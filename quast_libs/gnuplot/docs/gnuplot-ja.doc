C RCS $Id: gnuplot-ja.doc,v 1.54.2.3 2016/01/01 05:23:58 sfeam Exp $
C corresponding original gnuplot.doc revision: 1.902.2.20
C
C Copyright (C) 1986 - 1993, 1998, 1999, 2000, 2001, 2004   Thomas Williams, Colin Kelley et al.
C
C Japanese translation: Hiroharu Tamaru (2.0, 3.2), MASUTANI Yasuhiro (3.5),
C Shigeharu Takeno et al (3.7, 4.X, 5.X)
1 gnuplot
?gnuplot
C 下の contributors の表のアクセント文字は、現在のオリジナルでは UTF-8
C で書かれているが、それを HTML 名前参照形式に変更している。
^<h2 align="center"> An Interactive Plotting Program </h2>
^<p align="center">  Thomas Williams & Colin Kelley</p>
^<p align="center">  Version 5.0 organized by Ethan A Merritt and others</p>
^<p align="center">Major contributors (alphabetic order):<br>
^<br>
^  Hans-Bernhard Broeker, John Campbell,<br>
^  Robert Cunningham, David Denholm,<br>
^  Gershon Elber, Roger Fearick,<br>
^  Carsten Grammes, Lucas Hart,<br>
^  Lars Hecking, P&eacute;ter Juh&aacute;sz,<br>
^  Thomas Koenig, David Kotz,<br>
^  Ed Kubaitis, Russell Lang,<br>
^  Timoth&eacute;e Lecomte, Alexander Lehmann,<br>
^  Alexander Mai, Bastian M&auml;rkisch,<br>
^  Ethan A Merritt, Petr Mikul&iacute;k,<br>
^  Carsten Steger, Shigeharu Takeno,<br>
^  Tom Tkacik, Jos Van der Woude,<br>
^  James R. Van Zandt, Alex Woo, Johannes Zellner<br>
^</p>
^<p align="center">  Copyright (C) 1986 - 1993, 1998 - 2004   Thomas Williams, Colin Kelley<br>
^     Copyright (C) 2004 - 2014 various authors</p>
^<p align="center">   Mailing list for comments: <tt>gnuplot-info@lists.sourceforge.net</tt><br>
^      Mailing list for bug reports: <tt>gnuplot-bugs@lists.sourceforge.net</tt><br>
^      Web access (preferred): <tt>http://sourceforge.net/projects/gnuplot</tt></p>
^<p align="center"> This manual was originally prepared by Dick Crawford</p>
C 行が長いのは、できればなんとかしたい
2 著作権 (Copyright)
?copyright
?license
     Copyright (C) 1986 - 1993, 1998, 2004, 2007  Thomas Williams, Colin Kelley

 Permission to use, copy, and distribute this software and its
 documentation for any purpose with or without fee is hereby granted,
 provided that the above copyright notice appear in all copies and
 that both that copyright notice and this permission notice appear
 in supporting documentation.

 Permission to modify the software is granted, but not the right to
 distribute the complete modified source code.  Modifications are to
 be distributed as patches to the released version.  Permission to
 distribute binaries produced by compiling modified sources is granted,
 provided you
   1. distribute the corresponding source modifications from the
    released version in the form of a patch file along with the binaries,
   2. add special version identification to distinguish your version
    in addition to the base release version number,
   3. provide your name and address as the primary contact for the
    support of your modified version, and
   4. retain our contact information in regard to use of the base software.
 Permission to distribute the released version of the source code along
 with corresponding source modifications in the form of a patch file is
 granted with same provisions 2 through 4 for binary distributions.

 This software is provided "as is" without express or implied warranty
 to the extent permitted by applicable law.

       AUTHORS
               Original Software:
                  Thomas Williams,  Colin Kelley.
               Gnuplot 2.0 additions:
                  Russell Lang, Dave Kotz, John Campbell.
               Gnuplot 3.0 additions:
                  Gershon Elber and many others.
               Gnuplot 4.0 and 5.0 additions:
                  See list of contributors at head of this document.

 (以下おおまかな訳; 訳は正しくないかも知れませんので詳しくは上記の原文
 を当たってください。訳者は責任を持ちません。)

     Copyright (C) 1986 - 1993, 1998, 2004, 2007  Thomas Williams, Colin Kelley

 このソフトウェアとその付属文書の使用、複製、配布の許可は、上記の著作権
 (copyright) 表示が、全ての複製物に書かれていること、および著作権表示と
 この許諾文の両方がその支援文書に書かれていることを条件とした上で、この
 文書により保証されます。

 このソフトウェアの修正も認められています。しかし、修正を含む全ソースコ
 ードの配布の権利は認められません。修正はリリース版に対するパッチの形で
 配布しなければなりません。修正されたソースをコンパイルして作られたバイ
 ナリの配布は、以下の条件の元で認められます:
   1. リリース版からのソースの修正部分を、パッチの形でバイナリと共に配
      布すること
   2. ベースとなるリリース版と区別するために、そのバージョン番号に特別
      なバージョン指定子を付加すること
   3. その修正版のサポート用に、あなたの名前とアクセス可能なアドレスと
      を提供すること
   4. ベースとなるソフトウェアの使用に関しては、我々の連絡情報を保持し
      続けること
 リリース版のソースコードを、パッチの形でのソースの修正と一緒に配布する
 ことは、バイナリ配布に関する条項 2 から 4 までの条件の元で許されます。

 このソフトウェアは "あるがまま" 提供され、適用可能な法律で許められる範
 囲の保証を表明あるいは暗示していはいません。

       著者
               オリジナルソフトウェア:
                  Thomas Williams,  Colin Kelley.
               Gnuplot 2.0 追加:
                  Russell Lang, Dave Kotz, John Campbell.
               Gnuplot 3.0 追加:
                  Gershon Elber とその他の人々。
               Gnuplot 4.0, 5.0 追加:
                  この文書の先頭の寄与者 (contributors) の一覧参照。
2 はじめに (Introduction)
?introduction
?
 `gnuplot` は、ポータブルなコマンド入力方式のグラフユーティリティで、
 Linux, OS/2, MS Windows, OSX, VMS, その他多くのプラットホーム上で動作
 します。ソースコードには著作権がありますが、無料で配布されています (す
 なわち、それに対価を支払う必要はありません)。元は、科学者や学生が数学
 関数やデータなどを対話的に表示できるよう作られたのですが、現在までに、
 例えば Web スクリプトなど、多くの非対話型の利用もサポートするように成
 長しています。これは、例えば Octave のようにサードパーティのアプリケー
 ションの描画エンジンとしても使われています。gnuplot は、1986 よりサポ
 ートと活発な開発が行われています。

 gnuplot は、2 次元、または 3 次元の、多くの種類のグラフをサポートして
 います: 折線グラフ、点グラフ、棒グラフ、等高線、ベクトル場描画、曲面、
 そしてそれらに関連するさまざまな文字列等。そしてさらにいくつかの特別な
 描画型もサポートしています。

 gnuplot は多くの異なる出力をサポートしています: 対話型スクリーン出力形
 式 (マウスやホットキー入力も可能)、ペンプロッタや現在のプリンタへの直
 接出力、または多くのファイル形式への出力 (eps, emf, fig, jpeg, LaTeX,
 pdf, png, postscript, ...)。gnuplot は、容易に新しい出力形式を追加する
 よう拡張することができます。最近追加された対話型出力形式には、
 wxWidgets (複数のプラットホームで利用可能), Qt を元にしたものがありま
 す。svg や HTML5 canvas 出力形式を利用すれば、グラフを Web ページ内に
 マウス利用可能な形で埋め込んだ出力を生成することもできます。

 `gnuplot` のコマンド言語は大文字小文字を区別します。すなわち、小文字で
 書かれたコマンドや関数名は、それらを大文字で書いたものとは同じではあり
 ません。いずれのコマンドも、あいまいさの無い限りにおいて省略することが
 できます。1 行中にはセミコロン (;) で区切って複数のコマンドを書くこと
 ができます。文字列は単一引用符、あるいは二重引用符のどちらかで書き始め
 ますが、両者には微妙な違いがあります (詳細は、以下参照: `syntax`)。例:

       set title "My First Plot";  plot 'data';  print "all done!"

 コマンドは、複数行にまたがることができます。その場合は、最終行以外の
 全ての行の行末にバックスラッシュ (\) を書く必要があります。バックスラ
 ッシュは必ず各行 *最後* の文字でなくてはなりません。その結果としてバッ
 クスラッシュと、それに続く改行文字が存在しなかったかのように扱われます。
 つまり、改行文字がスペースの役をすることもありませんし、改行によってコ
 メントが終了することもありません。ですから複数行にまたがる行の先頭をコ
 メントアウトすると、そのコマンド全体がコメントアウトされることになりま
 す (以下参照: `comments`)。なお注意しますが、もし、複数行のコマンドの
 どこかでエラーが起きたとき、パーサはその場所を正確には指示することがで
 きませんし、また、正しい行に指示する必要もないでしょう。

 このドキュメントにおいて、中括弧 ({}) は省略可能な引数を表すものとし、
 縦棒 (|) は、互いに排他的な引数を区切るものとします。`gnuplot` のキー
 ワードや `help` における項目名は、逆引用符 (｀)、または可能な場合には
 `boldface` (太字) で表します。角括弧 (<>) は、それに対応するものに置き
 換えられるべきものを表します。多くの場合、オプションの引数には、それが
 省略されるとデフォルトの値が使用されます。しかし、これらの場合、必ずし
 も角括弧が中括弧で囲まれて書かれているわけではありません。

 ある項目についてのヘルプが必要なときには、`help` に続けてその項目名を
 入力して下さい。または単に `help ?` でもヘルプの項目のメニューが現われ
 ます。

 大量のグラフサンプルが、以下の Web ページにあります。
^ <a href="http://www.gnuplot.info/demo/">
           http://www.gnuplot.info/demo/
^ </a>
 コマンドラインから起動するときは、以下の書式が使えます。
       gnuplot {OPTIONS} file1 file2 ...
 ここで file1, file2 等は、`local` コマンドで取り込むのと同等の入力ファ
 イル (スクリプトファイル) です。
 X11 ベースのシステムでは、以下の書式が使えます。
       gnuplot {X11OPTIONS} {OPTIONS} file1 file2 ...
 詳細は、X11 のドキュメント、および以下参照: `x11`。

 gnuplot に与えるオプションは、コマンド行のどこに置いても構いません。フ
 ァイルは指定した順に実行され、同様に -e オプションで任意のコマンドを与
 えることもできます。例:
       gnuplot   file1.in   -e "reset"   file2.in

 特別なファイル名 "-" は、標準入力から読ませるのに使います。`gnuplot`
 は最後のファイルを処理し終わると終了します。読み込ませるファイルを一つ
 も指定しない場合は、`gnuplot` は標準入力からの対話入力を取ります。詳細
 は、以下参照: `batch/interactive`。gnuplot 用のオプションについては、
 以下のようにして一覧を見ることができます:
       gnuplot --help
 詳細は以下参照: `command line options`。

 対話型描画ウィンドウでの作業中は、'h' を打つとホットキー (`hotkeys`)
 とマウス機能 (`mousing`) に関するヘルプを見ることができます。
 `seeking-assistance` のセクションは、さらなる情報やヘルプ、FAQ を探す
 手掛りを与えてくれるでしょう。
2 探し出す手助け (Seeking-assistance)
?help-desk
?faq
?FAQ
?seeking-assistance
 公式の gnuplot Web ページは以下にあります。
^ <a href="http://www.gnuplot.info">
           http://www.gnuplot.info
^ </a>

 助けを求める前に、ファイル FAQ.pdf か、または上の Web サイトの
^ <a href="http://www.gnuplot.info/faq/">
           FAQ (度々聞かれる質問; Frequently Asked Questions) の一覧
^ </a>
 をチェックしてください。

 gnuplot ユーザとしての手助けが必要なら、以下のニュースグループを利用し
 てください。
           comp.graphics.apps.gnuplot
 私達はメーリングリストに参加するより、むしろニュースグループのメッセー
 ジを読むことを勧めます。メーリングリストも有効で、同じメッセージ列を配
 送しています。メーリングリストに参加する方法に関しては、SouceForge に
 ある gnuplot の開発 Web サイト
^ <a href="http://sourceforge.net/projects/gnuplot">
           http://sourceforge.net/projects/gnuplot
^ </a>
 を参照してください。

 メーリングリストメンバーへのメールアドレス:
           gnuplot-info@lists.sourceforge.net

 バグリポート、ソースの改良等は以下の trackers に upload してください:
           http://sourceforge.net/projects/gnuplot/support
 ただし、リポートを送る前に、あなたがリポートしようとしているバグが、よ
 り新しい版で既に修正されていないかチェックしてください。

 開発版に関するメーリングリスト:
           gnuplot-beta@lists.sourceforge.net

 何か質問を投稿するときは、あなたが使用している gnuplot のバージョン、
 出力形式、オペレーティングシステム、といった全ての情報を含むようにして
 ください。その問題を引き起こす「小さい」スクリプトがあればなお良いです。
 その場合、データファイルのプロットよりも関数のプロットの方がより良いで
 す。

2 バージョン 5 での新しい機能 (New features in version 5)
?new-features

 * 線の点線/破線パターンは、現在は線の他の属性と独立に指定できます。以
 下参照: `dashtype`, `set dashtype`, `set linetype`。

 * 文字の書式制御は、下付き、上付き、フォントサイズ、その他以前有効だっ
 たものに加え、今は太字体 (bold) と斜体 (italic) フォント設定もサポート
 しています。このモード (拡張文字処理) は、現在はデフォルトで有効となっ
 ています。以下参照: `enhanced text`。

 * 対話型出力形式は、ハイパーテキストラベルをサポートしていますが、これ
 はマウスがそのラベルのリンク点上にあるときにのみ現れるものです。

 * 新しい座標系 (度、分、秒)。以下参照: `set xtics geographic`。

 * 軸の見出しのデフォルト書式用の "% h" (LaTeX 系出力形式では "$%h$")。
 この書式は C の標準書式の %g に似ていますが、指数部分がある場合には、
 それが上付き文字として書かれることが違います。例えば、1.2E05 でなく、
 1.2 x 10^5 となります。

 * スクリプト内で、インラインデータを名前付きのデータブロックとして保存
 し繰り返し描画できるように。以下参照: `inline data`。

 * 32-bit のアルファ値 + RGB 色表記 (#AARRGGBB) をサポート。以下参照:
 `colorspec`。

 * hsv2rgb(H,S,V) という変換関数により HSV 色空間をサポート。

 * 第 2 軸 (x2, y2) は、対応関数により、第 1 軸に固定できます。最も単純
 なのは、これにより第 1 軸と 2 軸の軸の範囲を一致させることです。より一
 般に、これにより非線形な軸を定義できるようになりますが、これまではその
 ようなことは対数軸しかできませんでした。以下参照: `set link`。

 * plot コマンドの各関数にオプションとして描画範囲を前置指定できます。
 これは、plot 全体の範囲には影響せず、その関数のデータをサンプリングす
 る範囲でしかありません。以下参照: `plot`, `piecewise.dem`。

 * 外部ライブラリ libcerf が利用可能であれば、それは複素数学関数 cerf,
 cdawson, erfi, faddeeva, および Voigt プロファイル VP(x,sigma,gamma)
 を提供するのに使われます。

 * コマンド `import` は、外部共有オブジェクト (サポートはオペレーティン
 グシステム依存) が提供する関数にユーザ定義関数名を割り当てます。適当な
 外部共有オブジェクトを作るためのテンプレートヘッダファイル、サンプルソ
 ース、makefile などが demo の中にあります。

 * 対話作業の履歴一覧内の直前のコマンドは、番号で再実行できます。例えば
 `history !5` は、`history` の一覧内の 5 番のコマンドを再実行します。

 * ビットシフト演算子 >> と <<。

 * 新しい描画スタイル `with parallelaxes`、`with table`、および等高線の
 ラベル付け。

 * gnuplot のシェル呼び出しで gnuplot スクリプトにパラメータを渡せます。
 gnuplot -c scriptfile.gp ARG1 ARG2 ARG3 ...

3 新しいコマンド (New commands)
#start
# import f(x) from "plugin.so"             # 共有ライブラリから関数を読み込み
# set history {quiet|numers} {full|trim}   # history コマンド出力の制御
# history !N                               # 以前のコマンドを番号で再実行
# plot <datafile> skip N                   # テキストデータ先頭数行をスキップ
# plot ... smooth mcsplines                # データに沿う単調 3 次スプライン
# reset session                            # 現在の作業の初期状態を復帰
# set arrow <tag> from <start> length <len> angle <ang>
# set colorsequence default|classic|podo   # 以後の描画要素で使用する色
# set dashtype <tag> <dash-spec>           # ユーザ定義破線パターン
# set link x2 via f(x) inverse g(x)        # 非線形軸スケールを可能に
# set fit quiet|results|brief|verbose      # fit 出力量の制御
# set contours; splot ... with labels      # 数値での等高線のラベル
# set style textbox                        # 文字列要素に外枠をつける
# set view map {scale}                     # 3D 射影描画のリサイズが可能に
# set multiplot {next|previous}            # 自動レイアウト格子内での移動
#end

2 バージョン 5 での変更 (Changes in version 5)
?changes
 バージョン 5 で導入された以下の変更は、前の版の gnuplot 用のスクリプト
 の挙動を変える可能性があります。

 * NaN や、正しくないデータ列数、または他の予期しないものを含む入力デー
 タの処理の改良。例 (や図) については、以下参照: `missing`。

 * 時間座標は、標準的な Unix エポック (1970 年 1 月 1 日) からの秒数と
 して内部で保存します。以前の版の gnuplot では、別のエポック (2000 年
 1 月 1 日) を内部で使用していました。この変更は、gnuplot の外で作られ
 た秒単位のデータによって矛盾がもたらされる問題を解決します。インストー
 ルされている個々の gnuplot がどちらのエポックを使用しているかについて
 は、コマンド `print strftime("%F",0)` で知ることができます。現在は、時
 間は少なくともミリ秒の精度で保存されます。

 * 関数 `timecolumn(N,"timeformat")` は、現在は 2 つの引数を持ちます。
 新しい 2 つ目の引数はどのデータ軸とも関連しておらず、よってこれにより
 関数 `timecolumn` を、x や y 軸に指定するのとは違う形式の日時データの
 読み込みに使えるようになります。この機能は、次のコマンド列に取って変わ
 ります: `set xdata time; set timefmt "timeformat"`。これは、複数のファ
 イルから異なる書式の日時データを読んで、それらを組み合わせて 1 つのグ
 ラフにすることを可能にします。

 * コマンド `set [axis]range` のキーワード `reverse` は、自動縮尺
 (autoscaling) にのみ影響し、`set xrange [0:1]` のようなコマンドの意味
 を逆にしたり他の変更を行ったりはしません。このような場合に x 軸の方向
 を逆向きにしたければ、代わりに `set xrange [1:0]` としてください。

 * コマンド `call` は、変数群 ARGC, ARG0, ..., ARG9 を提供するよう実装
 されています。ARG0 は、実行するスクリプト名を指します。ARG1 から ARG9
 は文字列変数になるので、直接参照するか、または例えば @ARG1 のようにマ
 クロ展開させたものを参照することができます。call の古いパラメータ参照
 形式 $0 ... $9 は現在は非推奨です。

 * オプション smooth の kdensity の、bandwidth の追加指定では、データ列
 からでなく 1 つのキーワードとして値を取ります。以下参照:
 `smooth kdensity`。

 * `unset xrange` (および他の軸の範囲も) は、元のデフォルトの範囲を復帰
 します。

 * `unset terminal` は、gnuplot 開始時の出力形式を復帰します。

2 非推奨な書式 (Deprecated syntax)
?deprecated syntax
?backwards compatibility
?compatibility
 以前の版で使われていたいくつかの書式は gnuplot 4 で非推奨となりました
 が、後方互換性を持たせるためのコンパイル時のオプションが用意されていま
 す。古い書式のサポートは現在は削除されています。

 gnuplot 4 では非推奨で、バージョン 5 では削除:
       set title "Old" 0,-1
       set data linespoints
       plot 1 2 4               # y=1 での水平線
 現在の同等の機能:
       TITLE = "New"
       set title TITLE offset char 0, char -1
       set style data linespoints
       plot 1 linetype 2 pointtype 4
 バージョン 5 では --enable-backwards-compatibility で構築された場合を
 除き非推奨 (だがまだ使える):
       if (defined(VARNAME)) ...
       set style increment user
       plot 'file' thru f(x)
       call 'script' 1.23 ABC
          (in script:  print $0, "$1", "number of args = $#")
 現在の同等の機能:
       if (exists("VARNAME")) ...
       set linetype
       plot 'file' using 1:(f(column(2)))
       call 'script' 1.23 "ABC"
          (in script:  print ARG1, ARG2, "number of args = ", ARGC

2 バッチ/対話型操作 (Batch/Interactive)
?batch/interactive
?command line options
 `gnuplot` は多くのシステム上で、バッチ処理形式、あるいは対話型のどちら
 の形式でも実行でき、それらを組み合わせることも可能です。

 コマンドライン引数は、プログラムへのオプション (文字 - で始まる) か、
 `gnuplot` コマンドを含むファイルの名前であると解釈されます。
 -e "command" の形式のオプションは、gnuplot コマンドを強制的に実行させ、
 各ファイルとこのコマンド文字列は、指定された順に実行されます。特別なフ
 ァイル名 "-" は、コマンドを標準入力から読み込むことを意味します。最後
 のファイルを実行した後に `gnuplot` は終了します。読み込ませるファイル、
 およびコマンド文字列を指定しなかった場合は、`gnuplot` は標準入力からの
 対話型の入力を受け付けます。

 `exit` と `quit` はどちらも現在のコマンドファイルを終了し、まだ全ての
 ファイルが終っていなければ、次のファイルを `load` するのに使われます。

 例:

 対話を開始する:
       gnuplot

 2 つのコマンドファイル "input1", "input2" を使ってバッチ処理を行なう:
       gnuplot input1 input2

 初期化ファイル "header" の後、対話型モードを起動し、その後別のコマンド
 ファイル "tailer" を実行する:
       gnuplot header - trailer

 コマンドラインから `gnuplot` コマンドを直接与え、終了後にスクリーン上
 にグラフが残るようにオプション "-persist" を使う:
        gnuplot -persist -e "set title 'Sine curve'; plot sin(x)"

 ファイルのコマンドを実行する前に、ユーザ定義変数 a と s をセットする:
       gnuplot -e "a=2; s='file.png'" input.gpl

2 キャンバスサイズ (Canvas size)
?canvas size
?canvas
?set term size

 gnuplot の以前の版では、`set size` の値を、出力する描画領域 (キャンバ
 ス) のサイズを制御するのにも使っていた出力形式もありましたが、すべての
 出力形式がそうだったわけではありませんでした。この目的のために
 `set size` を使用することはバージョン 4.2 で非推奨となり、現在はほとん
 どの出力形式が以下のルールに従います:

 `set term <terminal_type> size <XX>, <YY>` は、出力ファイルのサイズ、
 または "キャンバス" のサイズを制御します。デフォルトでは、グラフはその
 キャンバス全体に描画されます。

 `set size <XX>, <YY>` は、描画自体をキャンバスのサイズに対して相対的に
 伸縮させます。1 より小さい伸縮値を指定すると、グラフはキャンバス全体を
 埋めず、1 より大きい伸縮値を指定すると、グラフの一部分のみがキャンバス
 全体に合うように描画されます。1 より大きい伸縮値を指定すると、ある出力
 形式では問題が起こるかもしれないことに注意してください。

 このルールに沿わない主な例外は PostScript ドライバで、デフォルトでは以
 前の版のと同じ振舞いをしますが、将来は PostScript ドライバも同様にデフ
 ォルトの振舞いを変更することになるでしょう。

 例:

       set size 0.5, 0.5
       set term png size 600, 400
       set output "figure.png"
       plot "data" with lines

 このコマンドは、幅 600 ピクセル、高さ 400 ピクセルの出力ファイル
 "figure.png" を生成します。グラフはキャンバスの中の左下に置かれます。
 これは、multiplot モードが常に行ってきた方法と矛盾しません。

2 コマンドライン編集 (Command-line-editing)
?line-editing
?editing
?command-line-editing
 コマンドラインでの編集機能とコマンドヒストリの機能は、外部の GNU
 readline ライブラリか外部の BSD libedit ライブラリ、または組み込まれて
 いる同等のもののいずれかを使ってサポートしています。この選択は、
 gnuplot のコンパイル時の configure のオプションで行います。

 組み込みの readline 版の場合の編集コマンドは以下の通りですが、DEL キー
 に関する動作はシステムに依存することに注意してください。GNU readline
 ライブラリと BSD libedit ライブラリに関しては、それ自身のドキュメント
 を参照してください。

@start table - まずは対話型テキスト形式
       `行編集`:

       ^B    1 文字前へ戻す
       ^F    1 文字先へ進める
       ^A    行の先頭に移動
       ^E    行の最後に移動
       ^H    直前の文字を削除
       DEL   現在の文字を削除
       ^D    現在位置の文字を削除、空行なら EOF を送信
       ^K    現在位置から行末まで削除
       ^L,^R 壊れた表示の行を再表示
       ^U    行全体の削除
       ^W    直前の単語を削除

       `履歴`:

       ^P    前の履歴へ移動
       ^N    次の履歴へ移動
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{コマンド行編集コマンド} \\ \hline \hline
#文字 & 機能 \\ \hline
# & \multicolumn{1}{|c|}{行編集}\\ \cline{2-2}
#\verb~^B~ & 1 文字前へ戻す\\
#\verb~^F~ & 1 文字先へ進める\\
#\verb~^A~ & 行の先頭へ移動\\
#\verb~^E~ & 行の最後へ移動\\
#\verb~^H~ & 直前の文字を削除\\
#\verb~DEL~ & 現在の文字を削除\\
#\verb~^D~ & 現在位置の文字を削除、空行なら EOF\\
#\verb~^K~ & 現在位置から行末まで削除\\
#\verb~^L, ^R~ & 壊れた表示の行を再表示\\
#\verb~^U~ & 行全体の削除\\
#\verb~^W~ & 直前の単語を削除\\ \hline
# & \multicolumn{1}{|c|}{履歴} \\ \cline{2-2}
#\verb~^P~ & 前の履歴へ移動\\
#\verb~^N~ & 次の履歴へ移動\\
%c l .
%文字@機能
%_
%@行編集
%^B@1 文字前へ戻す
%^F@1 文字先へ進める
%^A@行の先頭に移動
%^E@行の最後に移動
%^H@直前の文字を削除
%DEL@現在の文字を削除
%^D@現在位置の文字を削除、空行なら EOF
%^K@現在位置から行末まで削除
%^L, ^R@壊れた表示の行を再表示
%^U@行全体の削除
%^W@直前の単語を削除
%_
%@履歴
%^P@前の履歴へ移動
%^N@次の履歴へ移動
@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>文字</th>    <th>機能</th></tr>
^</thead>
^<tbody>
^<tr>    <td></td>    <th>行編集</th></tr>
^<tr>    <td><tt>^B</tt></td>    <td>1 文字前へ戻す</td></tr>
^<tr>    <td><tt>^F</tt></td>    <td>1 文字先へ進める</td></tr>
^<tr>    <td><tt>^A</tt></td>    <td>行の先頭へ移動</td></tr>
^<tr>    <td><tt>^E</tt></td>    <td>行の最後へ移動</td></tr>
^<tr>    <td><tt>^H</tt></td>    <td>直前の文字を削除</td></tr>
^<tr>    <td><tt>DEL</tt></td>    <td>現在の文字を削除</td></tr>
^<tr>    <td><tt>^D</tt></td>    <td>現在位置の文字を削除、空行なら EOF</td></tr>
^<tr>    <td><tt>^K</tt></td>    <td>現在位置から行末まで削除</td></tr>
^<tr>    <td><tt>^L, ^R</tt></td>    <td>壊れた表示の行を再表示</td></tr>
^<tr>    <td><tt>^U</tt></td>    <td>行全体の削除</td></tr>
^<tr>    <td><tt>^W</tt></td>    <td>直前の単語を削除</td></tr>
^</tbody>
^<tbody>
^<tr>    <th></th>    <th>履歴</th></tr>
^<tr>    <td><tt>^P</tt></td>    <td>前の履歴へ移動</td></tr>
^<tr>    <td><tt>^N</tt></td>    <td>次の履歴へ移動</td></tr>
^</tbody>
^</table>
2 コメント (Comments)
?comments
 コメントは次のように実装されています: 文字 '#' は、行中のたいていの場
 所に書くことができます。このとき `gnuplot` はその行の残りの部分を無視
 します。ただし、引用符の中、数 (複素数を含む) の中、コマンド置換
 (command substitution) の中などではこの効果がありません。簡単に言うと
 意味のあるような使い方をしさえすれば、正しく動作すると言うことです。

 データファイル中のコメント文字の指定については、以下参照:
 `set datafile commentschars`。コメント行が '\' で終わっている場合、次
 の行もコメントとして扱われることに注意してください。
2 座標系 (Coordinates)
?coordinates
=axes
 コマンド `set arrow`, `set key`, `set label`, `set object` はグラフ上
 の任意の位置が指定できます。その位置は以下の書式で指定します:

       {<system>} <x>, {<system>} <y> {,{<system>} <z>}

 各座標系指定 <system> には、`first`, `second`, `graph`, `screen`,
 `character` のいずれかが入ります。

 `first` は左と下の軸で定義される x,y (3D の場合は z も) の座標系を使用
 します。`second` は x2, y2 軸 (上と右の軸) を使用します。`graph` はグ
 ラフ描画領域内の相対的位置を指定し、左下が 0,0 で 右上が 1,1 (splot の
 場合はグラフ描画領域内の左下が 0,0,0 で、土台の位置は負の z の値を使用
 します。以下参照: `set xyplane`) となります。`screen` は表示範囲内 (範
 囲全体であり、`set size` で選択される一部分ではありません) を指定し、
 左下が 0,0 で 右上が 1,1 となります。`character` は、画面領域の左下
 (screen 0,0) からの、文字の幅、文字の高さでの位置を与えます。よって、
 `character` 座標は、選択されたフォントのサイズに依存します。

 x の座標系が指定されていない場合は `first` が使われます。y の座標系が
 指定されていない場合は x に対する座標系が使用されます。

 与える座標が絶対的な位置ではなくて相対的な値である場合もあります (例え
 ば `set arrow` ... `rto` の 2 番目の数値)。そのほとんどが、与えられた
 数値を最初の位置に対する差として使います。与えられた座標が対数軸内にあ
 る場合は、その相対的な値は倍率として解釈されます。例えば

       set logscale x
       set arrow 100,5 rto 10,2

 は、x 軸が対数軸で y 軸が線形の軸なので、100,5 の位置から 1000,7 の位
 置への矢印を書くことになります。

 一つ (あるいはそれ以上) の軸が時間軸である場合、`timefmt` の書式文字列
 に従って、引用符で囲まれた時間文字列で適切な座標を指定する必要がありま
 す。以下参照: `set xdata`, `set timefmt`。また、`gnuplot` は整数表記も
 認めていて、その場合その整数は 1970 年 1 月 1 日からの秒数と解釈されま
 す。
2 文字列データ (Datastrings)
?datastrings
 データファイルには、ホワイトスペース (空白やタブ) を含まない任意の印字
 可能な文字列、あるいは 2 重引用符で囲まれた任意の文字列 (ホワイトスペ
 ースが含まれても良い)、のいずれかの形からなる文字列データを持たせるこ
 とも可能です。データファイルに次のような行が含まれている場合、それは 4
 つの列を含み、3 列目がテキスト部分であると見なされます:

   1.000 2.000 "Third column is all of this text" 4.00

 テキスト部分は 2 次元や 3 次元描画内で例えば以下のように使用されます:

   plot 'datafile' using 1:2:4 with labels
   splot 'datafile' using 1:2:3:4 with labels

 テキスト部分の列データは 1 つ、または複数の描画軸の目盛りのラベルとし
 て使用できます。次の例は、入力データの 3 列目と 4 列目を (X,Y) 座標と
 して取り出し、それらの点の列を結ぶ線分を描画します。しかしこの場合
 gnuplot は、x 軸に沿って標準的に間の空いた数字ラベルのついた目盛り刻み
 をつけるのではなく、入力データファイルの 1 行目の X 座標の位置に、目盛
 り刻みと文字列を x 軸に沿ってつけて行きます。

   set xtics
   plot 'datafile' using 3:4:xticlabels(1) with linespoints

=columnheader
 入力データの列の最初のエントリ (すなわち列の見出し) をテキスト部分と解
 釈するもう一つのオプションがあり、それはテキスト部分を、その描画した列
 のデータの凡例 (key) のタイトル部分として使用します。次の例は、先頭の
 行の 2 列目の部分を凡例ボックス内のタイトルを生成するのに使用し、その
 後の列の 2,4 列目は要求された曲線を描画するのに処理されます:

   plot 'datafile' using 1:(f($2)/$4) with lines title columnhead(2)

 別の例:

   plot for [i=2:6] 'datafile' using i title "Results for ".columnhead(i)

 以下参照: `labels`, `using xticlabels`, `plot title`, `using`。
2 拡張文字列処理モード (Enhanced text mode)
?enhanced text
?enhanced
?text_markup
?markup
 多くの出力形式が、拡張文字列処理モード (enhanced text mode) をサポート
 しています。これは、文字列に追加の書式情報を埋めこみます。例えば "x^2"
 は x の自乗を、通常我々が見る上付きの 2 がついた形で書き出します。この
 モードは、出力形式の設定時にデフォルトとして選択されますが、その後で
 "set termoption [no]enhanced" を使ってその機能を有効/無効にもできます
 し、"set label 'x_2' noenhanced" のように個々の文字列に適用することも
 できます。

@start table - まずは対話型テキスト形式
  制御記号     例              説明
   ^           a^x             上付き文字
   _           a_x             下付き文字
   @           @x, a@^b_{cd}   空ボックス (幅がない)
   &           &{space}        指定した長さのスペースを挿入
   ~           ~a{.8-}         'a' の上に '-' を、現在のフォントサ
                               イズの .8 倍持ち上げた位置に重ね書き
   {/Times abc}                Times フォント、今のサイズで abc を出力
   {/Times*2 abc}              Times フォント、今の倍のサイズで abc
   {/Times:Italic abc}         TImes フォント、イタリック体で abc
   {/Arial:Bold=20 abc}        Arial フォント、太字、サイズ 20 で abc
#\begin{tabular}{|clll|} \hline
#\multicolumn{4}{|c|}{拡張文字列制御記号} \\ \hline
#制御記号 & 例 & 結果 & 説明 \\ \hline
#\verb~^~ & \verb~a^x~ & $a^x$ & 上付き文字\\
#\verb~_~ & \verb~a_x~ & $a_x$ & 下付き文字\\
#\verb~@~ & \verb~a@^b_{cd}~ & $a^b_{cd}$ & 空ボックス (幅がない)\\
#\verb~&~ & \verb~d&{space}b~ & d\verb*+     +b & 指定した長さのスペースを挿入\\
#\verb|~| & \verb|~a{.8-}| & $\tilde{a}$ & 'a' の上に '-' を、現在のフォントサ\\
#\verb~ ~ & \verb~ ~ & ~ ~ & イズの .8 倍持ち上げた位置に重ね書き\\
#\verb| | & \verb|{/Times abc}| & {\rm abc} & Times フォント、今のサイズで abc を出力\\
#\verb| | & \verb|{/Times*2 abc}| & \Large{\rm abc} & Times フォント、今の倍のサイズで abc\\
#\verb| | & \verb|{/Times:Italic abc}| & {\it abc} & Times フォント、イタリック体で abc\\
#\verb| | & \verb|{/Arial:Bold=20 abc}| & \Large\textsf{\textbf{abc}} & Arial フォント、太字、サイズ 20 で abc\\
%c c l .
%.TE", /* ugly - doc2ms uses @ for column separator, but here we */
%.TS", /* need @ in table, so end and restart the table ! */
%center box tab ($) ;
%c c l .
%制御記号$例$説明
%_
%^$a^x$上付き文字
%\&_$a\&_x$下付き文字
% @ $ @x, a\&@^b\&_{cd}$空ボックス (幅がない)
% & $ &{space}$指定した長さのスペースを挿入
% ~ $ ~a{.8-}$'a' の上に '-' を、現在のフォントサ
%   $   $イズの .8 倍持ち上げた位置に重ね書き
@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>制御記号</th>    <th>例</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt> ^ </tt></td>    <td><tt>a^x</tt></td>    <td>上付き文字</td></tr>
^<tr>    <td><tt> _ </tt></td>    <td><tt>a_x</tt></td>    <td>下付き文字</td></tr>
^<tr>    <td><tt> @ </tt></td>    <td><tt> @x</tt>, <tt>a@^b_{cd}</tt></td>    <td>空ボックス (幅がない)</td></tr>
^<tr>    <td><tt> &amp;</tt></td>    <td><tt> &amp;{space}</tt></td>    <td>指定した長さのスペースを挿入</td></tr>
^<tr>    <td><tt> ~ </tt></td>    <td><tt> ~a{.8-}</tt></td>    <td>'a' の上に '-' を、現在のフォントサ<br>イズの .8 倍持ち上げた位置に重ね書き</td></tr>
^</tbody>
^</table>

 書式制御文字は、それに続く 1 文字、または中カッコで囲まれたものに適用
 されます。中カッコ内には、例えば 2^{10} のような追加の書式文字列のない
 文字列か、またはフォントの属性を変更する追加制御文字列を入れることがで
 きます。以下の例はその中カッコの入れ子を示していて、ボールド体の A に
 イタリック体の下付きの添字 i がついたものが、いずれも現在のフォントで
 描かれます。この例の :Normal を取ると、下付きの添字はボールド体でかつ
 イタリック体になります。
      {/:Bold A_{/:Normal{/:Italic i}}}
 フォント指定は、開き中カッコ '{' の直後に続く '/' のすぐ次に書かなけれ
 ば「いけません」。

 空ボックス (phantom box) は a@^b_c の上付き文字と下付き文字を揃えると
 きに有用ですが、文字にアクセント記号を重ねる場合にはうまく働きません。
 後者の目的のためには、色々なアクセントやその他のダイアクリティカルマ
 ークのある多くの文字を持つエンコード (例えば iso_8859_1 や utf8) を使
 用する方がいいでしょう。以下参照: `set encoding`。そのボックスはスペー
 シングが行なわれないので、ボックス内 (つまり @ の後ろ) の上付き文字や
 下付き文字を短く出力するのに適しています。

 ある文字列と同じ長さのスペースを文字 '&' を使うことで入れることができ
 ます。すなわち、
         'abc&{def}ghi'
 は以下を生成します (abc と ghi の間は 3 文字分の空白):
         'abc   ghi'

 文字 '~' は、次の文字、またはカッコで囲まれた文字列に、それに続く文字
 またはカッコで囲まれた文字列を重ね書きします。2 番目の文字は最初の文字
 にあわせて水平方向にセンタリングされます。よって '~a/' は 'a' を貫くよ
 うなスラッシュが得られます。2 番目の文字は、その前に数字を置くことで垂
 直方向に移動させることができます。その数字は現在のフォントサイズに対す
 る割合を意味し、それに従って文字が上がったり下がったりします。この場合
 数字と文字列は 1 文字より長くなるのでカッコで囲む必要があります。重ね
 書きされる文字列が数字から始まっている場合は、垂直にずらす値と文字列と
 の間にスペースを入れてください ('~{abc}{.5 000}')。それ以外はスペース
 は不要です ('~{abc}{.5---}')。一方、あるいは両方のフォントを変更するこ
 ともできます ('~a{.5 /*.2 o}'; 'a' その 1/5 の大きさの 'o'、この場合数
 字とスラッシュの間のスペースは必要です) が、その文字列が始まった後で変
 更することはできません。それぞれの文字列内で、他の特殊な書式を使うこと
 もできません。もちろん、'~a{\^}' のように特殊な文字をエスケープするこ
 と (下記参照) は可能です。

 特殊記号は、8 進文字コードを与えることで数字で指定できます。例えば、
 {/Symbol \245} は、Adobe Symbol フォントの無限大の記号です。しかし、こ
 れは、 UTF-8 のようなマルチバイトエンコーディングではうまくいきません。
 UTF-8 環境では、タイプ打ち、そうでなければあなたが望む文字を選ぶような
 方法で、マルチバイト列を間接的に入力できるようにすべきです。

 制御文字は、 \\ や \{ などのように \ を使ってエスケープできます。

 二重引用符内の文字列は単一引用符内の文字列とは異なって解釈されることに
 注意してください。主な違いは、二重引用符内の文字列ではバックスラッシュ
 は 2 つ重ねる必要があることです。

 gnuplot ソース配布物内の /docs/psdoc サブディレクトリにあるファイル
 "ps_guide.ps" に、拡張された書式に関する例が載っています。同様のものが
 デモ
^ <a href="http://www.gnuplot.info/demo/enhanced_utf8.html">
 `enhanced_utf8.dem`
^ </a>
 にもあります。
2 環境変数 (Environment)
?environment
 `gnuplot` は多くのシェル環境変数を認識します。必須のものはありませんが、
 使えば便利になるかも知れません。

 GNUTERM は、それが定義されていれば、起動時のデフォルト出力形式として使
 われます。これは、~/.gnuplot (またはそれに相当する) 初期化ファイル (以
 下参照: `startup`) による指定や、もちろんその後の明示的な `set term`
 コマンドによる指定で変更できます。

 GNUHELP にヘルプファイル (gnuplot.gih) のパス名を定義しておくことがで
 きます。

 VMS では、論理名 GNUPLOT$HELP を `gnuplot` のヘルプライブラリの名前と
 して定義します。`gnuplot` のヘルプは任意の VMS システムのヘルプライブ
 ラリに入れることができます。

 Unix においては、カレントディレクトリに .gnuplot というファイルがない
 場合には、HOME に定義されたディレクトリを探します。MS-DOS, Windows,
 OS/2 では GNUPLOT がその役割に使われます。Windows では、NT 専用の変数
 USERPROFILE も参照されます。VMS では SYS$LOGIN です。`help startup`
 と打ってみてください。

 Unix においては、PAGER がヘルプメッセージの出力用のフィルタとして使わ
 れます。

 Unix では、SHELL が `shell` コマンドの際に使われます。MS-DOS, OS/2 で
 は COMSPEC が `shell` コマンドの際に使われます。

 `FIT_SCRIPT` は、当てはめ (fit) が中断されたときに実行する `gnuplot`
 コマンドの指定に使われます。以下参照: `fit`。`FIT_LOG` は当てはめによ
 るログファイルのデフォルトのファイル名の指定に使われます。

 GNUPLOT_LIB は、データやコマンドファイルの検索ディレクトリを追加定義す
 るのに使われます。その変数は、一つのディレクトリ名かまたは複数のディレ
 クトリ名を書くことができますが、ディレクトリの区切りはプラットホーム毎
 に違います。例えば Unix では ':' で、MS-DOS, Windows, OS/2 では ';' で
 す。GNUPLOT_LIB の値は変数 `loadpath` に追加されますが、それは `save`
 や `save set` コマンドでは保存されません。

 出力ドライバの中には gd ライブラリ経由で TrueType フォントを扱えるもの
 もいくつかあります。これらのドライバのフォント検索パスは、環境変数
 GDFONTPATH で制御できます。さらに、それらのドライバでのデフォルトのフ
 ォントは環境変数 GNUPLOT_DEFAULT_GDFONT で制御できます。

 postscript 出力ドライバは自分で持っているフォント検索パスを使いますが、
 それは環境変数 GNUPLOT_FONTPATH で制御できます。書式は GNUPLOT_LIB と
 同じです。GNUPLOT_FONTPATH の値は変数 `fontpath` に追加されますが、そ
 れは `save` や `save set` コマンドでは保存されません。

 PostScript ドライバは、外部 (組み込まれていない) 定義ファイルを探すた
 めに環境変数 GNUPLOT_PS_DIR を利用します。インストール時の作業により、
 gnuplot にはそれらのファイルのコピーが組み込まれているか、またはデフォ
 ルトのパスが埋め込まれています。この変数は、postscript 出力形式でデフ
 ォルトのファイルの代わりにカスタマイズした prologue ファイルを使用する
 のに利用できます。以下参照: `postscript prologue`。
2 式 (Expressions)
?expressions
 基本的には C, FORTRAN, Pascal, BASIC において利用可能な数学表現を使用
 できます。 演算子の優先順位は C 言語の仕様に従います。数式中の空白文字
 とタブ文字は無視されます。

 複素数の定数は {<real>,<imag>} と表現します。ここで <real> と <imag>
 (実部、虚部) は数値定数である必要があります。例えば {3,2} は 3 + 2i を
 あらわし、{0,1} は 'i' 自身を表します。これらには明示的に中カッコを使
 う必要があります。

=division
 gnuplot は "実数" と "整数" 演算を FORTRAN や C のように扱うということ
 に注意してください。"1", "-10" などは整数と見なされ、"1.0", "-10.0",
 "1e1", 3.5e-1 などは実数と見なされます。 これら 2 つのもっとも重要な違
 いは割算です。整数の割算は切り捨てられます: 5/2 = 2。実数はそうではあ
 りません: 5.0/2.0 = 2.5。それらが混在した式の場合、計算の前に整数は実
 数に "拡張" されます: 5/2e0 = 2.5。負の整数を正の整数で割る場合、その
 値はコンパイラによって変わります。"print -5/2" として、あなたのシステ
 ムが -2 と -3 のどちらを答えとするかを確認してください。

 数式 "1/0" は "未定義値 (undefined)" フラグを生成し、それによりその点
 を無視します。あるいは、あらかじめ定義されている値 NaN を使っても同じ
 ことになります。例については、以下参照: `using`。
=NaN

 複素数表現の実数部分、虚数部分は、どんな形で入力されても常に実数です:
 {3,2} の "3" と "2" は実数であり、整数ではありません。

 gnuplot は文字列に対する単純な演算、および文字列変数も利用できます。例
 えば式 ("A" . "B" eq "AB") は真と評価されますが、これは文字列の結合演
 算子と文字列の等号演算子を意味しています。

 数としての値を含む文字列は、それが数式で利用された場合は、対応する整数
 や実数に変換されます。よって、("3" + "4" == 7) や (6.78 == "6.78") は
 どちらも真になります。整数は、それが文字列結合演算子で使われた場合は文
 字列に変換されますが、実数や複素数はダメです。典型的な例は、ファイル名
 や他の文字列内に整数を使う場合でしょう: 例えば ("file" . 4 eq "file4")
 は真です。

 後置指定する範囲記述子 [beg:end] によって、部分文字列を指定することが
 できます。例えば、"ABCDEF"[3:4] == "CD" で、"ABCDEF"[4:*] == "DEF" で
 す。書式 "string"[beg:end] は、文字列値の組み込み関数
 substr("strings",beg,end) を呼ぶこととほぼ同じですが、関数呼び出しでは
 beg, end は省略することはできません。
3 関数 (Functions)
?expressions functions
 特に注意がなければ、`gnuplot` の数学関数の引数は整数、実数、複素数の値
 を取ることができます。角を引数や戻り値とする関数 (例えば sin(x)) は、
 その値をラジアンとして扱いますが、これはコマンド `set angles` によって
 度に変更できます。

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3" width="90%">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th colspan="3"> 数学ライブラリ関数 </th></tr>
^<tr>    <th>関数</th>    <th>引数</th>    <th>戻り値</th></tr>
^</thead>
^<tbody>
^<tr>    <td>abs(x)</td>    <td>任意</td>    <td>|<i>x</i>|, <i>x</i> の絶対値; 同じ型</td></tr>
^<tr>    <td>abs(x)</td>    <td>複素数</td>    <td>length of <i>x</i>, &radic;( Re(<i>x</i>)<sup>2</sup> + Im(<i>x</i>)<sup>2</sup> )</td></tr>
^<tr>    <td>acos(x)</td>    <td>任意</td>    <td>cos<sup>-1</sup> <i>x</i> (アークコサイン)</td></tr>
^<tr>    <td>acosh(x)</td>    <td>任意</td>    <td>ラジアンでの cosh<sup>-1</sup> <i>x</i> (逆双曲余弦)</td></tr>
^<tr>    <td>airy(x)</td>    <td>任意</td>    <td>エアリー (Airy) 関数 Ai(<i>x</i>)</td></tr>
^<tr>    <td>arg(x)</td>    <td>複素数</td>    <td><i>x</i> の偏角</td></tr>
^<tr>    <td>asin(x)</td>    <td>任意</td>    <td>sin<sup>-1</sup> <i>x</i> (アークサイン)</td></tr>
^<tr>    <td>asinh(x)</td>    <td>任意</td>    <td>ラジアンでの sinh<sup>-1</sup> <i>x</i> (逆双曲正弦)</td></tr>
^<tr>    <td>atan(x)</td>    <td>任意</td>    <td>tan<sup>-1</sup> <i>x</i> (アークタンジェント)</td></tr>
^<tr>    <td>atan2(y,x)</td>    <td>整数または実数</td>    <td>tan<sup>-1</sup>(<i>y/x</i>) (アークタンジェント)</td></tr>
^<tr>    <td>atanh(x)</td>    <td>任意</td>    <td>ラジアンでの tanh<sup>-1</sup> <i>x</i> (逆双曲正接)</td></tr>
^<tr>    <td>EllipticK(k)</td>    <td>(-1:1) 内の実数 k</td>    <td><i>K(k)</i> 第 1 種完全楕円積分</td></tr>
^<tr>    <td>EllipticE(k)</td>    <td>[-1:1] 内の実数 k</td>    <td><i>E(k)</i> 第 2 種完全楕円積分</td></tr>
^<tr>    <td>EllipticPi(n,k)</td>    <td>実数 n&lt;1, (-1:1) 内の実数 k</td>    <td> &Pi;(<i>n,k</i>) 第 3 種完全楕円積分</td></tr>
^<tr>    <td>besj0(x)</td>    <td>整数または実数</td>    <td>ラジアンでの <i>J</i><sub>0</sub> ベッセル関数 (0 次ベッセル関数)</td></tr>
^<tr>    <td>besj1(x)</td>    <td>整数または実数</td>    <td>ラジアンでの <i>J</i><sub>1</sub> ベッセル関数 (1 次ベッセル関数)</td></tr>
^<tr>    <td>besy0(x)</td>    <td>整数または実数</td>    <td>ラジアンでの <i>Y</i><sub>0</sub> ベッセル関数 (0 次ノイマン関数)</td></tr>
^<tr>    <td>besy1(x)</td>    <td>整数または実数</td>    <td>ラジアンでの <i>Y</i><sub>1</sub> ベッセル関数 (1 次ノイマン関数)</td></tr>
^<tr>    <td>ceil(x)</td>    <td>任意</td>    <td>&lceil;<i>x</i>&rceil;, <i>x</i> (の実部) 以上の最小の整数</td></tr>
^<tr>    <td>cos(x)</td>    <td>radians</td>    <td>cos <i>x</i>, <i>x</i> のコサイン</td></tr>
^<tr>    <td>cosh(x)</td>    <td>任意</td>    <td>cosh <i>x</i>, ラジアンでの <i>x</i> のハイパボリックコサイン</td></tr>
^<tr>    <td>erf(x)</td>    <td>任意</td>    <td>erf(Re(<i>x</i>)), <i>x</i> の実部の誤差関数</td></tr>
^<tr>    <td>erfc(x)</td>    <td>任意</td>    <td>erfc(Re(<i>x</i>)), 1.0 - (<i>x</i> の実部の誤差関数)</td></tr>
^<tr>    <td>exp(x)</td>    <td>任意</td>    <td><i>e<sup>x</sup></i>, <i>x</i> の指数関数</td></tr>
^<tr>    <td>expint(n,x)</td>    <td>任意</td>    <td><i>E<sub>n</sub></i>(<i>x</i>), <i>x</i> の指数積分</td></tr>
^<tr>    <td>floor(x)</td>    <td>任意</td>    <td>&lfloor;<i>x</i>&rfloor;, <i>x</i> (の実部) 以下の最大の整数</td></tr>
^<tr>    <td>gamma(x)</td>    <td>任意</td>    <td>&Gamma;(Re(<i>x</i>)), <i>x</i> の実部のガンマ関数</td></tr>
^<tr>    <td>ibeta(p,q,x)</td>    <td>任意</td>    <td>ibeta(Re(<i>p,q,x</i>)), <i>p</i>,<i>q</i>,<i>x</i> の実部の不完全ベータ関数</td></tr>
^<tr>    <td>inverf(x)</td>    <td>任意</td>    <td><i>x</i> の実部の逆誤差関数</td></tr>
^<tr>    <td>igamma(a,x)</td>    <td>任意</td>    <td>igamma(Re(<i>a,x</i>)), <a>a</a>,<i>x</i> の実部の不完全ガンマ関数</td></tr>
^<tr>    <td>imag(x)</td>    <td>複素数</td>    <td>Im(<i>x</i>), <i>x</i> の虚数部分 (実数)</td></tr>
^<tr>    <td>invnorm(x)</td>    <td>任意</td>    <td><i>x</i> の実部の逆正規分布関数</td></tr>
^<tr>    <td>int(x)</td>    <td>実数</td>    <td><i>x</i> の整数部分 (0 に向かって丸め)</td></tr>
^<tr>    <td>lambertw(x)</td>    <td>実数</td>    <td>Lambert <i>W</i> 関数</td></tr>
^<tr>    <td>lgamma(x)</td>    <td>任意</td>    <td>lgamma(Re(<i>x</i>)), <i>x</i> の実部のガンマ対数関数</td></tr>
^<tr>    <td>log(x)</td>    <td>任意</td>    <td>ln <i>x</i>, <i>x</i> の自然対数 (底 <i>e</i>)</td></tr>
^<tr>    <td>log10(x)</td>    <td>任意</td>    <td>log<sub>10</sub> <i>x</i>, <i>x</i> の対数 (底 10)</td></tr>
^<tr>    <td>norm(x)</td>    <td>任意</td>    <td>norm(<i>x</i>), <i>x</i> の実部の正規分布関数</td></tr>
^<tr>    <td>rand(x)</td>    <td>整数</td>    <td>区間 [0:1] 内の疑似乱数</td></tr>
^<tr>    <td>real(x)</td>    <td>任意</td>    <td>Re(<i>x</i>), <i>x</i> の実数部分</td></tr>
^<tr>    <td>sgn(x)</td>    <td>任意</td>    <td><i>x</i> &gt; 0 なら 1, <i>x</i> &lt; 0 なら -1, <i>x</i> = 0 なら 0. <i>x</i> の虚部は無視</td></tr>
^<tr>    <td>sin(x)</td>    <td>任意</td>    <td>sin <i>x</i>, <i>x</i> のサイン</td></tr>
^<tr>    <td>sinh(x)</td>    <td>任意</td>    <td>sinh <i>x</i>,ラジアンでの <i>x</i> のハイパボリックサイン</td></tr>
^<tr>    <td>sqrt(x)</td>    <td>任意</td>    <td>&radic;<i>x</i>, <i>x</i> の平方根</td></tr>
^<tr>    <td>tan(x)</td>    <td>任意</td>    <td>tan <i>x</i>, <i>x</i> のタンジェント</td></tr>
^<tr>    <td>tanh(x)</td>    <td>任意</td>    <td>tanh <i>x</i>, ラジアンでの <i>x</i> のハイパボリックタンジェント</td></tr>
^<tr>    <td>voigt(x,y)</td>    <td>実数</td>    <td>ガウス関数とローレンツ関数の畳みこみ</td></tr>
^</tbody>
^</table>

^<p>&nbsp;</p>

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3" width="90%">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>   <th colspan="3">libcerf (利用可能な場合のみ) による特殊関数</th></tr>
^<tr>    <th>関数</th>    <th>引数</th>    <th>戻り値</th></tr>
^</thead>
^<tbody>
^<tr>    <td>cerf(z)</td>    <td>複素数</td>    <td>複素誤差関数</td></tr>
^<tr>    <td>cdawson(z)</td>    <td>複素数</td>    <td>複素 Dawson 積分</td></tr>
^<tr>    <td>faddeeva(z)</td>    <td>複素数</td>    <td>再スケール化複素誤差関数 <i>w</i>(<i>z</i>) = exp(-<i>z</i><sup>2</sup>) × erfc(-i<i>z</i>)</td></tr>
^<tr>    <td>erfi(x)</td>    <td>実数</td>    <td>虚誤差関数 erfi(<i>x</i>) = -i × erf(i<i>x</i>)</td></tr>
^<tr>    <td>VP(x,sigma,gamma)</td>    <td>実数</td>    <td>Voigt プロファイル</td></tr>

^</tbody>
^</table>

^<p>&nbsp;</p>

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3" width="90%">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th colspan="3"> 文字列関数 </th></tr>
^<tr>    <th>関数</th>    <th>引数</th>    <th>戻り値</th></tr>
^</thead>
^<tbody>
^<tr>    <td>gprintf("format",x,...)</td>    <td>任意</td>    <td>gnuplot の書式解析器を適用した結果の文字列</td></tr>
^<tr>    <td>sprintf("format",x,...)</td>    <td>複数個</td>    <td>C 言語の sprintf の返す文字列</td></tr>
^<tr>    <td>strlen("string")</td>    <td>文字列</td>    <td>バイト単位での文字列の長さ (整数)</td></tr>
^<tr>    <td>strstrt("string","key")</td>    <td>文字列</td>    <td>部分文字列 "key" が現れる先頭位置</td></tr>
^<tr>    <td>substr("string",beg,end)</td>    <td>複数個</td>    <td>文字列 "string"[beg:end]</td></tr>
^<tr>    <td>strftime("timeformat",t)</td>    <td>任意</td>    <td>gnuplot による時刻解析結果の文字列</td></tr>
^<tr>    <td>strptime("timeformat",s)</td>    <td>文字列</td>    <td>文字列 s を変換した 1970 年からの秒数</td></tr>
^<tr>    <td>system("command")</td>    <td>文字列</td>    <td>シェルコマンドの出力を持つ文字列</td></tr>
^<tr>    <td>word("string",n)</td>    <td>文字列, 整数</td>    <td>文字列 "string" の n 番目の単語</td></tr>
^<tr>    <td>words("string")</td>    <td>文字列</td>    <td>文字列 "string" 中の単語数</td></tr>
^</tbody>
^</table>

^<p>&nbsp;</p>

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3" width="90%">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th colspan="3"> 他の gnuplot の関数 </th></tr>
^<tr>    <th>関数</th>    <th>引数</th>    <th>戻り値</th></tr>
^</thead>
^<tbody>
^<tr>    <td>column(x)</td>    <td>整数か文字列</td>    <td> 入力データ中の <i>x</i> 列目の内容</td></tr>
^<tr>    <td>columnhead(x)</td>    <td>整数</td>    <td> データファイルの最初の <i>x</i> 列目中の文字列</td></tr>
^<tr>    <td>exists("X")</td>    <td>文字列</td>    <td> 変数名 X が定義されていれば 1, そうでなければ 0</td></tr>
^<tr>    <td>hsv2rgb(h,s,v)</td>    <td>[0:1] 内の実数 h,s,v</td>    <td> HSV 色を 24ビットの RGB 色へ変換</td></tr>
^<tr>    <td>stringcolumn(x)</td>    <td>整数</td>    <td> 文字列としての <i>x</i> 列目の内容</td></tr>
^<tr>    <td>timecolumn(N,format)</td>    <td>整数, 文字列</td>    <td> データ入力中の <i>N</i> 列目の日時データ</td></tr>
^<tr>    <td>tm_hour(x)</td>    <td>整数</td>    <td>時</td></tr>
^<tr>    <td>tm_mday(x)</td>    <td>整数</td>    <td>日</td></tr>
^<tr>    <td>tm_min(x)</td>    <td>整数</td>    <td>分</td></tr>
^<tr>    <td>tm_mon(x)</td>    <td>整数</td>    <td>月</td></tr>
^<tr>    <td>tm_sec(x)</td>    <td>整数</td>    <td>秒</td></tr>
^<tr>    <td>tm_wday(x)</td>    <td>整数</td>    <td>その週の何日目</td></tr>
^<tr>    <td>tm_yday(x)</td>    <td>整数</td>    <td>その年の何日目</td></tr>
^<tr>    <td>tm_year(x)</td>    <td>整数</td>    <td>西暦</td></tr>
^<tr>    <td>time(x)</td>    <td>任意</td>    <td>現在のシステム時刻</td></tr>
^<tr>    <td>valid(x)</td>    <td>整数</td>    <td> データ中の column(<i>x</i>) の正当性</td></tr>
^<tr>    <td>value("name")</td>    <td>文字列</td>    <td> 名前 name の変数の現在の値</td></tr>
^</tbody>
^</table>

C TeX と troff 出力に関しては表は以下のヘルプセクションを置き換えます。
C HTML ヘルプに関しては表とセクションの両方が必要なので、以下のマジック
C マーカを doc2html へのこのシグナルとして使用します。
^<!-- INCLUDE_NEXT_TABLE -->
@start table
#\begin{longtable}{|ccl|} \hline
#\multicolumn{3}{|c|}{数学ライブラリ関数} \\ \hline \hline
#関数 & 引数 & 戻り値 \\ \hline
#\endhead \hline \endfoot
%c c l .
%関数@引数@戻り値
%_
4 abs
?expressions functions abs
?abs
#abs(x) & 任意  &  $x$ の絶対値, $|x|$; 同じ型\\
#abs(x) & 複素数 &  $x$ の長さ, $\sqrt{{\mbox{real}(x)^{2} +
#\mbox{imag}(x)^{2}}}$ \\
%abs(x)@任意@$x$ の絶対値, $|x|$; 同じ型
%abs(x)@複素数@$x$ の長さ, $sqrt{roman real (x) sup 2 + roman imag (x) sup 2}$
 関数 `abs(x)` 引数の絶対値を返します。返り値の型は引数と同じです。

=norm
=modulus
 複素数の引数に対しては, abs(x) は複素平面における x の長さと定義されて
 います [すなわち sqrt(real(x)**2 + imag(x)**2) ]。これは x のノルム
 (norm)、または x の複素絶対値 (modulus) とも呼ばれます。
4 acos
?expressions functions acos
?acos
#acos(x) & 任意 & $\cos^{-1} x$ (アークコサイン) \\
%acos(x)@任意@$cos sup -1 x$ (アークコサイン)
 関数 `acos(x)` は引数のアークコサイン (逆余弦) を返します。`acos` の返
 す値がラジアン単位かまたは度であるかは `set angles` で選択されます。
4 acosh
?expressions functions acosh
?acosh
#acosh(x) & 任意 & ラジアンでの $\cosh^{-1} x$ (逆双曲余弦)\\
%acosh(x)@任意@$ラジアンでの cosh sup -1 x$ (逆双曲余弦)
 関数 `acosh(x)` は逆ハイパボリックコサイン (逆双曲余弦) の値をラジアン
 で返します。
4 airy
?expressions functions airy
?airy
#airy(x) & 任意  & エアリー関数 Ai(x) \\
%airy(x)@任意@エアリー関数 Ai(x)
 関数 `airy(x)` は、エアリー (Airy) 関数 Ai(x) の値を返します。関数
 Ai(x) は、微分方程式 y'' - x y = 0 の、実数全体で有界な解です。引数が
 複素数の場合、その虚数部分は無視されます。
4 arg
?expressions functions arg
?arg
#arg(x) & 複素数 & $x$ の偏角 \\
%arg(x)@複素数@$x$ の偏角
 関数 `arg(x)` は複素数の偏角を、`set angles` の設定にしたがってラジア
 ン、または度で返します。
4 asin
?expressions functions asin
?asin
#asin(x) & 任意  & $\sin^{-1} x$ (アークサイン) \\
%asin(x)@任意@$sin sup -1 x$ (アークサイン)
 関数 `asin(x)` は引数のアークサイン (逆正弦) を返します。`asin` の返す
 値は `set angles` の設定によってラジアン単位かまたは度になります。
4 asinh
?expressions functions asinh
?asinh
#asinh(x) & 任意  & ラジアンでの $\sinh^{-1} x$ (逆双曲正弦)\\
%asinh(x)@任意@$ラジアンでの sinh sup -1 x$ (逆双曲正弦)
 関数 `asinh(x)` は逆ハイパボリックサイン (逆双曲正弦) の値をラジアンで
 返します。
4 atan
?expressions functions atan
?atan
#atan(x) & 任意  & $\tan^{-1} x$ (アークタンジェント) \\
%atan(x)@任意@$tan sup -1 x$ (アークタンジェント)
 関数 `atan(x)` は引数のアークタンジェント (逆正接) の値を返します。
 `atan` の返す値は `set angles` の設定によってラジアン単位かまたは度に
 なります。
4 atan2
?expressions functions atan2
?atan2
#atan2(y,x) & 整数または実数 & $\tan^{-1} (y/x)$ (アークタンジェント) \\
%atan2(y,x)@整数または実数@$tan sup -1 (y/x)$ (アークタンジェント)
 関数 `atan2(y,x)` は引数の実数部分の比のアークタンジェント (逆正接) の
 値を返します。`atan2` は `set angles` の設定によってラジアン単位か度に
 なる、適切な四分円における値を返します。
4 atanh
?expressions functions atanh
?atanh
#atanh(x) & 任意  & ラジアンでの $\tanh^{-1} x$ (逆双曲正接)\\
%atanh(x)@任意@ラジアンでの $tanh sup -1 x$ (逆双曲正接)
 関数 `atanh(x)` は逆ハイパボリックタンジェント (逆双曲正接) の値をラジ
 アンで返します。
4 EllipticK
#EllipticK(k) & 実数 k $\in$ (-1:1) & $K(k)$ 第 1 種完全楕円積分\\
%EllipticK(k)@(-1:1) 内の実数 k@$K k$ 第 1 種完全楕円積分
 以下参照: `elliptic integrals`。
4 EllipticE
#EllipticE(k) & 実数 k $\in$ [-1:1] & $E(k)$ 第 2 種完全楕円積分\\
%EllipticE(k)@[-1:1] 内の実数 k@ $E k$ 第 2 種完全楕円積分
 以下参照: `elliptic integrals`。
4 EllipticPi
#EllipticPi(n,k) & 実数 n$<$1, 実数 k $\in$ (-1:1) & $\Pi(n,k)$ 第 3 種完全楕円積分\\
%EllipticPi(n,k)@ 実数 n<1, (-1:1) 内の実数 k@ $Pi n,k$ 第 3 種完全楕円積分
 以下参照: `elliptic integrals`。
4 besj0
?expressions functions besj0
?besj0
#besj0(x) & 整数または実数 & $J_{0}$ ベッセル関数 (0 次ベッセル関数)\\
%besj0(x)@整数または実数@$J sub 0$ ベッセル関数 (0 次ベッセル関数)
 関数 `besj0(x)` は引数の J0 ベッセル関数 (0 次の第 1 種円柱関数 J0、0
 次ベッセル関数) の値を返します。`besj0` には引数はラジアンで与えます。
4 besj1
?expressions functions besj1
?besj1
#besj1(x) & 整数または実数 & $J_{1}$ ベッセル関数 (1 次ベッセル関数)\\
%besj1(x)@整数または実数@$J sub 1$ ベッセル関数 (1 次ベッセル関数)
 関数 `besj1(x)` は引数の J1 ベッセル関数 (1 次の第 1 種円柱関数 J1、1
 次ベッセル関数) の値を返します。`besj1` には引数はラジアンで与えます。
4 besy0
?expressions functions besy0
?besy0
#besy0(x) & 整数または実数 & $Y_{0}$ ベッセル関数 (0 次ノイマン関数)\\
%besy0(x)@整数または実数@$Y sub 0$ ベッセル関数 (0 次ノイマン関数)
 関数 `besy0(x)` は引数の Y0 ベッセル関数 (0 次の第 2 種円柱関数 Y0、0
 次ノイマン関数) の値を返します。`besy0` には引数はラジアンで与えます。
4 besy1
?expressions functions besy1
?besy1
#besy1(x) & 整数または実数 & $Y_{1}$ ベッセル関数 (1 次ノイマン関数)\\
%besy1(x)@整数または実数@$Y sub 1$ ベッセル関数 (1 次ノイマン関数)
 関数 `besy1(x)` は引数の Y1 ベッセル関数 (1 次の第 2 種円柱関数 Y1、1
 次ノイマン関数) の値を返します。`besy1` には引数はラジアンで与えます。
4 ceil
?expressions functions ceil
?ceil
#ceil(x) & 任意 & $\lceil x \rceil$, $x$ (の実部) 以上の最小の整数\\
%ceil(x)@任意@$left ceiling x right ceiling$, $x$ (の実部) 以上の最小の整数
 関数 `ceil(x)` は引数以上の最小の整数を返します。複素数引数に対しては
 `ceil` はその引数の実部以上の最小の整数を返します。
4 cos
?expressions functions cos
?cos
#cos(x) & 任意 & $x$ のコサイン $\cos x$\\
%cos(x)@ラジアン@$x$ のコサイン $cos~x$
 関数 `cos(x)` は引数のコサイン (余弦) の値を返します。`cos` は
 `set angles` の選択にしたがって、ラジアンまたは度の引数を受け付けます。
4 cosh
?expressions functions cosh
?cosh
#cosh(x) & 任意 & $\cosh x$, $x$ のハイパボリックコサイン \\
%cosh(x)@任意@$cosh~x$, $x$ のハイパボリックコサイン
 関数 `cosh(x)` は引数のハイパボリックコサインの値を返します。`cosh` の
 引数はラジアンで与えます。
4 erf
?expressions functions erf
?erf
#erf(x) & 任意 & $\mbox{erf}(\mbox{real}(x))$,  $x$ の 実部の誤差関数\\
%erf(x)@任意@$erf ( roman real (x))$, $x$ の実部の誤差関数
 関数 `erf(x)` は引数の実部の誤差関数の値を返します。引数が複素数の場合
 は虚部は無視されます。以下参照: `erfc`, `inverf`, `norm`。
4 erfc
?expressions functions erfc
?erfc
#erfc(x) & 任意 & $\mbox{erfc}(\mbox{real}(x))$,  1.0 - ($x$ の実部の誤差関数) \\
%erfc(x)@任意@$erfc ( roman real (x))$, 1.0 - ($x$ の実部の誤差関数)
 関数 `erfc(x)` は 1.0 から、引数の実部の誤差関数の値を引いたものを返し
 ます。引数が複素数の場合は虚部は無視されます。以下参照: `erf`,
 `inverf`, `norm`。
4 exp
?expressions functions exp
?exp
#exp(x) & 任意 & $e^{x}$, $x$ の指数関数\\
%exp(x)@任意@$e sup x$, $x$ の指数関数
 関数 `exp(x)` 引数の指数関数の値 (`e` の引数乗) を返します。環境によっ
 ては (特に sun) 大きい x の値に対する exp(-x) は未定義値を返す場合があ
 ります。このような場合、safe(x) = x<-100 ? 0 : exp(x) のようなユーザ定
 義関数が役に立つでしょう。
4 expint
?expressions functions expint
?expint
#expint(n,x) & 整数 $n\ge0$, 実数 $x\ge0$ & $E_n(x)=\int_1^\infty t^{-n} e^{-xt}\,dt$, $x$ の指数積分 \\
%expint(n,x)@any@$E sub n (x)$, $x$ の指数積分
 関数 `expint(n,x)` は、その引数の実数部分の指数積分、すなわち t の関数
 t^(-n) e^(-tx) の 1 から∞までの積分値を返します。n は 0 以上の整数、
 x は 0 以上の実数で、x>0 か n>1 のいずれかでなければなりません。
4 floor
?expressions functions floor
?floor
#floor(x) & 任意 & $\lfloor x \rfloor$, $x$ (の実部) 以下の最大の整数\\
%floor(x)@任意@$left floor x right floor$, $x$ (の実部) 以下の最大の整数
 関数 `floor(x)` はその引数以下の最大の整数を返します。複素数引数に対し
 ては `floor` はその引数の実部以下の最大の整数を返します。
4 gamma
?expressions functions gamma
?gamma
#gamma(x) & 任意 & $\mbox{gamma}(\mbox{real}(x))$, $x$ の実部のガンマ関数\\
%gamma(x)@任意@$GAMMA ( roman real (x))$, $x$ の実部のガンマ関数
 関数 `gamma(x)` は引数の実部のガンマ関数の値を返します。整数 n に対し
 ては gamma(n+1) = n! です。引数が複素数の場合、虚数部分は無視されます。
4 ibeta
?expressions functions ibeta
?ibeta
#ibeta(p,q,x) & 任意 & $\mbox{ibeta}(\mbox{real}(p,q,x))$, $p$,$q$,$x$ の実部の不完全ベータ関数 \\
%ibeta(p,q,x)@任意@$ibeta ( roman real (p,q,x))$, $p$,$q$,$x$ の実部の不完全ベータ関数
 関数 `ibeta(p,q,x)` は引数の実部の不完全ベータ関数の値を返します。p, q
 は正で x は [0:1] 内の値です。引数が複素数の場合は虚部は無視されます。
 この関数は連分数法 (Abramowitz and Stegun, 1964) で近似していて、この
 近似は x < (p-1)/(p+q-2) の範囲でしか正確ではありません。
4 inverf
?expressions functions inverf
?inverf
#inverf(x) & 任意 & $x$ の実部の逆誤差関数 \\
%inverf(x)@任意@$x$ の実部の逆誤差関数
 関数 `inverf(x)` は引数の実部の逆誤差関数の値を返します。以下参照:
 `erf`, `invnorm`。
4 igamma
?expressions functions igamma
?igamma
#igamma(a,x) & 任意 & $\mbox{igamma}(\mbox{real}(a,x))$, $a$,$x$ の実部の不完全ガンマ関数 \\
%igamma(a,x)@任意@$igamma ( roman real (a,x))$, $a$,$x$ の実部の不完全ガンマ関数
 関数 `igamma(a,x)` は引数の実部の、正規化された不完全ガンマ関数の値を
 返します。ここで、a > 0, x >= 0 です。標準的な記法では P(a,x) (例えば
 Abramowitz and Stegun (6.5.1)) で、x が無限大に発散する場合の極限値は
 1 です。引数が複素数の場合は虚部は無視されます。
4 imag
?expressions functions imag
?imag
#imag(x) & 複素数 & $x$ の虚数部分 (実数) \\
%imag(x)@複素数@$x$ の虚数部分 (実数)
 関数 `imag(x)` は引数の虚数部分を実数として返します。
4 invnorm
?expressions functions invnorm
?invnorm
#invnorm(x) & 任意 & $x$ の実部の逆正規分布関数 \\
%invnorm(x)@任意@$x$ の実部の逆正規分布関数
 関数 `invnorm(x)` は引数の実部に対する、正規分布 (ガウス分布) の累積分
 布関数の逆関数の値を返します。以下参照: `norm`。
4 int
?expressions functions int
?int
#int(x) & 実数 &  $x$ の整数部分 (0 に向かって丸め) \\
%int(x)@実数@$x$ の整数部分 (0 に向かって丸め)
 関数 `int(x)` は、引数の整数部分 (0 に向かって丸めた) を返します。
4 lambertw
?expressions functions lambertw
?lambertw
#lambertw(x) & 実数 & Lambert W 関数 \\
%lambertw(x)@実数@Lambert W 関数
 lambertw 関数は Lambert の W 関数の主値を返します。これは、
 (W(z)*exp(W(z))=z で定義されます。z は z >= -exp(-1) を満たす実数でな
 ければいけません。
4 lgamma
?expressions functions lgamma
?lgamma
#lgamma(x) & 任意 & $\mbox{lgamma}(\mbox{real}(x))$, $x$ の実部のガンマ対数関数\\
%lgamma(x)@任意@$lgamma ( roman real (x))$, $x$ の実部のガンマ対数関数
 関数 `lgamma(x)` は引数の実部のガンマ関数値の自然対数の値を返します。
 引数が複素数の場合、虚部は無視されます。
4 log
?expressions functions log
?log
#log(x) & 任意 & $\log_{e} x$,  $x$ の自然対数 (底 $e$) \\
%log(x)@任意@$ln~x$, $x$ の自然対数 (底 $e$)
 関数 `log(x)` は引数の自然対数 (底 `e`) の値を返します。以下参照:
 `log10`。
4 log10
?expressions functions log10
?log10
#log10(x) & 任意 & $\log_{10} x$, $x$ の対数 (底 $10$) \\
%log10(x)@任意@${log sub 10}~x$, $x$ の対数 (底 $10$)
 関数 `log10(x)` は引数の対数 (底 10) を返します。
4 norm
?expressions functions norm
?norm
#norm(x) & 任意 & $x$ の実部の正規分布 (ガウス分布) 関数 \\
%norm(x)@任意@$norm(x)$, $x$ の実部の正規分布 (ガウス分布) 関数
 関数 `norm(x)` は、引数の実部に対する、正規分布 (ガウス分布) の累積分
 布関数の値を返します。以下参照: `invnorm`, `erf`, `erfc`。
4 rand
?expressions functions rand
?rand
#rand(x) & 整数 & 区間 [0:1] 内の疑似乱数生成器 \\
%rand(x)@整数@区間 [0:1] 内の疑似乱数生成器
 `rand(0)`  区間 [0:1] 内の疑似乱数を返す。詳しくは以下参照: `random`。
4 real
?expressions functions real
?real
#real(x) & 任意 &  $x$ の実部 \\
%real(x)@任意@$x$ の実部
 関数 `real(x)` は引数の実部を返します。
4 sgn
?expressions functions sgn
?sgn
#sgn(x) & 任意 & $x>0$ なら 1, $x<0$ なら -1, $x=0$ なら 0. $x$ の虚部は無視 \\
%sgn(x)@任意@$x>0$ なら 1, $x<0$ なら -1, $x=0$ なら 0. $x$ の虚部は無視
 関数 `sgn(x)` は引数が正なら 1 を、負なら -1 を、0 ならば 0 を返します。
 引数が複素数の場合虚部は無視されます。
4 sin
?expressions functions sin
?sin
#sin(x) & 任意 & $\sin x$, $x$ のサイン\\
%sin(x)@任意@$sin~x$, $x$ のサイン
 関数 `sin(x)` は引数のサイン (正弦) の値を返します。`sin` は
 `set angles` の選択にしたがって、ラジアンまたは度の引数を受け付けます。
4 sinh
?expressions functions sinh
?sinh
#sinh(x) & 任意 & $\sinh x$, $x$ のハイパボリックサイン \\
%sinh(x)@任意@$sinh~x$, $x$ のハイパボリックサイン
 関数 `sinh(x)` は引数のハイパボリックサインの値を返します。`sinh` の
 引数はラジアンで与えます。
4 sqrt
?expressions functions sqrt
?sqrt
#sqrt(x) & 任意 & $\sqrt{x}$,  $x$ の平方根\\
%sqrt(x)@任意@$sqrt x $, $x$ の平方根
 関数 `sqrt(x)` は引数の平方根の値を返します。
4 tan
?expressions functions tan
?tan
#tan(x) & 任意 & $\tan x$,  $x$ のタンジェント \\
%tan(x)@任意@$tan~x$, $x$ のタンジェント
 関数 `tan(x)` は引数のタンジェント (正接) の値を返します。`tan` は
 `set angles` の選択にしたがって、ラジアンまたは度の引数を受け付けます。
4 tanh
?expressions functions tanh
?tanh
#tanh(x) & 任意 & $\tanh x$, $x$ のハイパボリックタンジェント\\
%tanh(x)@任意@$tanh~x$, $x$ のハイパボリックタンジェント
 関数 `tanh(x)` は引数のハイパボリックタンジェントの値を返します。
 `tanh` の引数はラジアンで与えます。
4 voigt
?expressions functions voigt
?voigt
#voigt(x,y) & 実数 & Voigt/Faddeeva 関数 $\frac{y}{\pi} \int{\frac{exp(-t^2)}{(x-t)^2+y^2}}dt$ \\
#           &       & 注意: voigt$(x,y)$ = $real($faddeeva$(x+iy))$ \\
%voigt(x,y)@実数@ガウス関数とローレンツ関数の畳みこみ
 関数 `voigt(x,y)` は、スペクトル解析で使用される Voigt/Faddeeva 関数の
 近似を返します。その誤差は 1/10^4 以内です。libcerf ルーチンが利用可能
 ならば、より正確な値を求めるために re_w_of_z() ルーチンが使われます。
 voigt(x,y) = real(faddeeva( x + y*{0,1} )) に注意してください。
#\hline \end{longtable}
#%% @end が必要とするため、ダミーの tabular の開始
#\begin{tabular}{|ccl|}
@end table

^<!-- INCLUDE_NEXT_TABLE -->
@start table
#\begin{longtable}{|ccl|} \hline
#\multicolumn{3}{|c|}{libcerf (利用可能な場合のみ) による特殊関数} \\ \hline \hline
#関数 & 引数 & 戻り値 \\ \hline
#\endhead \hline \endfoot
%c c l .
%関数@引数@戻り値
%_
4 cerf
?expressions functions cerf
?cerf
#cerf(z) & 複素数 & 複素誤差関数 \\
%cerf(z)@複素数@複素誤差関数 \\
 `cerf(z)` は誤差関数 erf(x) の複素バージョンです。
4 cdawson
?expressions functions cdawson
?cdawson
=dawson
%cdawson(z) @ 複素数 @ 複素 Dawson 積分 \\
#cdawson(z)&複素数&Dawson 積分 $D(z)={\frac{\sqrt{\pi}}{2}e^{-z^2} erfi(z)}$ の複素拡張 \\
 `cdawson(z)` は複素引数に対する Dawson 積分の値を返します。
 cdawson(z) = sqrt(pi)/2 * exp(-z^2) * erfi(z)
4 faddeeva
?expressions functions faddeeva
?faddeeva
%faddeeva(z) @ 複素数 @ 再スケール化複素誤差関数 w(z) = exp(-z^2) * erfc(-i*z) \\
#faddeeva(z)&複素数&再スケール化複素誤差関数 $w(z) = e^{-z^2}~ erfc(-iz) $ \\
 `Faddeeva(z)` は再スケール化複素誤差関数です。
 w(z) = exp(-z^2) * erfc(-i*z)
 これは、Abramowitz-Stegun の式 7.1.3, 7.1.4 に対応します。
4 erfi
?expressions functions erfi
?erfi
%erfi(x) @ 実数 @ 虚誤差関数 erfi(x) = -i * erf(ix) \\
#erfi(x)&実数&虚誤差関数 $erf(x) = -i * erf(ix)$ \\
 虚誤差関数 erfi(x) = -i * erf(ix)
4 Voigt Profile
?expressions functions VP
?VP
%VP(x,sigma,gamma) @ 実数 @ Voigt プロファイル \\
#VP(x,$\sigma$,$\gamma$)&実数& Voigt プロファイル $ VP(x,\sigma,\gamma) = {\int^{\infty}_{-\infty}{G(x^\prime;\sigma) L(x-x^\prime;\gamma) dx^\prime }} $ \\
 `VP(x,sigma,gamma)` はガウス密度関数 G(x;sigma) とローレンツ密度関数
 L(x;gamma) の畳み込みで定義される Voigt プロファイル (密度関数) に対
 応します。

#\hline \end{longtable}
#%% @end が必要とするため、ダミーの tabular の開始
#\begin{tabular}{|ccl|}
@end table

^<!-- INCLUDE_NEXT_TABLE -->
@start table
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{文字列関数} \\ \hline \hline
#関数 & 引数 & 返り値 \\ \hline
%c c l .
%関数@引数@返り値
%_
4 gprintf
?expressions functions gprintf
#gprintf("format",x,...) & 任意 & gnuplot の書式解析器を適用した結果の文字列 \\
%gprintf("format",x,...)@任意@gnuplot の書式解析器を適用した結果の文字列 \\
 `gprintf("format",x)` は、gnuplot 独自の書式指定子に一つの変数 x を適
 用し、その結果の文字列を返します。標準的な C 言語書式指定子を使いたい
 場合は、代わりに `sprintf("format",x)` を使う必要があります。
 以下参照: `format specifiers`。
4 sprintf
?expressions functions sprintf
?sprintf
#sprintf("format",x,...) & 複数個 & C 言語の sprintf の返す文字列 \\
%sprintf("format",x,...)@複数個@C 言語の sprintf の返す文字列 \\
 `sprintf("format",var1,var2,...)` は標準的な C 言語の書式指定子を複数
 個の引数に適用し、その結果の文字列を返します。gnuplot 独自の書式指定子
 を使いたい場合は、代わりに `gprintf()` を使用する必要があります。
 sprintf の書式指定子に関するより詳しい情報については、標準的な C 言語
 の本か、unix の sprintf の man ページを参照してください。
4 strlen
?expressions functions strlen
?strlen
#strlen("string") & 文字列 & バイト単位での文字列の長さ (整数) \\
%strlen("string")@文字列@バイト単位での文字列の長さ (整数)
 `strlen("string")` は、バイト単位での文字列の長さを返します。現在のエ
 ンドーディングが多バイト文字をサポートしていれば、その値は文字列中の文
 字数よりも大きくなるでしょう。
4 strstrt
?expressions functions strstrt
?strstrt
#strstrt("string","key") & 文字列 & 部分文字列 "key" が現れる先頭位置\\
%strstrt("string","key")@文字列@部分文字列 "key" が現れる先頭位置
 `strstrt("string","key")` は、文字列 "key" を "string" の中で探し、そ
 れが現れる先頭位置を返します。"key" が見つからなかった場合は 0 を返し
 ます。C ライブラリの strstr 関数に似ていますが、文字列へのポインタを返
 す strstr とは違い、これは整数での位置を返します。例えば、
 strstrt("hayneedlestack","needle") = 4 となります。
4 substr
?expressions functions substr
?substr
=substring
#substr("string",beg,end) & 複数個 & 文字列 "string"[beg:end] \\
%substr("string",beg,end)@複数個@文字列 "string"[beg:end]
 `substr("string",beg,end)` は、元の文字列の beg から end 番目までの文
 字からなる文字列を返します。これは、"string"[beg:end] という式とほぼ同
 じですが、こちらはオプション beg, end を省略できません。
4 strftime
?expressions functions strftime
?strftime
#strftime("timeformat",t) & 任意 & gnuplot による時刻解析結果の文字列 \\
%strftime("timeformat",t)@任意@gnuplot による時刻解析結果の文字列
 `strftime("timeformat",t)` は、1970 年からの秒数による時刻 t に、時刻
 書式指定 timeformat を適用します。
 以下参照: `time_specifiers`, `strptime`。
4 strptime
?expressions functions strptime
?strptime
#strptime("timeformat",s) & 文字列 & 文字列 s を変換した 1970 年からの秒数 \\
%strptime("timeformat",s)@文字列@文字列 s を変換した 1970 年からの秒数
 `strptime("timeformat",s)` 書式指定 timeformat を使って文字列 s から時
 刻を読み込んで、それを 1970 年からの秒数に変換します。
 以下参照: `time_specifiers`, `strftime`。
4 system
?expressions functions system
=system
#system("command") & 文字列 & シェルコマンドの出力を持つ文字列\\
%system("command")@文字列@シェルコマンドの出力を持つ文字列
 `system("command")` は、標準的なシェルを用いて "command" を実行し、そ
 の標準出力への文字列を文字列変数として返します。一番最後の改行一つは無
 視されます。

 これは、'f(x) = real(system(sprintf("somecommand %f", x)))' のようにし
 て、外部関数の出力を gnuplot スクリプト内に取り込むのに利用できます。
4 word
=word
#word("string",n) & 文字列, 整数 & 文字列 "string" の n 番目の単語 \\
%word("string",n)@文字列, 整数@文字列 "string" の n 番目の単語
 `word("string",n)` は文字列 string の n 番目の単語文字列を返します。例
 えば `word("one two three",2)` は文字列 "two" を返します。
4 words
=words
#words("string") & 文字列 & 文字列 "string" 中の単語数 \\
%words("string")@文字列@文字列 "string" 中の単語数
 `words("string")` は文字列 string 中の単語数を返します。例えば
 `words(" a b c d")` は 4 を返します。
@end table

^<!-- INCLUDE_NEXT_TABLE -->
@start table
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{他の {\bf gnuplot} の関数} \\ \hline \hline
#関数 & 引数 & 返り値 \\ \hline
%c c l .
%関数@引数@返り値
%_
4 column
?expressions functions column
?column
#column(x) & 整数 & データファイル処理中の $x$ 列目 \\
%column(x)@整数@ データファイル処理中の $x$ 列目
#column(x) & 整数か文字列 & データファイル処理中の $x$ 列目 \\
%column(x)@整数か文字列@ データファイル処理中の $x$ 列目
 `column(x)` は fit あるいはデータファイルプロットでの `using` の処理中
 の数式の一部としてのみ使われます。これは $x$ 列目の内容を数値として評
 価します。以下参照: `plot datafile using`。
4 columnhead
?expressions functions columnhead
?columnhead
#columnhead(x) & 整数 & データファイルの最初の $x$ 列目中の文字列 \\
%columnhead(x)@整数@ データファイルの最初の $x$ 列目中の文字列
 `columnhead(x)` は、非線形のあてはめ (fit) の際の `using` 処理内の数式
 として、あるいはデータファイル描画でのいずれかのみで使えます。これは、
 データの最初の行の x 列目の内容を含む文字列と評価されます。以下参照:
 `plot datafile using`。
4 exists
?expressions functions exists
?exists
#exists("X") & 文字列 & 変数名 X が定義されていれば 1, そうでなければ 0\\
%exists("X")@文字列@ 変数名 X が定義されていれば 1, そうでなければ 0
 exists() の引数は文字列定数、または文字列変数です。その文字列が、定義
 されている変数名を持っていれば 1 を、そうでなければ 0 を返します。
4 hsv2rgb
?expressions functions hsv2rgb
?hsv2rgb
?hsv
#hsv2rgb(h,s,v) & h,s,v $\in$ [0:1] & 24 ビット RGB 色値 \\
%hsv2rgb(h,s,v)@h,s,v $\in$ [0:1]@ 24 ビット RGB 色値
 HSV (色相 (Hue)/彩度 (Saturation)/明度 (Value)) 3 つ組をそれと同等な
 RGB 値に変換します。
4 stringcolumn
?expressions functions stringcolumn
?stringcolumn
?expressions functions strcol
?strcol
#stringcolumn(x) & 整数か文字列 & 文字列としての $x$ 列目の内容 \\
%stringcolumn(x)@整数か文字列@ 文字列としての $x$ 列目の内容
 `stringcolumn(x)` は fit あるいはデータファイルプロットでの `using` の
 操作の数式の一部としてのみ使われます。これは $x$ 列目の内容を文字列変
 数として返します。以下参照: `plot datafile using`。
4 timecolumn
?expressions functions timecolumn
?timecolumn
#timecolumn(N,"timeformat") & 整数, 文字列 & データ入力中の $N$ 列目の日時データ \\
%timecolumn(N,"timeformat")@整数, 文字列@データファイル入力中の $N$ 列目の日時データ
 `timecolumn(N,"timeformat")` は fit、あるいはデータファイル描画での
 `using` 処理の数式の一部としてのみ使います。以下参照:
 `plot datafile using`。

 これは、N 列目から始まる文字列データを日時データ値として読み、これをミ
 リ秒精度の "Unix エポック (1970 年 1 月 1 日) からの秒数" として解釈す
 るために "timeformat" を使用します。
 注意: バージョン 5 より前は、この関数は一つの引数しか取らず、また純粋
 に軸の座標を含んでいる列にしか機能していませんでした。
4 tm_hour
?expressions tm_hour
?tm_hour
#tm\_hour(x) & 整数 & 時\\
%tm_hour(x)@整数@時
 関数 `tm_hour` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 時刻の何時 (0--23 の範囲の整数) であるかを、実数として返します。
4 tm_mday
?expressions tm_mday
?tm_mday
#tm\_mday(x) & 整数 & 日 \\
%tm_mday(x)@整数@日
 関数 `tm_mday` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 その月の何日 (1--31 の範囲の整数) であるかを、実数として返します。
4 tm_min
?expressions tm_min
?tm_min
#tm\_min(x) & 整数 & 分 \\
%tm_min(x)@整数@分
 関数 `tm_min` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 時刻の何分 (0--59 の範囲の整数) であるかを、実数として返します。
4 tm_mon
?expressions tm_mon
?tm_mon
#tm\_mon(x) & 整数 & 月 \\
%tm_mon(x)@整数@月
 関数 `tm_mon` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 何月 (0--11 の範囲の整数) であるかを、実数として返します。
4 tm_sec
?expressions tm_sec
?tm_sec
#tm\_sec(x) & 整数 & 秒 \\
%tm_sec(x)@整数@秒
 関数 `tm_sec` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 時刻の何秒 (0--59 の範囲の整数) であるかを、実数として返します。
4 tm_wday
?expressions tm_wday
?tm_wday
#tm\_wday(x) & 整数 & その週の何日目 \\
%tm_wday(x)@整数@その週の何日目
 関数 `tm_wday` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 その週の何日目 (0--6 の範囲の整数) であるかを、実数として返します。
4 tm_yday
?expressions tm_yday
?tm_yday
#tm\_yday(x) & 整数 & その年の何日目 \\
%tm_yday(x)@整数@その年の何日目
 関数 `tm_yday` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 その年の何日目 (1--366 の範囲の整数) であるかを、実数として返します。
4 tm_year
?expressions tm_year
?tm_year
#tm\_year(x) & 整数 & 西暦 \\
%tm_year(x)@整数@西暦
 関数 `tm_year` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 西暦何年 (整数) であるかを、実数として返します。
4 time
?expressions time
?time
#time(x) & 任意 & 現在のシステム時刻 \\
%time(x)@任意@現在のシステム時刻
 関数 `time` は現在のシステム時刻を返します。この値は `strftime` 関数で
 日時文字列に変換できますし、`timecolumn` と組み合わせて相対的な日時グ
 ラフを作成するのにも使えます。引数の型はそれが返すものを決定します。引
 数が整数の場合は time() は現在の時刻を 1970 年 1 月 1 日からの整数とし
 て返し、引数が実数 (または複素数) ならば同様の値を実数として返します。
 引数が文字列ならば、それを書式文字列であるとみなし、書式化された日時文
 字列を提供するようそれを `strftime` に渡します。
4 valid
?expressions functions valid
?valid
#valid(x) & 整数 & データ中の $\mbox{column}(x)$ の正当性\\
%valid(x)@整数@ データ中の column($x$) の正当性
 `valid(x)` は、データ描画か fit における `using` の式の中でしか使われ
 ません。以下参照: `plot datafile using`。

#value("name") & 文字列 & 名前 name の変数の現在の値\\
%value("name")@文字列@ 名前 name の変数の現在の値
@end table

4 種々の楕円積分 (elliptic integrals)
?expressions functions elliptic integrals
?elliptic integrals
=elliptic integrals
 関数 `EllipticK(k)` は、第 1 種完全楕円積分、すなわち、関数
 `(1-(k*sin(p))**2)**(-0.5)` の 0 からπ/2 までの範囲の広義積分の値を返
 します。`k` の定義域は -1 から 1 です (両端は含まない)。

 関数 `EllipticE(k)` は、第 2 種完全楕円積分、すなわち、関数
 `(1-(k*sin(p))**2)**0.5` の 0 からπ/2 までの範囲の広義積分の値を返し
 ます。`k` の定義域は -1 から 1 です (両端も含む)。

 関数 `EllipticPi(n,k)` は、第 3 種完全楕円積分、すなわち関数
 `(1-(k*sin(p))**2)**(-0.5)/(1-n*sin(p)**2)` の 0 からπ/2 までの範囲の
 広義積分の値を返します。パラメータ `n` は 1 より小さく、`k` は -1 と 1
 の間 (両端は含まない) でなければいけません。定義より、すべての正の `k`
 に対し EllipticPi(0,k) == EllipticK(k) であることに注意してください。
4 乱数の生成 (random)
?expressions random
?random
=rand
 関数 `rand()` は 0 と 1 の間の疑似乱数列を生成します。これは以下からの
 アルゴリズムを使用しています: P. L'Ecuyer and S. Cote, "Implementing a
 random number package with splitting facilities", ACM Transactions on
 Mathematical Software, 17:98-111 (1991).

       rand(0)     内部に持つ 2 つの 32bit の種 (seed) の現在の値から生
                   成される [0:1] 区間内の疑似乱数値を返す
       rand(-1)    2 つの種の値を標準値に戻す
       rand(x)     0 < x < 2^31-1 の整数なら種の両方を x に設定する
       rand({x,y}) 0 < x,y < 2^31-1 の整数なら seed1 を x に seed2 を y
                   に設定する
4 value
?expressions functions value
?value
 A がユーザー定義変数の名前であれば、B = value("A") は事実上 B = A と全
 く同じです。これは、変数の名前自身が文字列変数に収められている場合に有
 用です。以下参照: `user-defined variables`。これは、変数名をデータファ
 イルから読み取ることも可能にします。引数が数式である場合、value() はそ
 の数式の値を返します。引数が文字列で、定義されている変数に対応するもの
 がない場合、value() は NaN を返します。

4 単語の取り出しと単語数 (word, words)
?expressions functions word
?expressions functions words
?words
?word
 `word("string",n)` は、文字列 (string) の n 番目の単語を返します。例え
 ば `word("one two three",2)` は文字列 "two" を返します。

 `words("string")` は、文字列 (string) の単語数を返します。例えば、
 `words(" a b c d")` は 4 を返します。

 関数 `word` と `words` は、単一引用符、二重引用符で囲まれた文字列も、
 限定的ですがサポートしています:
       print words("\"double quotes\" or 'single quotes'")   # 3
 開始引用符の前は、スペースか、または文字列の先頭でなければいけません。
 これは、単語内、あるいは単語終わりにつくアポストロフィー (') は、それ
 ぞれの単語の要素であると見なされることを意味します:
       print words("Alexis' phone doesn't work") # 4
 引用符文字のエスケープはサポートしていませんので、ある引用符を維持した
 い場合は、それぞれを別の種類の引用符で囲まなければいけません:
       s = "Keep \"'single quotes'\" or '\"double quotes\"'"
       print word(s, 2) # 'single quotes'
       print word(s, 4) # "double quotes"
 最後の例では、引用符のエスケープが文字列の定義時のみに必要であることに
 注意してください。

3 演算子 (Operators)
?expressions operators
?operators
 `gnuplot` の演算子は、C 言語の演算子とほぼ同じですが、特に注意がなけれ
 ば全ての演算子が整数、実数、複素数の引数を取ることができます。また、
 FORTRAN で使える ** (累乗) 演算子もサポートされています。

 演算の評価の順序を変更するにはかっこを使います。
4 単項演算子 (Unary)
?expressions operators unary
?operators unary
?unary
 以下は、単項演算子とその使用法の一覧です:

@start table - まずは対話型テキスト形式
     記号          例        説明
       -           -a          マイナス符号
       +           +a          プラス符号 (何もしない)
       ~           ~a        * 1 の補数 (ビット反転)
       !           !a        * 論理的否定
       !           a!        * 階乗
       $           $3        * `using` 内での引数/列指定
=factorial
=negation
=one's complement
=operator precedence
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{単項演算子}\\ \hline \hline
#記号 & 例 & 説明 \\ \hline
#\verb@-@ & \verb@-a@ & マイナス符号 \\
#\verb@+@ & \verb@+a@ & プラス符号 (何もしない) \\
#\verb@~@ & \verb@~a@ & * 1 の補数 (ビット反転) \\
#\verb@!@ & \verb@!a@ & * 論理的否定 \\
#\verb@!@ & \verb@a!@ & * 階乗 \\
#\verb@$@ & \verb@$3@ & * `using` 内での引数/列指定 \\
C ugly hack: doc2ms uses $ as delimiter for eqn's so it doesn't seem to
C be able to print them. So we have to typeset this table without using
C eqn (at least that's the only solution I found, without any real docs
C on *roff and eqn
C First, terminate the table doc2ms.c already started:
%.TE
C ... then turn off eqn delimiters:
%.EQ
%delim off
%.EN
C ... and restart the table:
%.TS
%center box tab (@) ;
%c c l .
%記号@例@説明
%_
%-@-a@マイナス符号
%+@+a@プラス符号 (何もしない)
%~@~a@* 1 の補数 (ビット反転)
%!@!a@* 論理的否定
%!@a!@* 階乗
%$@$3@* `using` 内での引数/列指定
%_
@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>記号</th>    <th>例</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>-</tt></td>    <td><tt>-a</tt></td>    <td>マイナス符号</td></tr>
^<tr>    <td><tt>+</tt></td>    <td><tt>+a</tt></td>    <td>プラス符号 (何もしない)</td></tr>
^<tr>    <td><tt>~</tt></td>    <td><tt>~a</tt></td>    <td>* 1 の補数 (ビット反転)</td></tr>
^<tr>    <td><tt>!</tt></td>    <td><tt>!a</tt></td>    <td>* 論理的否定</td></tr>
^<tr>    <td><tt>!</tt></td>    <td><tt>a!</tt></td>    <td>* 階乗</td></tr>
^<tr>    <td><tt>$</tt></td>    <td><tt>$3</tt></td>    <td>* `using` 内での引数/列指定</td></tr>
^</tbody>
^</table>

 説明に星印 (*) のついた演算子の引数は整数でなければなりません。

 演算子の優先順位は Fortran や C と同じです。それらの言語同様、演算の評
 価される順序を変えるためにかっこが使われます。よって -2**2 = -4 で、
 (-2)**2 = 4 です。

 階乗演算子は、大きな値を返せるように実数を返します。
4 二項演算子 (Binary)
?expressions operators binary
?operators binary
 以下は、二項演算子とその使用法の一覧です:

@start table - まずは対話型テキスト形式
     記号          例          説明
       **          a**b          累乗
       *           a*b           積
       /           a/b           商
       %           a%b         * 余り
       +           a+b           和
       -           a-b           差
       ==          a==b          等しい
       !=          a!=b          等しくない
       <           a<b           より小さい
       <=          a<=b          以下
       >           a>b           より大きい
       >=          a>=b          以上
       <<          0xff<<1       符号なし左シフト
       >>          0xff>>2       符号なし右シフト
       &           a&b         * ビット積 (AND)
       ^           a^b         * ビット排他論理和 (XOR)
       |           a|b         * ビット和 (OR)
       &&          a&&b        * 論理的 AND
       ||          a||b        * 論理的 OR
       =           a = b         代入
       ,           (a,b)         累次評価
       .           A.B           文字列の連結
       eq          A eq B        文字列が等しい
       ne          A ne B        文字列が等しくない
=bitwise operators
=string operators
=modulo
=exponentiation
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{二項演算子} \\ \hline \hline
#記号 & 例 & 説明 \\ \hline
#\verb~**~ & \verb~a**b~ & 累乗\\
#\verb~*~ & \verb~a*b~ & 積\\
#\verb~/~ & \verb~a/b~ & 商\\
#\verb~%~ & \verb~a%b~ & * 余り\\
#\verb~+~ & \verb~a+b~ & 和\\
#\verb~-~ & \verb~a-b~ & 差\\
#\verb~==~ & \verb~a==b~ & 等しい\\
#\verb~!=~ & \verb~a!=b~ & 等しくない\\
#\verb~<~ & \verb~a<b~ & より小さい\\
#\verb~<=~ & \verb~a<=b~ & 以下\\
#\verb~>~ & \verb~a>b~ & より大きい\\
#\verb~>=~ & \verb~a>=b~ & 以上\\
#\verb~<<~ & \verb~0xff<<1~ & 符号なし左シフト\\
#\verb~>>~ & \verb~0xff>>1~ & 符号なし右シフト\\
#\verb~&~ & \verb~a&b~ & * ビット積 (AND)\\
#\verb~^~ & \verb~a^b~ & * ビット排他的論理和 (XOR)\\
#\verb~|~ & \verb~a|b~ & * ビット和 (OR)\\
#\verb~&&~ & \verb~a&&b~ & * 論理的 AND\\
#\verb~||~ & \verb~a||b~ & * 論理的 OR\\
#\verb~=~ & \verb~a = b~ & 代入\\
#\verb~,~ & \verb~(a,b)~ & 累次評価\\
#\verb~.~ & \verb~A.B~ & 文字列の連結\\
#\verb~eq~ & \verb~A eq B~ & 文字列が等しい\\
#\verb~ne~ & \verb~A ne B~ & 文字列が等しくない\\
%c c l .
%記号@例@説明
%_
%**@a**b@累乗
%*@a*b@積
%/@a/b@商
%%@a%b@* 余り
%+@a+b@和
%-@a-b@差
%==@a==b@等しい
%!=@a!=b@等しくない
%<@a<b@より小さい
%<=@a<=b@以下
%>@a>b@より大きい
%>=@a>=b@以上
%<<@0xff<<1@符号なし左シフト
%>>@0xff>>1@符号なし右シフト
%&@a&b@* ビット積 (AND)
%^@a^b@* ビット排他的論理和 (XOR)
%|@a|b@* ビット和 (OR)
%&&@a&&b@* 論理的 AND
%||@a||b@* 論理的 OR
%=@a = b@代入
%,@(a,b)@累次評価
%.@a.b@文字列の連結
%eq@A eq B@文字列が等しい
%ne@A ne B@文字列が等しくない

@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>記号</th>    <th>例</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>**</tt></td>    <td><tt>a**b</tt></td>    <td>累乗</td></tr>
^<tr>    <td><tt>*</tt></td>    <td><tt>a*b</tt></td>    <td>積</td></tr>
^<tr>    <td><tt>/</tt></td>    <td><tt>a/b</tt></td>    <td>商</td></tr>
^<tr>    <td><tt>%</tt></td>    <td><tt>a%b</tt></td>    <td>* 余り</td></tr>
^<tr>    <td><tt>+</tt></td>    <td><tt>a+b</tt></td>    <td>和</td></tr>
^<tr>    <td><tt>-</tt></td>    <td><tt>a-b</tt></td>    <td>差</td></tr>
^<tr>    <td><tt>==</tt></td>    <td><tt>a==b</tt></td>    <td>等しい</td></tr>
^<tr>    <td><tt>!=</tt></td>    <td><tt>a!=b</tt></td>    <td>等しくない</td></tr>
^<tr>    <td><tt>&lt;</tt></td>    <td><tt>a&lt;b</tt></td>    <td>より小さい</td></tr>
^<tr>    <td><tt>&lt;=</tt></td>    <td><tt>a&lt;=b</tt></td>    <td>以下</td></tr>
^<tr>    <td><tt>&gt;</tt></td>    <td><tt>a&gt;b</tt></td>    <td>より大きい</td></tr>
^<tr>    <td><tt>&gt;=</tt></td>    <td><tt>a&gt;=b</tt></td>    <td>以上</td></tr>
^<tr>    <td><tt>&lt;&lt;</tt></td>    <td><tt>0xff&lt;&lt;1</tt></td>    <td>符号なし左シフト</td></tr>
^<tr>    <td><tt>&gt;&gt;</tt></td>    <td><tt>0xff&gt;&gt;1</tt></td>    <td>符号なし右シフト</td></tr>
^<tr>    <td><tt>&amp;</tt></td>    <td><tt>a&amp;b</tt></td>    <td>* ビット積 (AND)</td></tr>
^<tr>    <td><tt>^</tt></td>    <td><tt>a^b</tt></td>    <td>* ビット排他的論理和 (XOR)</td></tr>
^<tr>    <td><tt>|</tt></td>    <td><tt>a|b</tt></td>    <td>* ビット和 (OR)</td></tr>
^<tr>    <td><tt>&amp;&amp;</tt></td>    <td><tt>a&amp;&amp;b</tt></td>    <td>* 論理的 AND</td></tr>
^<tr>    <td><tt>||</tt></td>    <td><tt>a||b</tt></td>    <td>* 論理的 OR</td></tr>
^<tr>    <td><tt>=</tt></td>    <td><tt>a = b</tt></td>    <td>代入</td></tr>
^<tr>    <td><tt>,</tt></td>    <td><tt>(a,b)</tt></td>    <td>累次評価</td></tr>
^<tr>    <td><tt>.</tt></td>    <td><tt>a.b</tt></td>    <td>文字列の連結</td></tr>
^<tr>    <td><tt>eq</tt></td>    <td><tt>A eq B</tt></td>    <td>文字列が等しい</td></tr>
^<tr>    <td><tt>ne</tt></td>    <td><tt>A ne B</tt></td>    <td>文字列が等しくない</td></tr>
^</tbody>
^</table>

 説明に星印 (*) のついた演算子の引数は整数でなければなりません。
 大文字の A,B は演算子が文字列引数を要求することを意味します。

 論理演算子の AND (&&) と OR (||) は C 言語同様に必要最小限の評価しかし
 ません。すなわち、`&&` の第 2 引数は、第 1 引数が偽ならば評価されませ
 んし、`||` の第 2 引数は、第 1 引数が真ならば評価されません。

 累次評価 (,) は、カッコの中でのみ評価され、左から右へ順に実行すること
 が保証され、最も右の式の値が返されます。
4 三項演算子 (Ternary)
?expressions operators ternary
?operators ternary
?ternary
 一つだけ三項演算子があります:

@start table - まずは対話型テキスト形式
      記号          例       説明
       ?:          a?b:c     三項演算子
#\begin{tabular}{|ccl|} \hline
#\multicolumn{3}{|c|}{三項演算子} \\ \hline \hline
#記号 & 例 & 説明 \\ \hline
#\verb~?:~ & \verb~a?b:c~ & 三項演算子\\
%c c l .
%記号@例@説明
%_
%?:@a?b:c@* 三項演算子

@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>記号</th>    <th>例</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>?:</tt></td>    <td><tt>a?b:c</tt></td>    <td>* 三項演算子</td></tr>
^</tbody>
^</table>

 三項演算子は C のものと同じ働きをします。最初の引数 (a) は整数でなけれ
 ばいけません。この値が評価され、それが真 (ゼロでない) ならば 2 番目の
 引数 (b) が評価されその値が返され、そうでなければ 3 番目の引数 (c) が
 評価され、その値が返されます。

 三項演算子は、区分的に定義された関数や、ある条件が満たされた場合にのみ
 点を描画する、といったことを行なう場合に有用です。

 例:

 0 <= x < 1 では sin(x) に、1 <= x < 2 では 1/x に等しくて、それ以外の
 x では定義されない関数を描画:
       f(x) = 0<=x && x<1 ? sin(x) : 1<=x && x<2 ? 1/x : 1/0
       plot f(x)
 `gnuplot` は未定義値に対しては何も表示せずにただ無視するので、最後の場
 合の関数 (1/0) は点を何も出力しないことに注意してください。また、この
 関数描画の描画スタイルが lines (線描画) の場合、不連続点 (x=1) の所も
 連続関数として線が結ばれてしまうことにも注意してください。その点を不連
 続になるようにするには、関数を 2 つの部分それぞれに分けてください (こ
 のような場合、媒介変数関数を使うのが便利です)。

 ファイル 'file' のデータで、4 列目のデータが負でないときだけ、1 列目の
 データに関する 2 列目と 3 列目のデータの平均値を描画:

       plot 'file' using 1:( $4<0 ? 1/0 : ($2+$3)/2 )

 `using` の書式の説明に関しては、以下参照: `plot datafile using`。
3 和 (Summation)
?expressions operators summation
?operators summation
?summation
 和の式は、以下の形式で表します:
       sum [<var> = <start> : <end>] <expression>
 ここで <var> は、<start> から <end> までの整数値を順に取る整数変数とし
 て扱われます。その各値に対して、式 <expression> の値が合計値に追加され、
 最終的な合計値がこの和の式の値となります。
 例:
       print sum [i=1:10] i
           55.
       # 以下は plot 'data' using 1:($2+$3+$4+$5+$6+...) と同等
       plot 'data' using 1 : (sum [col=2:MAXCOL] column(col))
 <expression> は、必ずしも変数 <var> を含む必要はありません。<start> と
 <end> は変数値や数式で指定もできますが、それらの値は動的に変更すること
 はできません。そうでないと副作用が起こり得ます。<end> が <start> より
 小さい場合は、和の値は 0 となります。
3 定義済み変数 (Gnuplot-defined variables)
?expressions gnuplot-defined
?gnuplot-defined
?gnuplot-defined variables
?GPVAL
?gpval
 gnuplot は、プログラムの現在の内部状態と直前の描画を反映するような読み
 出し専用の変数をいくつか持っています。これらの変数の名前は、例えば
 GPVAL_TERM, GPVAL_X_MIN, GPVAL_X_MAX, GPVAL_Y_MIN のように "GPVAL_" で
 始まります。これらすべての一覧とその値を見るには、`show variables all`
 と入力してください。ただし、軸のパラメータに関連する値 (範囲、対数軸で
 あるか等) は、現在 `set` したものではなく、最後に描画されたものが使用
 されます。

 例: 点 [X,Y] のスクリーン比での座標を計算する方法
      GRAPH_X = (X - GPVAL_X_MIN) / (GPVAL_X_MAX - GPVAL_X_MIN)
      GRAPH_Y = (Y - GPVAL_Y_MIN) / (GPVAL_Y_MAX - GPVAL_Y_MIN)
      SCREEN_X = GPVAL_TERM_XMIN + GRAPH_X * (GPVAL_TERM_XMAX - GPVAL_TERM_XMIN)
      SCREEN_Y = GPVAL_TERM_YMIN + GRAPH_Y * (GPVAL_TERM_YMAX - GPVAL_TERM_YMIN)
      FRAC_X = SCREEN_X * GPVAL_TERM_SCALE / GPVAL_TERM_XSIZE
      FRAC_Y = SCREEN_Y * GPVAL_TERM_SCALE / GPVAL_TERM_YSIZE

=errors
=error state
 読み出し専用変数 GPVAL_ERRNO は、任意の gnuplot コマンドがあるエラーの
 ために早く終わってしまった場合に 0 でない値にセットされ、直前のエラー
 メッセージは文字列変数 GPVAL_ERRMSG に保存されます。GPVAL_ERRNO と
 GPVAL_ERRMSG は、コマンド `reset errors` を使ってクリアできます。

 `mouse` 機能が使える対話型入出力形式は、"MOUSE_" で始まる読み出し専用
 変数をいくつか持っています。詳細は、以下参照: `mouse variables`。

 `fit` 機能は、"FIT_" で始まるいくつかの変数を使用しますので、そのよう
 な名前を使うのは避けるべきでしょう。`set fit errorvariables` を使用す
 ると、各当てはめ変数のエラーは、そのパラメータ名に "_err" を追加した変
 数に保存されます。詳細は、以下参照: `fit`。

 以下も参照: `user-defined variables`, `reset errors`,
 `mouse variables`, `fit`。

3 ユーザ定義の変数と関数 (User-defined)
?expressions user-defined
?user-defined variables
?user-defined
?variables
 新たなユーザ定義変数と 1 個から 12 個までの引数を持つユーザ定義関数を、
 任意の場所で定義したり使ったりすることができます。それは `plot` コマン
 ド上でも可能です。

 ユーザ定義関数書式:
       <func-name>( <dummy1> {,<dummy2>} ... {,<dummy12>} ) = <expression>

 ここで <expression> は仮変数 <dummy1> から <dummy12> で表される数式です。

 ユーザ定義変数書式:
       <variable-name> = <constant-expression>

 例:
       w = 2
       q = floor(tan(pi/2 - 0.1))
       f(x) = sin(w*x)
       sinc(x) = sin(pi*x)/(pi*x)
       delta(t) = (t == 0)
       ramp(t) = (t > 0) ? t : 0
       min(a,b) = (a < b) ? a : b
       comb(n,k) = n!/(k!*(n-k)!)
       len3d(x,y,z) = sqrt(x*x+y*y+z*z)
       plot f(x) = sin(x*a), a = 0.2, f(x), a = 0.4, f(x)

       file = "mydata.inp"
       file(n) = sprintf("run_%d.dat",n)

 最後の 2 行の例は、ユーザ定義文字列変数と、ユーザ定義文字列関数を意味
 しています。

=NaN
=pi
 変数 `pi` (3.14159...) と `NaN` (IEEE 非数 ("Not a Number")) はあらか
 じめ定義されています。これらが必要なければ、他のものに再定義することも
 可能ですし、以下のようにして元の値に復帰することもできます:

       NaN = GPVAL_NaN
       pi  = GPVAL_pi

 他にもいくつかの変数が、例えば対話型入出力形式でのマウス操作や当てはめ
 (fit) などの gnuplot の動作状態に応じて定義されます。詳細は
 以下参照: `gnuplot-defined variables`。

 ある変数 V が既に定義されているかどうかは、式 exists("V") でチェックで
 きます。例:
       a = 10
       if (exists("a")) print "a is defined"
       if (!exists("b")) print "b is not defined"

 変数名や関数名の命名規則は、大抵のプログラミング言語と同じで、先頭はア
 ルファベットで、その後の文字はアルファベット、数字、"_" が使えます。

 各関数の定義式は、'GPFUN_' という接頭辞を持つ特別な文字列値変数として
 利用できます。

 例:
       set label GPFUN_sinc at graph .05,.95

 以下参照: `show functions`, `functions`, `gnuplot-defined variables`,
 `macros`, `value`。
2 フォント
?fonts
 gnuplot それ自身にはどんなフォントも含まれてはおらず、外部フォント処理
 に頼っているだけで、その細部は悲しいことに出力形式毎に異なります。ここ
 では、複数の出力形式に適用されるフォント機構について説明します。ここに
 上げたもの以外の出力形式でのフォントの使用に関しては、その出力形式のド
 キュメントを参照してください。

 一時的に、例えば Adobe Symbol フォントのような特別なフォントに切り替え
 ることでアルファベットではない記号を入れることも可能ですが、現在は、
 UTF-8 エンコーディングを使用して、必要な記号を指す Unicode エントリを
 指定するという方法があります。以下参照: `encoding`, `locale`。

3 cairo (pdfcairo, pngcairo, epscairo, wxt 出力形式)
?fonts cairo
=fonts
=pdf
=png
=wxt
 これらの出力形式は、フォントの検索とアクセスに外部の fontconfig ツール
 群を使用します。
^ <a href="http://fontconfig.org/fontconfig-user.html">
 fontconfig ユーザマニュアル
^ </a>
 を参照してください。これは、gnuplot で一般的な名前やサイズでフォントを
 要求することを可能にし、必要ならば fontconfig に同等のフォントを代用さ
 せることもできるので、通常はこれで十分でしょう。以下は、多分いずれも機
 能します:
      set term pdfcairo font "sans,12"
      set term pdfcairo font "Times,12"
      set term pdfcairo font "Times-New-Roman,12"

3 gd (png, gif, jpeg terminals)
?gd
?fonts gd
=fonts
=png
=jpeg
=gif
 png, gif, jpeg 出力形式のフォント処理は、外部ライブラリ libgd によって
 行われます。libgd は、次の 5 種類の基本フォントを直接提供しています:
 `tiny` (5x8 ピクセル), `small` (6x12 ピクセル), `medium`, (7x13 Bold),
 `large` (8x16), `giant` (9x15 ピクセル)。これらのフォントは大きさを変
 更したり回転したりすることはできません。使用する際は、`font` キーワー
 ドの代わりに上のキーワードを指定します。例:
      set term png tiny

 多くのシステムで、libgd は Adobe Type 1 フォント (*.pfa) と TrueType
 フォントへのアクセスも提供します。その場合フォント自身の名前ではなく、
 フォントファイルの名前を、"<face> {,<pointsize>}" の形式で与えます。
 ここで、<face> はフォントファイルのフルパス名か、または環境変数
 GDFONTPATH で指示されるディレクトリの一つの中のファイル名の先頭部分、
 のいずれかです。よって、'set term png font "Face"' は、
 <あるディレクトリ>/Face.ttf か <あるディレクトリ>/Face.pfa というファ
 イル名のフォントを探そうとします。例えば、GDFONTPATH に
 `/usr/local/fonts/ttf:/usr/local/fonts/pfa` が含まれている場合は、以下
 のコマンドの 2 つずつはいずれも同じことになります:
      set term png font "arial"
      set term png font "/usr/local/fonts/ttf/arial.ttf"
      set term png font "Helvetica"
      set term png font "/usr/local/fonts/pfa/Helvetica.pfa"
 デフォルトのフォントサイズも同時に指定するには:
      set term png font "arial,11"

 TrueType と Adobe Type 1 フォントは、完全に大きさの変更や回転が可能で
 す。"set term" コマンドでフォントを指定しなかった場合、gnuplot は別の
 デフォルトフォントの設定があるかどうかを調べるために環境変数
 GNUPLOT_DEFAULT_GDFONT を参照します。
3 postscript (カプセル化 postscript *.eps も)
?fonts postscript
=fonts
=postscript
=eps
 PostScript フォント処理は、プリンタか表示ソフトが行います。もし、あな
 たのコンピュータにフォントが一切なくても、gnuplot は正しい PostScript
 ファイル、またはカプセル化 PostScript (*.eps) ファイルを生成できます。
 gnuplot は単に出力ファイル中にフォントを名前として入れるだけで、プリン
 タや表示ソフトがその名前からフォントを見つけるか近似することを仮定して
 います。

 PostScript プリンタや表示ソフトはすべて、標準的な Adobe フォントセット
 `Times-Roman`, `Helvetica`, `Courier`, `Symbol` は知っているはずです。
 多分その他にも多くのフォントが使えるようになっていると思いますが、それ
 ら特定のフォントセットはあなたのシステムやプリンタの設定に依存します。
 gnuplot は、それは知りませんし気にもしません。gnuplot が作成した *.ps
 や *.eps 出力は、あなたの要求したフォント名を単に持っているだけです。

 よって、
      set term postscript eps font "Times-Roman,12"
 は、すべてのプリンタや表示ソフトに適切な出力を作成します。

 一方、
      set term postscript eps font "Garamond-Premier-Pro-Italic"
 は、正しい PostScript を含む出力ファイルを作成しますが、それは特殊なフ
 ォントを参照しますので、一部のプリンタや表示ソフトしか、要求したその特
 定のフォントは表示できないでしょう。大抵の場合は別なフォントで代用され
 ます。

 しかし、指定したフォントを出力ファイル中に埋め込んで、どんなプリンタで
 もそれを使うようにすることも可能です。これには、あなたのシステムに適切
 なフォント記述ファイルがあることが必要となります。この方法でフォントを
 埋め込む場合、特定のライセンスが必要となるフォントファイルもあることに
 注意してください。より詳細な説明や例については、以下参照:
 `postscript fontfile`。
2 ヘルプの用語解説 (Glossary)
?glossary
 このドキュメント全体に渡って、用語に関する一貫性の維持が考えられていま
 す。しかしこの試みは完全には成功していません。それは `gnuplot` が時間
 をかけて進化してきたように、コマンドやキーワードの名前もそのような完全
 性を排除するかのように採用されて来ているからです。このセクションでは、
 これらのキーワードのいくつかがどのように使われているかを説明します。

 "ページ (page)"、"表示画面 (screen)"、"キャンバス (canvas)" は、
 `gnuplot` がアクセス可能な領域全体を指します。デスクトップではそれはウ
 ィンドウ全体を指し、プロッタでは、一枚の紙全体、svga モードでは、モニ
 タスクリーン全体を指します。

 表示画面は、一つ、またはそれ以上の "グラフ描画 (plot)" を含みます。グ
 ラフ描画は一つの横座標と一つの縦座標で定義されますが、余白 (margin) や
 その中に書かれる文字列 (text) 同様、それらは実際にその上に表示されてい
 る必要はありません。

 グラフ描画は一つの "グラフ" を含みます。グラフは一つの横座標と一つの縦
 座標で定義されますが、これらは実際にその上に表示されている必要はありま
 せん。

 グラフは一つまたはそれ以上の "曲線 (line)" を含みます。曲線は一つの関
 数、またはデータ集合です。用語 "line" は描画スタイルとしても使われます。
 さらにこの用語は "文字列の一行 (a line of text)" のように使われること
 もあります。多分文脈からそれらは区別できるでしょう。

 一つのグラフ上の複数の曲線はそれぞれ名前を持ちます。その名前は、その曲
 線の表現に使われる描画スタイルのサンプルとともに "凡例 (key)" 内に一覧
 表示されます。凡例は、時には "表題 (legend)" とも呼ばれます。

 用語 "タイトル (title)" は `gnuplot` では複数の意味で使われます。この
 ドキュメントではそれらを区別するために、形容詞として "描画の (plot)"、
 "曲線の (line)"、"凡例の (key)" を頭につけたりもします。
 2 次元のグラフは 4 つまでの見出し付けされる軸を持つことができます。こ
 れら 4 つの軸の名前はそれぞれ、グラフ描画の下の境界に沿う軸である "x"、
 左の境界に沿う軸 "y"、上の境界に沿う軸 "x2"、右の境界に沿う軸 "y2" と
 なっています。以下参照: `axes`。

 3 次元のグラフは  3 つまでの見出し付けされる軸 (`axes`) "x","y","z" を
 持つことができます。どの特定の軸に関してもそれがグラフ上でどこに書かれ
 るかを述べることはできません。それは、`set view` でグラフを見る方向を
 変更できるからです。

 データファイルに関する議論では、用語 "行 (record)" を復活し、ファイル
 の一行の文字列、すなわち、改行文字や行末文字同士の間の文字列、を指し示
 すのに使います。"点 (point)" は行から取り出した一つのデータです。"デー
 タブロック (datablock)" は、空行で区切られた連続した複数の行からなる点
 の集合です。データファイルの議論の中で "line" が参照される場合は、これ
 はデータブロックの部分集合を指します。"データブロック (datablock)" と
 いう言葉は、名前付きインラインデータブロックでも使われています。以下参
 照: `datablocks`。

 (訳注: この日本語訳の中ではここに書かれているような用語の統一は考慮さ
 れてはおらず、よって混乱を引き起こす可能性があります。厳密には原文を参
 照すべきでしょう。)
2 繰り返し (iteration)
?iteration
?iterate
Ffigure_newsyntax
 gnuplot バージョン 4.6 には、繰り返し (iteration) コマンドやブロック構
 造を扱える if/else/while/do が導入されています。以下参照: `if`,
 `while`, `do`。単純な繰り返しは、コマンド `plot`, `set` で利用できま
 す。以下参照: `plot for`。複数のコマンドを包含する一般的な繰り返しは、
 下で紹介するブロック構造を利用することで行えます。関連する新しい機能で
 ある数式型の以下も参照: `summation`。以下は、これらの新しい構文機能を
 いくつか利用した例です:
       set multiplot layout 2,2
       fourier(k, x) = sin(3./2*k)/k * 2./3*cos(k*x)
       do for [power = 0:3] {
           TERMS = 10**power
           set title sprintf("%g term Fourier series",TERMS)
           plot 0.5 + sum [k=1:TERMS] fourier(k,x) notitle
       }
       unset multiplot

2 線種、色、スタイル (linetypes)
?linetypes
?colors
 古い版の gnuplot では、各出力形式は "線種 (linetype)" をある程度用意し
 ていて、それらは色、太さ、点線/破線のパターン、または色と点線/破線の組
 合せで違いを表現していました。それらの色、点線/破線のパターンは、出力
 形式を越えて同じものになるという保証は何もありませんでしたが、多くは同
 じ色の列、赤/緑/青/紫/水色/黄色を使用していました。この古い挙動は、今
 は `set colorsequence classic` で選択できますが、gnuplot バージョン 5
 のデフォルトは、出力形式に無関係に共通の 8 色列を使用します。

 線種 (linetype) の属性の並びは、対話的か初期化ファイルのいずれかによっ
 てさらにカスタマイズ可能です。以下参照: `set linetype`。配布パッケージ
 に初期化ファイルのサンプルがいくつか用意されています。

 特定の出力形式に対する線種の属性の現在の状態は、その出力形式を設定した
 あとで `test` コマンドを実行することで確認できます。

 一つの描画コマンド内での関数やデータファイルの連続する並びには、現在の
 デフォルトの線種列から線種が順番に割り当てられます。個々の関数、データ
 ファイル、またはその他の描画要素に対する線種は、その描画コマンド上で明
 示的に線の属性を指定することで上書きできます。

 例:

      plot "foo", "bar"                 # 線種 1, 2 で 2 ファイルを描画
      plot sin(x) linetype 4            # 線種色 4 を使用

 一般に、色の指定は、色の名前か、RGB (赤、緑、青) 成分か、HSV (色相、彩
 度、明度) 成分か、現在の pm3d パレットに沿った座標で行います。

 例:

      plot sin(x) lt rgb "violet"       # gnuplot の持つ色名の一つ
      plot sin(x) lt rgb "#FF00FF"      # 明示的な 16 進 RGB 3 つ組
      plot sin(x) lt palette cb -45     # 現在のパレットの cbrange の
                                        # -45 に対応する色
      plot sin(x) lt palette frac 0.3   # パレットに対応する小数値

 以下参照: `colorspec`, `show colornames`, `hsv`, `set palette`,
 `cbrange`。

 線種 (linetype) には、点線/破線のパターンも結びつけられていますが、す
 べての出力形式でそれが使えるわけではありません。gnuplot バージョン 5
 では、線色とは独立に点線/破線パターンを指定できます。以下参照:
 `dashtype`。

3 色指定 (colorspec)
?colorspec
?rgbcolor
=colors
?lc
?linecolor
?tc
?textcolor
 多くのコマンドで、明示的な色の指定をともなった線種を指定することができ
 ます。

 書式:

       ... {linecolor | lc} {"colorname" | <colorspec> | <n>}
       ... {textcolor | tc} {<colorspec> | {linetype | lt} <n>}

 <colorspec> は以下の形式のいずれかです:

       rgbcolor "colorname"    # 例: "blue"
       rgbcolor "0xRRGGBB"     # 16 進数値の定数文字列
       rgbcolor "0xAARRGGBB"   # 16 進数値の定数文字列
       rgbcolor "#RRGGBB"      # x11 形式の 16 進数文字列
       rgbcolor "#AARRGGBB"    # x11 形式の 16 進数文字列
       rgbcolor <integer val>  # AARRGGBB を表す整数値
       rgbcolor variable       # 入力ファイルから整数値を読み込む
       palette frac <val>      # <val> は 0 から 1 の値
       palette cb <value>      # <val> は cbrange の範囲の値
       palette z
       variable                # 入力ファイルから色番号を読み込む
       bgnd                    # 背景色
       black

 <n> は、その線種 (linetype) 番号が使う色を意味します。以下参照:
 `test`。

 "colorname" は gnuplot が内部に持っている色の名前のうちの一つを指定し
 ます。有効な名前の一覧に関しては、以下参照: `show colornames`。

 16 進定数は、引用符付きで "#RRGGBB" や "0xRRGGBB" の形で与えることがで
 きます。RRGGBB は、色の赤、緑、青の成分を意味し、それぞれ 00 から FF
 までの範囲内でなければいけません。例えば、マゼンタ (紫) は、最も明るい
 赤 + 最も明るい青、なので "0xFF00FF" と表され、これは 16 進数で
 (255 << 16) + (0 << 8) + (255) を意味しています。

 "#AARRGGBB" は、RGB 色の上位ビットにアルファ値 (透過性) がついているこ
 とを意味します。アルファ値 0 は完全に不透明色であることを意味し、よっ
 て "#00RRGGBB" は "#RRGGBB" と同じになります。アルファ値の 255 (FF) は
 完全に透明であることを意味します。`注意`: この指定法のアルファ値の位置
 は、以前の版の gnuplot の画像描画モード "with rgbalpha" による指定の場
 合の反対になっています。

 カラーパレットとは、色の線型な勾配で、単一の数値を特定の色に滑らかに対
 応づけます。常にそのような 2 つの対応付けが効力を持ちます。
 `palette frac` は 0 から 1 までの小数値を、カラーパレットの全範囲に対
 応付けるもので、`palette cb` は、色軸の範囲を同じカラーパレットへ割り
 当てるものです。以下参照: `set cbrange`, `set colorbox`。これらの対応
 付けのどちらかを使って、現在のパレットから定数色を選び出すことができま
 す。

 "palette z" は、各描画線分や描画要素の z の値を、パレットへ対応づけら
 れている cbrange の範囲に対応づけます。これにより、3 次元の曲線や曲面
 に沿って色を滑らかに変化させることができます。これは、2 次元描画で、パ
 レット値を追加の列データから読み込ませて色付けするのにも使えます (すべ
 ての 2 次元描画スタイルがこの追加列を認識するわけではありません)。
=bgnd
=black
 特殊な色指定が 2 つあります。背景色の `bgnd` と、`black` です。
4 background color
?background
?bgnd
 多くの出力形式でグラフの背景色を明示的に設定できます。特別な線種
 (linetype) `bgnd` はその色で描画しますが、その `bgnd` は色としても認識
 されます。
 例:
      # 以下はキャンバスの一部分を背景色で上書きすることで消去します。
      set term wxt background rgb "gray75"
      set object 1 rectangle from x0,y0 to x1,y1 fillstyle solid fillcolor bgnd
      # 以下は x 軸に沿った「見えない」線を描きます。
      plot 0 lt bgnd
4 linecolor variable
?linecolor variable
?lc variable
?textcolor variable
?tc variable
 `lc variable` は、入力データの一つの列から読んだ値を線種 (linetype) の
 番号として使い、その線種に属する色を使うようプログラムに指示します。よ
 ってこれは、`using` 指定子へ対応する列の指定の追加を必要とします。文字
 の色も同様に、`tc variable` で指定できます。

 例:
       # データの 3 列目を、個々の点に色を割り当てるのに使用
       plot 'data' using 1:2:3 with points lc variable

       # 一つのデータファイルには複数のデータ集合を入れることが可能で、
       # それらは 2 行の空行で分離されています。個々のデータ集合には
       # index 値が割り当てられていて (以下参照: `index`)、using 指定の
       # column(-2) で取得できます。以下参照: `pseudocolumns`。以下の例
       # は -2 の column 値を使って、個々のデータ集合を異なる線色で描画
       # します。
       plot 'data' using 1:2:(column(-2)) with lines lc variable

4 rgbcolor variable
?rgbcolor variable
?lc rgbcolor variable
?tc rgbcolor variable
 グラフの各データ点、各線分、または各ラベルにそれぞれ異なる色を割り当て
 ることができます。`lc rgbcolor variable` は、データファイルの各行から
 RGB 色の情報を読み込むようプログラムに指示します。よってこれは、
 `using` 指定子による対応する列の指定の追加を必要とし、その列は 24-bit
 形式の RGB の 3 つ組であるとみなされます。その値をデータファイルから直
 接与える場合は、これは最も簡単な形式の 16 進値で与えます (以下参照:
 `rgbcolor`)。一方で、以下の例のように 24-bit RGB 色として評価されるよ
 うな数式を `using` 指定子に入れることもできます。文字の色も同様に、
 `tc rgbcolor variable` で指定できます。

 例:
       # 3 次元描画で、各 x,y,z 座標に対応した赤、緑、青の成分を持つ色
       # のついた点を配置
       rgb(r,g,b) = 65536 * int(r) + 256 * int(g) + int(b)
       splot "data" using 1:2:3:(rgb($1,$2,$3)) with points lc rgb variable

3 点線/破線種 (dashtype)
?dashtype
=dashtype
 gnuplot バージョン 5 で、`linecolor` や `linewidth` と同様に、点線/破
 線パターン (`dashtype`) が各曲線毎の属性として独立しました。従来のよう
 な、使用中の出力形式の点線を書くための特別なモードとして指定する必要は
 ありません。すなわち、`set term <termname> {solid|dashed}` のようなコ
 マンドは現在は無視されます。

 すべての線は、ほかに指定しなければ、`dashtype solid` という属性を持ち
 ますが、このデフォルト値をコマンド `set linetype` で特定の線種に変更し
 その後のコマンドで使えるようにできます。または、`plot` や他のコマンド
 の一部分として使用したい点線/破線の型を指定できます。

 書式:
       dashtype N          # 定義済み点線/破線型を番号で呼び出し
       dashtype "pattern"  # 点 (.) 横線 (-) 下線 (_) と空白の組み合わ
                           # せ文字列による指定
       dashtype (s1,e1,s2,e2,s3,e3,s4,e4)  # 1~4 個の <実線長>,<空白長>
                           # の組による点線/破線パターン指定

 例:
       # 2 つの関数が線種 1 を使うが dashtype で区別
       plot f1(x) with lines lt 1 dt solid, f2(x) with lines lt 1 dt 3

 いくつかの出力形式は、それが提供する定義済み点線/破線パターンに、ユー
 ザ定義パターンを追加することをサポートしています。

 例:
      plot f(x) dt 3            # 出力形式の持つパターン 3 を使用
      plot f(x) dt ".. "        # 一時的なパターンを作成
      plot f(x) dt (2,5,2,15)   # 同じパターンを数値で表現
      set dashtype 11 (2,4,4,7) # 新パターンを番号で呼び出せるよう定義
      plot f(x) dt 11           # 新パターンを使って描画

 点線/破線パターンを文字列で指定した場合、gnuplot はそれを <実線長>,
 <空白長> の組の列に変換します。その場合、コマンド `show dashtype` は、
 元の文字列と変換後の数値の列の両方を表示します。

3 linestyles と linetypes
?linestyles vs linetypes
 `linestyle` は、属性 linecolor, linewidth, dashtype, pointtype の一時
 的な組み合わせで、これはコマンド `set style line` で定義します。一度
 linestyle を定義すると、1 回の plot コマンド上でそれを使って、1 つ、ま
 たはより多くの描画要素の見た目を制御できます。言い換えれば、これは丁度
 linetype から永続性を取り除いたもの、と言うことができるでしょう。
 `linetypes` は永続的 (明示的にそれらを再定義するまでは保持される) です
 が、`linestyles` は、次のグラフィックの状態がリセットされるまでの間し
 か保持されません。

 例:

      # 新しいラインスタイルを、出力形式に依存しない色 cyan、線幅が 3、
      # 点種 6 (丸の中に点) と定義
      set style line 5 lt rgb "cyan" lw 3 pt 6
      plot sin(x) with linespoints ls 5          # 定義スタイル 5 で

2 レイヤー (layers)
?layers
=behind
=front
=back
 gnuplot のグラフは、色々な要素を固定された順番で描き上げていくことで構
 成されています。この順番は、キーワード `behind`, `back`, `front` を使
 って要素に特定の階層を割り当てることで変更できます。例えば、グラフ領域
 の背景色を変更するには、色のついた長方形を属性 `behind` で定義すればい
 いわけです。
      set object 1 rectangle from graph 0,0 to graph 1,1 fc rgb "gray" behind
 描画の順番は以下の通りです:
      behind
      back
      グラフ自体
      グラフの表題 (`key`)
      front
 各階層内では、要素の描画は以下の順番です:
      番号順のオブジェクト (rectangle, circle, ellipse, polygon)
      番号順のラベル (label)
      番号順の矢印 (arrow)
 1 ページに複数のグラフがある場合 (multiplot モード)、この順序は、複数
 グラフを全体として適用するのではなく、各描画要素に別々に適用します。
2 マウス入力 (mouse input)
?mouse input
 多くの出力形式で、現在の描画にマウスを使って作用をすることが可能になっ
 ています。そのうちいくつかはホットキーの定義もサポートしていて、マウス
 カーソルが有効な描画ウィンドウにあるときに、あるキーを押すことであらか
 じめ定義した関数を実行させることができます。マウス入力を `batch` コマ
 ンドスクリプトと組み合わせることも可能で、例えば `pause mouse` として、
 その後にマウスクリックによってパラメータとして返って来るマウス変数をそ
 の後のスクリプト動作に反映させることができます。以下参照: `bind`,
 `mouse variables`。また以下も参照: `set mouse`。
3 bind
?commands bind
?hotkey
?hotkeys
?bind
 書式:
       bind {allwindows} [<key-sequence>] ["<gnuplot commands>"]
       bind <key-sequence> ""
       reset bind

 `bind` は、ホットキーの定義、再定義に使用します。ホットキーとは、入力
 カーソルがドライバのウィンドウ内にあるときに、あるキー、または複数のキ
 ーを押すことで、gnuplot のコマンド列を実行させる機能のことを言います。
 `bind` は、gnuplot が `mouse` をサポートするようにコンパイルされていて
 かつマウスが有効な出力形式上で使われてる場合にのみ有効であることに注意
 してください。ユーザ指定のキー割当 (binding) は、組み込み (builtin) キ
 ー割当を置き換えますが、<space> と 'q' は通常は再定義はできません。そ
 の唯一の例外については、以下参照: `bind space`。

 マウスボタンは、ボタン 1 のみ、2 次元描画用にのみ定義可能です。

 ホットキーの一覧を得るには `show bind`, または `bind` とタイプするか、
 グラフウィンドウ上でホットキー 'h' を入力してください。

 キー定義は、`reset bind` でデフォルトの状態に復帰できます。

 修飾キーを含む複数のキーの定義は引用符で囲む必要があることに注意してく
 ださい。

 標準ではホットキーは現在の描画ウィンドウ上に入力カーソルがある場合のみ
 認識されます。`bind allwindows <key> ...` (`bind all <key> ...` と省略
 可) は、<key> の割当を、それが現在の有効なものか否かに関わらず、すべて
 の gnuplot の描画ウィンドウ上で可能にします。この場合、gnuplot 変数
 MOUSE_KEY_WINDOW にそれが行なわれたウィンドウの ID が保存されるのでそ
 れをキーに割り当てたコマンドで使用することができます。

 例:

 - キー割当の設定:

     bind a "replot"
     bind "ctrl-a" "plot x*x"
     bind "ctrl-alt-a" 'print "great"'
     bind Home "set view 60,30; replot"
     bind all Home 'print "This is window ",MOUSE_KEY_WINDOW'

 - キー割当を表示:
     bind "ctrl-a"          # ctrl-a に対するキー割当を表示
     bind                   # 全てのキー定義を表示
     show bind              # 全てのキー定義を表示

 - キー割当を削除:
     bind "ctrl-alt-a" ""   # ctrl-alt-a のキー割当を削除
                              (組み込みキー定義は削除されません)
     reset bind             # デフォルト (組み込み) のキー定義を導入

 - トグルスイッチ形式にキー割当:
   v=0
   bind "ctrl-r" "v=v+1;if(v%2)set term x11 noraise; else set term x11 raise"

 修飾キー (ctrl / alt) は大文字小文字の区別はありませんが、キーはそうで
 はありません:
     ctrl-alt-a == CtRl-alT-a
     ctrl-alt-a != ctrl-alt-A

 修飾キー (alt == meta) の一覧:
     ctrl, alt

 サポートされている特殊キーの一覧:

    "BackSpace", "Tab", "Linefeed", "Clear", "Return", "Pause", "Scroll_Lock",
    "Sys_Req", "Escape", "Delete", "Home", "Left", "Up", "Right", "Down",
    "PageUp", "PageDown", "End", "Begin",

    "KP_Space", "KP_Tab", "KP_Enter", "KP_F1", "KP_F2", "KP_F3", "KP_F4",
    "KP_Home", "KP_Left", "KP_Up", "KP_Right", "KP_Down", "KP_PageUp",
    "KP_PageDown", "KP_End", "KP_Begin", "KP_Insert", "KP_Delete", "KP_Equal",
    "KP_Multiply", "KP_Add", "KP_Separator", "KP_Subtract", "KP_Decimal",
    "KP_Divide",

    "KP_1" - "KP_9", "F1" - "F12"

 以下は、実際のキーではなく、ウィンドウに関するイベントです:

    "Button1" "Close"

 以下も参照: `mouse`。
4 bind space
?commands bind space
?bind space
 gnuplot が、configure 時にオプション --enable-rase-console をつけてイ
 ンストールされた場合は、描画ウィンドウ内で <space> をタイプすると
 gnuplot のコマンドウィンドウが前面に出ます。このホットキーは、
 'gnuplot -ctrlq' のようにして gnuplot を起動するか、または X リソース
 の 'gnuplot*ctrlq' を設定することで ctrl-space に変更できます。
 以下参照: `x11 command-line-options`。
3 マウス用の変数 (Mouse variables)
?mouse variables
 `mousing` (マウス機能) が有効な場合、現在のウィンドウ上でのマウスクリ
 ックによって gnuplot のコマンドライン上で使うことができる色々なユーザ
 変数が設定されます。クリック時のマウスの座標は変数 MOUSE_X, MOUSE_Y,
 MOUSE_X2, MOUSE_Y2 に代入されます。クリックされたボタンや、そのときの
 メタキーの状態は MOUSE_BUTTON, MOUSE_SHIFT, MOUSE_ALT, MOUSE_CTRL に代
 入されます。これらの変数は任意の描画の開始時には未定義で、有効な描画ウ
 ィンドウ中でのマウスクリックイベントによって初めて定義されます。有効な
 描画ウィンドウ中でマウスが既にクリックされたかどうかをスクリプトから調
 べるには、これらの変数のうちのどれか一つが定義されているかどうかをチェ
 ックすれば十分です。

       plot 'something'
       pause mouse
       if (exists("MOUSE_BUTTON")) call 'something_else'; \
       else print "No mouse click."

 描画ウィンドウ上での一連のキー入力を追跡することも、マウスコードを使う
 ことで可能となります。

       plot 'something'
       pause mouse keypress
       print "Keystroke ", MOUSE_KEY, " at ", MOUSE_X, " ", MOUSE_Y

 `pause mouse keypress` が、キー入力で終了した場合は MOUSE_KEY には押さ
 れたキーの ASCII コードが保存されます。MOUSE_CHAR にはその文字自身が文
 字列値として保存されます。pause コマンドが (例えば ctrl-C や描画ウィン
 ドウが外部から閉じられるなどして) 異常終了した場合は MOUSE_KEY は -1
 になります。

 マウスによる拡大の後の新しい描画範囲は、GPVAL_X_MIN, GPVAL_X_MAX,
 GPVAL_Y_MIN, GPVAL_Y_MAX で参照できることに注意してください。
 以下参照: `gnuplot-defined variables`。
2 残留 (Persist)
?persist
 gnuplot の多くの出力形式 (aqua, pm, qt, x11, windows, wxt, ...) が、ス
 クリーン上にグラフをその中に描いた表示用のウィンドウを別に開きます。オ
 プション `persist` は、主たるプログラムが終了したときにも、それらのウ
 ィンドウを残すよう gnuplot に指示します。
 これは、非対話型出力形式出力では何もしません。
 例えば、以下のコマンドを実行すると

      gnuplot -persist -e 'plot [-5:5] sinh(x)'

 gnuplot は、表示ウィンドウを開き、その中にグラフを描き、そして終了し、
 表示ウィンドウはグラフをその中に持ったままスクリーンに残ります。出力形
 式によっては、その残ったウィンドウ上でも多少のマウス操作が可能な場合も
 あります。しかし、グラフの再描画を要求するズーム (とその逆) のような操
 作は、既にプログラムが終了しているので一般的には無理です。

 新しい出力形式を設定するときにも `persist` や `nopersist` を指定できま
 す。例:

      set term qt persist size 700,500

2 描画 (Plotting)
?plotting
 `gnuplot` にはグラフを描画する 4 つのコマンド `plot`, `splot`,
 `replot`, `refresh` があります。`plot` は 2 次元グラフを生成し、
 `splot` は 3 次元グラフ (もちろん実際にはその 2 次元面への射影) を生成
 します。`replot` は、それに与えた引数を、直前の `plot` や `splot` コマ
 ンドに追加したものを実行し、`refresh` は、データをファイルから再読み込
 みする代わりに前に保存したデータを使って、直前の `plot` や `splot` コ
 マンドを再実行します。

 描画に関する一般的な情報の大半は、`plot` に関する項で見つかります。3
 次元描画に固有の情報は `splot` の項にあります。

 `plot` は xy 直交座標系と極座標系が使えます。以下参照: `set polar`。
 `splot` は xyz 直交座標が使えますが、3 次元極座標、円柱座標データも入
 力できます。以下参照: `set mapping`。
=axes
 `plot` では、4 つの境界 x (下), x2 (上), y (左), y2 (右) をそれぞれ独
 立な軸として扱うこともできます。オプション `axes` で、与えられた関数や
 データ集合をどの軸のペアで表示させるかを選べます。また、各軸の縮尺や見
 出しづけを完全に制御するために十分な補佐となる `set` コマンド群が存在
 します。いくつかのコマンドは、`set xlabel` のように軸の名前をその中に
 持っていますし、それ以外のものは `set logscale xy` のように、1 つ、ま
 たは複数の軸の名前をオプションとしてとります。z 軸を制御するオプション
 やコマンドは 2 次元グラフには効力を持ちません。

 `splot` は、点や線に加えて曲面や等高線を書くことができます。3 次元の関
 数の格子定義に関する情報については、以下参照: `set isosamples`。3 次元
 データのファイルに必要な形態については、以下参照: `splot datafile`。等
 高線に関する情報については、以下参照: `set contour`, `set cntrlabel`,
 `set cntrparam`。

 `splot` での縮尺や見出し付けの制御は、z 軸にも有効であること、および
 x2 軸、y2 軸のラベル付けが `set view map` を使って作られる疑似的な 2
 次元描画にのみ可能であることを除けば `plot` と全く同じです。
2 初期化 (Startup (initialization))
?startup
?start
?start-up
?initialization
?.gnuplot
 起動時に、gnuplot はまずシステム用の初期設定ファイル `gnuplotrc` を探
 します。そのファイルの置き場所は gnuplot のインストール時に決定され、
 `show loadpath` で知ることができます。次にユーザのホームディレクトリ内
 に個人用の設定ファイルを探します。そのファイルは Unix 系のシステムでは
 `.gnuplot` であり、その他の処理系では `GNUPLOT.INI` となっています。
 (Windows と OS/2 では、環境変数 `GNUPLOT` に設定されている名前のディレ
 クトリ内にそれを探します; Windows では、変数 GNUPLOT が定義されていな
 ければ `USEPROFILE` を使用します)。注意: インストール時に `gnuplot` が
 最初にカレントディレクトリを探すように設定できますが、セキュリティ上危
 険なのでそれは推奨しません。
2 文字列定数と文字列変数 (Strings)
?strings
?string variables
 文字列定数に加えて、ほとんどの gnuplot コマンドは文字列変数、文字列式
 または文字列を返す関数も受け付けます。例えば、以下の 4 つの plot のや
 り方は結果として全て同じ描画タイトルを生成します:

       four = "4"
       graph4 = "Title for plot #4"
       graph(n) = sprintf("Title for plot #%d",n)

       plot 'data.4' title "Title for plot #4"
       plot 'data.4' title graph4
       plot 'data.4' title "Title for plot #".four
       plot 'data.4' title graph(4)

 整数は、それが文字列結合演算子によって作用された場合は、文字列に変換さ
 れますので、以下の例も上と同様に動作します:

       N = 4
       plot 'data.'.N title "Title for plot #".N

 一般に、コマンドラインの各要素は、それらが標準的な gnuplot への命令文
 法の一部分と認識されるもの以外は、有効な文字列変数としての評価のみが行
 なわれます。よって、以下のコマンド列は、恐らくは混乱を引き起こさないよ
 うに避けられるべきですが、文法的には間違ってはいません:

       plot = "my_datafile.dat"
       title = "My Title"
       plot plot title title

 次の 3 つの二項演算子は文字列に作用します: 文字列の結合演算子 ".", 文
 字列の等号演算子 "eq", および文字列の不等号演算子 "ne" です。以下の例
 では TRUE が表示されます。

      if ("A"."B" eq "AB") print "TRUE"

 以下も参照: 2 つの文字列書式関数 `gprintf`, `sprintf`。

=substring
 任意の文字列、文字列変数、文字列値関数に、範囲指定子をつけることにより
 部分文字列を指定できます。範囲指定子は [begin:end] の形で、begin は部
 分文字列の先頭位置、end は最後の位置です。位置指定は、最初の文字を 1
 番目と見ます。先頭の位置、最後の位置は空、あるいは '*' でも構いません。
 その場合、それは元の文字列自体の先頭、あるいは最後を意味します。例えば、
 str[:] や str[*:*] はどちらも str の文字列全体を意味します。
2 置換とコマンドラインマクロ (Substitution)
?substitution
 gnuplot への命令文字列が最初に読み込まれた時点、すなわちまだそれが解釈
 され、もしくは実行される前の段階で、2 つの形式の単語の置換が実行されま
 す。それらは逆引用符 (｀) (ASCII 番号 96) で囲まれているか、または @
 (ASCII 番号 64) が頭についた文字列に対して行なわれます。
3 逆引用符によるシステムコマンドの置換 (Substitution backquotes)
?substitution backquotes
?backquotes
?shell commands
 シェルコマンドを逆引用符 (｀) で囲むことによってコマンド置換を行うこと
 ができます。このコマンドは子プロセスで実行され、その出力結果でコマンド
 ラインの逆引用符で囲まれたコマンドを置き換えます。処理系によってはパイ
 プがサポートされている場合もあります。以下参照:
 `plot datafile special-filenames`。

 コマンド置換は、単一引用符内の文字列以外は、`gnuplot` のコマンドライ
 ン中、どこででも使用可能です。

 例:

 以下の例は、`leastsq` というプログラムを実行し、その出力結果で、
 `leastsq` を (まわりの引用符こみで) 置き換えます:
       f(x) = `leastsq`

 ただし VMS では、
       f(x) = `run leastsq`

 以下は現在の日付とユーザー名のラベルを生成します:
       set label "generated on `date +%Y-%m-%d` by `whoami`" at 1,1
       set timestamp "generated on %Y-%m-%d by `whoami`"
3 文字列変数のマクロ置換 (Substitution macros)
?substitution macros
?macros
=exists
 コマンドラインのマクロ置換はデフォルトでは無効になっていますが、
 `set macros` で有効にできます。マクロ置換が有効である場合、文字 @ は、
 コマンドライン上でその文字列変数の値への置換を行なうのに使われます。文
 字列変数の値としての文は、複数の単語からなることも可能です。これにより
 文字列変数をコマンドラインマクロとして使うことが可能になります。この機
 能により展開できるのは文字列定数のみで、文字列を値に取る数式を使うこと
 はできません。
 例:

       set macros
       style1 = "lines lt 4 lw 2"
       style2 = "points lt 3 pt 5 ps 2"
       range1 = "using 1:3"
       range2 = "using 1:5"
       plot "foo" @range1 with @style1, "bar" @range2 with @style2

 この @ 記号を含む行は、その入力時に展開され、それが実際に実行されると
 きには次のように全部打ち込んだ場合と同じことになります。

       plot "foo" using 1:3 with lines lt 4 lw 2, \
            "bar" using 1:5 with points lt 3 pt 5 ps 2

 関数 exists() はマクロの評価に関して有用でしょう。以下の例は、C が安全
 にユーザ定義変数の名前に展開できるかどうかをチェックします。

       C = "pi"
       if (exists(C)) print C," = ", @C

 マクロの展開は、単一引用符内、または二重引用符内では行なわれませんが、
 逆引用符 (｀) 内ではマクロ展開されます。

 マクロの展開は、gnuplot が新しいコマンド行を見たときに非常に早い段階で
 gnuplot が処理し、そしてただ一度だけそれを行います。よって、

      A = "c=1"
      @A

 のようなコードは正しく実行しますが、以下のような行はだめです。それは、
 マクロの定義が同じ行にあるため展開に間に合わないからです。

      A = "c=1"; @A   # will not expand to c=1

 コマンドを完成させて実行するには、コマンド `evaluate` も有用でしょう。
3 文字列変数、マクロ、コマンドライン置換 (mixing_macros_backquotes)
?mixing_macros_backquotes
?substitution mixing_macros_backquotes
 文字列変数や逆引用符 (｀) による置換、マクロによる置換の相互関係は少し
 ややこしいです。逆引用符はマクロ置換を妨げないので、

       filename = "mydata.inp"
       lines = ` wc --lines @filename | sed "s/ .*//" `

 は、mydata.ipn の行数を整数変数 lines に保存することになります。また、
 二重引用符は逆引用符の置換を妨げないので、

       mycomputer = "`uname -n`"

 は、システムコマンド `uname -n` の返す文字列を文字列変数 mycomputer に
 保存することになります。

 しかし、マクロ置換は二重引用符内では機能しないので、システムコマンドを
 マクロとして定義してそれをマクロとして利用しかつ逆引用符置換を行なうこ
 とはでできません。

        machine_id = "uname -n"
        mycomputer = "`@machine_id`"  # うまくいかない !

 この失敗は、二重引用符が @machine_id をマクロとして解釈することを妨げ
 ているからです。システムコマンドをマクロとして保存し、その後それを実行
 するには、逆引用符自体もマクロ内に含める必要があります。これは以下のよ
 うにマクロを定義することで実現できます。sprintf の書式には 3 種類の引
 用符全てが入れ子になっていることに注意してください。

       machine_id = sprintf('"`uname -n`"')
       mycomputer = @machine_id
2 区切りやカッコの使い方 (Syntax)
?syntax
?specify
?punctuation
 リストや座標がコンマ (,) 区切りであるのに対し、オプションやそれに伴う
 パラメータはスペース ( ) 区切りです。範囲はコロン (:) で区切ってかぎか
 っこ ([]) でくくりますし、文字列やファイル名は引用符でくくり、他にいく
 つかカッコ (()) でくくるものがあります。

 コンマは以下の区切りで使用されます。`set` コマンドの `arrow`, `key`,
 `label` の座標; 当てはめ (fit) られる変数のリスト (コマンド `fit` のキ
 ーワード `via` に続くリスト); コマンド `set cntrparam` で指定されると
 びとびの等高線の値やそのループパラメータのリスト; `set` コマンドの
 `dgrid3d` `dummy`, `isosamples`, `offsets`, `origin`, `samples`,
 `size`, `time`, `view` の引数; 目盛りの位置やそのループパラメータのリ
 スト; タイトルや軸の見出しの位置; `plot`, `replot`, `splot` コマンドの
 x,y,z 座標の計算に使われる媒介変数関数のリスト; `plot`, `replot`,
 `splot` コマンドの複数の描画 (データ、または関数) のそれぞれの一連のキ
 ーワードのリスト。

 (丸) カッコは、目盛りの見出しを (ループパラメータではなく) 明示的に集
 合与える場合の区切りとして、または `fit`, `plot`, `replot`, `splot` コ
 マンドの `using` フィルタでの計算を指示するために使われます。

 (カッコやコンマは通常の関数の表記でも使われます。)

 かぎかっこは、`set`, `plot`, `splot` コマンドでは範囲を区切るのに使わ
 れます。

 コロンは `range` (範囲) 指定 (`set`, `plot`, `splot` コマンドで使われ
 る) の両端の値を区切るのに、または `plot`, `replot`, `splot`, `fit` コ
 マンドの `using` フィルタの各エントリを区切るのに使われます。

 セミコロン (;) は、一行のコマンド行内で与えられる複数のコマンドを区切
 るのに使われます。

 中カッコ ({}) は、拡張文字列処理モード (enhanced text mode) の記述や、
 if/then/else 文のブロックの区切りとして使われますし、または複素数を記
 述するのにも使われます: {3,2} = 3 + 2i となります。

 EEPIC, Imagen, Uniplex, LaTeX, TPIC の各出力形式では、単一引用符内の
 \\ または二重引用符内の \\\\ で改行を示すことが可能です。
3 引用符 (Quotes)
?quotes
?syntax quotes
 gnuplot は、文字列を区切るのに、二重引用符 (ASCII コード 34 番)、単一
 引用符 (ASCII コード 39 番)、および逆引用符 (｀) (ASCII コード 96 番)
 の 3 種類の引用符を使います。

 ファイル名は単一引用符、あるいは二重引用符内で囲みます。このマニュアル
 では一般にコマンドの例示では、わかりやすくするためにファイル名は単一引
 用符でくくり、他の文字列は二重引用符でくくります。

 見出し (label)、タイトル (title)、またはその他の描画要素で使用される文
 字列定数や複数行文字列は単一引用符、あるいは二重引用符内で囲みます。引
 用符で囲まれた文字列のさらなる処理の結果は、どの引用符記号を選ぶかによ
 って変わります。

 \n (改行) や \345 (8 進表記の文字コード) のようなバックスラッシュ (\)
 による特殊文字表現は、2 重引用符内の文字列では効力を持ちます。単一引用
 符内では、バックスラッシュ自体が通常の文字と見なされます。単一引用符
 内の文字列で単一引用符自体 (ASCII コード 39 番) を使うには、それを重ね
 て書く必要があります。つまり、文字列 "d\" s' b\\" と、'd" s'' b\' は完
 全に同じものとなります。

 1 つの複数行文字列に関する位置合わせは各行に同等に働きます。よって、中
 央に位置合わせされた文字列
       "This is the first line of text.\nThis is the second line."
 は次のように表示されます:
                        This is the first line of text.
                           This is the second line.
 しかし
       'This is the first line of text.\nThis is the second line.'
 だと次のようになります。
           This is the first line of text.\nThis is the second line.

 拡張文字列処理 (enhanced text processing) は二重引用符に対しても単一引
 用符に対しても機能します。しかし、そのモードをサポートしている出力形式
 でのみ働きます。以下参照: `enhanced text`。

 逆引用符は,コマンドライン中の置換のためにシステムコマンドを囲むのに使
 います。以下参照: `substitution`。
2 時間/日付データ (Time/Date)
?time/date
 `gnuplot` は入力データとして時間/日付情報の使用をサポートしています。
 この機能は `set xdata time`, `set ydata time` などのコマンドによって有
 効になります。

 内部では全ての時間/日付は 1970 年からの秒数に変換されます。コマンド
 `set timefmt` は全ての入力に対するデフォルトの書式を定義します。データ
 ファイル、範囲、軸の目盛りの見出し、ラベルの位置と、日時データ値を受け
 入れるすべてのものへの入力の書式が、デフォルトでこれになります。一時に
 は一つのデフォルト入力書式のみが有効です。よって、ファイル内の x と y
 の両方が時間/日付データである場合は、デフォルトではそれは同じ書式と解
 釈されます。しかし、このデフォルトは、`using` 指定で関数 `timecolumn`
 を用いて、それに対応する特定のファイルや列からデータを読みこむことによ
 り、変えることが可能です。

 秒数へ (秒数から) の変換は国際標準時 (UT; グリニッジ標準時 (GMT) と同
 じ) が使われます。各国標準時や夏時間への変換の機能は何も持ち合わせてい
 ません。もしデータがすべて同じ標準時間帯に従っているなら (そして全てが
 夏時間か、そうでないかのどちらか一方にのみ従うなら) これに関して何も心
 配することはありません。しかし、あなたが使用するアプリケーションで絶対
 的な時刻を厳密に考察しなければいけない場合は、あなた自身が UT に変換す
 べきでしょう。

 `show xrange` のようなコマンドは、その整数値を `timefmt` に従って解釈
 し直します。`timefmt` を変更してもう一度 `show` でその値を表示させると、
 それは新しい `timefmt` に従って表示されます。このため、(`set xdata` な
 どにより) その軸に対するデータ型をリセットすると、その値は整数値として
 表示されることになります。

 コマンド `set format` または `set tics format` は、指定された軸に対す
 る入力が時間/日付であるなしに関わらず目盛りの見出しに使われる書式を定
 義します。

 時間/日付情報がファイルから描画される場合、`plot`, `splot` コマンドで
 は `using` オプションを「必ず」使う必要があります。`plot`, `splot` で
 は各行のデータ列の分離にスペースを使いますが、時間/日付データはその中
 にスペースを含み得るからです。もしタブ区切りを使用しているのなら、あな
 たのシステムがそれをどう扱うか確かめるために何度もテストする必要がある
 でしょう。

 関数 `time` は、現在のシステム時刻を得るのに使えます。この値は、
 `strftime` 関数で日時文字列に変換できますし、`timecolumn` と組み合わせ
 て相対的な日時グラフを作成するのにも使えます。引数の型はそれが返すもの
 を決定します。引数が整数の場合は time() は現在の時刻を 1970 年 1 月 1
 日からの整数として返し、引数が実数 (または複素数) ならば同様の値を実数
 として返しますが、小数 (秒以下) 部分の精度は、オペレーティングシステム
 に依存します。引数が文字列ならば、それを書式文字列であるとみなし、書式
 化された日時文字列を提供するようそれを `strftime` に渡します。

 次の例は時間/日付データの描画の例です。

 ファイル "data" は以下のような行からなるとします:

       03/21/95 10:00  6.02e23

 このファイルは以下のようにして表示されます:

       set xdata time
       set timefmt "%m/%d/%y"
       set xrange ["03/21/95":"03/22/95"]
       set format x "%m/%d"
       set timefmt "%m/%d/%y %H:%M"
       plot "data" using 1:3

 ここで、x 軸の目盛りの見出しは "03/21" のように表示されます。

 現在の gnuplot は、時刻をミリ秒精度で追跡し、時刻のフォーマットもそれ
 に伴って変更されています。
 例: 現在の時刻をミリ秒精度で表示
      print strftime("%H:%M:%.3S %d-%b-%Y",time(0.0))
      18:15:04.253 16-Apr-2011

 以下参照: `time_specifiers`。
1 描画スタイル (plotting styles)
?plotting styles

 gnuplot では、たくさんの描画スタイルが利用できます。
 それらは、アルファベット順に以下に紹介されています。
 コマンド `set style data` と `set style function` は、それ以降の
 `plot` や `splot` コマンドに対してデフォルトの描画スタイルを変更
 します。

 描画スタイルは、コマンド `plot` や `splot` の一部分として、明示的にオ
 プション指定することもできます。一つの描画の中で、複数の描画スタイルを
 組み合わせたい場合は、各要素に対して描画スタイルを指定する必要がありま
 す。

 例:

      plot 'data' with boxes, sin(x) with lines

 各描画スタイルは、それ自体がデータファイルからのいくつかのデータの組
 を期待します。例えば、デフォルトでは `lines` スタイルは、y の値だけの
 1 列のデータ (x の値は暗黙に順番に取られる)、または最初が x, 次が y の
 2 つの列を期待しています。ファイルの何列のデータを描画データと解釈させ
 るうまい方法に関する情報については、以下参照: `using`。

2 boxerrorbars
?plotting styles boxerrorbars
?style boxerrorbars
?boxerrorbars
 描画スタイル `boxerrorbars` は 2 次元のデータ描画でのみ利用可能です。
 これは、3 列、または 4 列、または 5 列のデータが必要です。入力列を追加
 (4,5,6 列目) すると、それらは各データ点毎の variable color 情報 (以下
 参照: `linecolor`, `rgbcolor variable`) として使われます。誤差線は、箱
 の境界と同じ色で描画されます。

      3 列:  x  y  ydelta
      4 列:  x  y  ydelta xdelta        # 箱の幅 != -2
      4 列:  x  y  ylow  yhigh          # 箱の幅 == -2
      5 列:  x  y  ylow  yhigh  xdelta

Ffigure_boxerrorbars
 y の誤差が "ydelta" の形式で与えられて、箱の横幅があらかじめ -2.0 に設
 定されて (`set boxwidth -2.0`) いなければ、箱の横幅は 4 列目の値で与え
 られます。y の誤差が "ylow yhigh" の形式で与えられる場合は箱の横幅は 5
 列目の値で与えられます。特別な場合として、"ylow yhigh" の誤差形式の 4
 列のデータに対する `boxwidth = -2.0` という設定があります。この場合箱
 の横幅は、隣接する箱にくっつくように自動的に計算されます。3 列のデータ
 の場合も、横幅は自動的に計算されます。

 箱の高さは、`yerrorbars` スタイル同様に y の誤差の値から決定されます。
 y-ydelta から y+ydelta まで、あるいは ylow から yhigh まで、これらは何
 列のデータが与えられているかによって決まります。
2 boxes
?plotting styles boxes
?style boxes
?boxes
 `boxes` スタイルは 2 次元描画でのみ利用可能です。これは与えられた x 座
 標を中心とし、x 軸から (グラフの境界から、ではありません) 与えられた y
 座標までの箱を書きます。これは基本的に、2 列、または 3 列のデータを使
 用します。余分な入力列は、variable 行や塗り潰し色の情報が提供されたも
 のとして使用されます (以下参照: `rgbcolor variable`)。

      2 列:  x  y
      3 列:  x  y  x_width

Ffigure_boxes
 箱の幅は 3 つのうち一つの方法で決定されます。入力データが 3 列目のデー
 タを持っている場合は、それが箱の幅にセットされます。そうでなくて
 `set boxwidth` コマンドで箱の幅がセットされていた場合は、それが使われ
 ます。そのどちらでもない場合、箱の幅は、隣接する箱がくっつくように自動
 的に計算されます。

 箱の中身は現在の塗りつぶしスタイル (fillstyle) に従って塗りつぶされま
 す。詳細は、以下参照: `set style fill`。新しい塗りつぶしスタイルを
 plot コマンド上で指定することもできます。
 塗りつぶしスタイルが `empty` の場合は、箱は塗りつぶされません。
 塗りつぶしスタイルが `solid` の場合は、箱は現在の描画色でベタ塗りされ
 ますが、fillstyle パラメータを追加することで塗りつぶし密度を制御できま
 す。0 は背景色、1 は描画色そのものになります。
 塗りつぶしスタイルが `pattern` の場合は、箱は現在の描画色で、あるパタ
 ーンで塗りつぶします。

 例:

 データファイルを塗りつぶした箱で描画し、箱同士を少し垂直方向にスペース
 を空ける (棒グラフ):

       set boxwidth 0.9 relative
       set style fill solid 1.0
       plot 'file.dat' with boxes

 パターンでの塗りつぶしスタイルの箱で sin と cos のグラフを描画:

       set style fill pattern
       plot sin(x) with boxes, cos(x) with boxes

 sin はパターン 0 で、cos はパターン 1 で描画されます。追加される描画は
 出力ドライバがサポートするパターンを循環的に使用します。

 それぞれのデータ集合で明示的に塗りつぶしスタイルを指定:

      plot 'file1' with boxes fs solid 0.25, \
           'file2' with boxes fs solid 0.50, \
           'file3' with boxes fs solid 0.75, \
           'file4' with boxes fill pattern 1, \
           'file5' with boxes fill empty

2 boxplot
?plotting styles boxplot
?style boxplot
?boxplot
Ffigure_boxplot
 boxplot は、値の統計的な分布を表現する一般的な方法です。四分位境界は、
 1/4 の点が第一四分位境界以下の値を持つように、1/2 の点が第二四分位境界
 (メジアン) 以下の値を持つように、等と決定されます。第一四分位と第三四
 分位の間の領域を囲むように箱を描画し、メジアン値のところには水平線を描
 きます。箱ひげは、箱からユーザ指定限界まで延長されます。それらの限界の
 外にある点は、ひとつひとつ描画されます。

 例:

     # x 座標は 1.0、y は 5 列目の値のところに boxplot を配置
     plot 'data' using (1.0):5

     # 上と同じだが、範囲外の点は隠し、boxplot の幅を 0.3 にする
     set style boxplot nooutliers
     plot 'data' using (1.0):5:(0.3)

 デフォルトでは、using 指定による 2 列目の y のすべての値に対する
 boxplot を 1 つだけ生成します。しかし、追加の (4 つ目の) 列を指定する
 と、その列の値をある因子変数の離散的なレベル値であると見なし、その離散
 値のレベルの値の数だけの boxplot を描画します。それらの boxplot の間隔
 はデフォルトでは 1.0 ですが、これは `set style boxplot separation` で
 変更できます。デフォルトでは、因子変数の値は、各 boxplot の下 (または
 上) の目盛りのラベルに表示します。

 例

     # 'data' の 2 列目は "control" か "treatment" のいずれかの文字列で
     # 以下の例は、その因子毎の 2 つの boxplot を生成する
     plot 'data' using (1.0):5:(0):2

 その箱のデフォルトの幅は `set boxwidth <width>` で設定できますが、plot
 コマンドの `using` による 3 番目のオプション列でも指定できます。1 番目
 と 3 番目の列 (x 座標と幅) は通常データ列ではなく定数として与えます。

 デフォルトでは、箱ひげは箱の端から、y の値が四分位範囲の 1.5 倍の中に
 収まっていて最も離れているような点まで延長されます。デフォルトでは、範
 囲外の点 (outlier) は円 (pointtype 7) で描かれます。箱ひげの端の棒の幅
 は `set bars` を使って制御できます。

 これらのデフォルトの性質は `set style boxplot` コマンドで変更できます。
 以下参照: `set style boxplot`, `bars`, `boxwidth`, `fillstyle`,
 `candlesticks`。

2 boxxyerrorbars
?plotting styles boxxyerrorbars
?style boxxyerrorbars
?boxxyerrorbars
Ffigure_boxxyerrorbars
 `boxxyerrorbars` スタイルは 2 次元のデータ描画でのみ利用可能です。これ
 は、`xyerrorbars` スタイルが単に線分の交差で表現するところを長方形で表
 現することを除けば、ほぼ同じです。これは、入力データの 4 列、または 6
 列を使用します。余分な入力列は、variable 行や塗り潰し色の情報が提供さ
 れたものとして使用されます (以下参照: `rgbcolor variable`)。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  xlow  xhigh  ylow  yhigh

 箱の幅と高さは `xyerrorbars` スタイル同様 x, y の誤差から決定されます
 つまり、xlow から xhigh までと ylow から yhigh まで、または x-xdelta
 から x+xdelta までと y-ydelta から y+ydelta まで。これらは何列のデータ
 が与えられているかによって決まります。

 入力列を追加 (5,7 列目) すると、それらは各データ点毎の variable color
 情報 (以下参照: `linecolor`, `rgbcolor variable`) であるとして使われま
 す。

 箱の内部は現在の塗りつぶしスタイル (fillstyle) に従って塗られます。詳
 細は、以下参照: `set style fill`, `boxes`。plot コマンド上で新しい塗り
 つぶしスタイルを指定することもできます。
2 candlesticks
?plotting styles candlesticks
?style candlesticks
?candlesticks
Ffigure_candlesticks
 `candlesticks` スタイルは、金融データの 2 次元のデータ描画、および統計
 データのひげ付きの棒グラフを生成するのに使えます。
 記号は、水平方向には x を中心とし、垂直方向には開始値 (open) と終値
 (close) を境界とする長方形が使われます。そして、その x 座標のところに
 長方形のてっぺんから最高値 (high) までと、長方形の底から最安値 (low)
 までの垂直線が引かれますが、この垂直線は最高値と最安値が入れ替わっても
 変更されません。

 基本的に 5 列のデータが必要です:

       金融データ:   date  open  low  high  close
       箱ひげ描画:   x  box_min  whisker_min  whisker_high  box_high

 長方形の幅はコマンド `set boxwidth` で制御できますが、以前の gnuplot
 への後方互換性として、boxwidth パラメータが設定されていない場合は
 `set bars <width>` で制御されるようになっています。

 これの代わりに、箱ひげ (box-and-whisker) のグループ化に関する明示的な
 幅の指定を、追加の 6 番目のデータで指定できます。その幅は、x 座標と同
 じ単位で与えなければいけません。

 入力列を追加 (6 列目、または 6 列目がデータの幅として使れる場合は 7 列
 目) すると、それらは各データ点毎の variable color 情報 (以下参照:
 `linecolor`, `rgbcolor variable`) として使われます。

 デフォルトでは、鉛直線分のてっぺんと底には垂直に交わる水平線は引かれま
 せん。それを引きたい場合、例えば典型的な例は箱ひげ図 (box-and-whisker
 plot) での使用ですが、描画コマンドにキーワード `whiskerbars` を追加し
 てください。デフォルトでは、水平線は箱 (candlestick) の水平幅一杯に引
 かれますが、それは全体の幅に対する割合を指定することで変更できます。

 金融データの通常の慣習では、(開始値) < (終値) の場合は長方形は空で、
 (終値) < (開始値) の場合は塗り潰されます。現在の fillstyle に "empty"
 をセットしている場合は、実際にこうなります。以下参照: `fillstyle`。
 fillstyle に塗り潰し、またはパターンをセットしている場合は、開始値、終
 値に関係なく、すべての箱にそれが使われます。以下参照: `set bars`,
 `financebars`。また、以下も参照してください。
^ <a href="http://www.gnuplot.info/demo/candlesticks.html">
 candlestick
^ </a>
 と
^ <a href="http://www.gnuplot.info/demo/finance.html">
 finance
^ </a>
 のデモ。

 注意: 中央値を表すための記号などを追加したい場合、以下の例のように、ひ
 げ付きの棒グラフに他の描画コマンドを追加する必要があります:

   # データ列:  X '最小値' '1/4 位の値' '中央値' '3/4 位の値' '最大値'
   set bars 4.0
   set style fill empty
   plot 'stat.dat' using 1:3:2:6:5 with candlesticks title 'Quartiles', \
        ''         using 1:4:4:4:4 with candlesticks lt -1 notitle

   # ひげの上に水平線を伴う描画で、水平線の幅を全体幅の 50% にする
   plot 'stat.dat' using 1:3:2:6:5 with candlesticks whiskerbars 0.5

 以下参照: `set boxwidth`, `set bars`, `set style fill`, `boxplot`。
2 circles
?plotting styles circles
?style circles
?circles
Ffigure_circles
 スタイル `circles` は、各データ点に明示された半径の円を描画します。3
 列のデータを与えた場合は、それを x, y, 半径と解釈します。半径は、常に
 描画の水平軸 (x または x2) の単位で解釈されます。y 方向の縮尺と描画の
 アスペクト比は、いずれも無視されます。2 列のデータしか与えないと、半径
 は `set style circle` から取ります。この場合、半径は graph か screen
 の座標系で与えることができます。

 デフォルトでは完全な円を描画しますが、4 列目、5 列目に開始角、終了角を
 指定することで扇形を描画することもできます。4 列目、あるいは 6 列目の
 データを追加して部分円の色を指定することもできます。扇形の開始角、終了
 角の単位は度で指定する必要があります。以下参照: `set style circle`,
 `set style fill`。

 例:

     # 面積が 3 列目の値に比例するような円を描画
     set style fill transparent solid 0.2 noborder
     plot 'data' using 1:2:(sqrt($3)) with circles, \
          'data' using 1:2 with linespoints

     # 円の代わりにパックマンを描画
     plot 'data' using 1:2:(10):(40):(320) with circles

     # インランデータで円グラフを描画
     set xrange [-15:15]
     set style fill transparent solid 0.9 noborder
     plot '-' using 1:2:3:4:5:6 with circles lc var
     0    0    5    0    30    1
     0    0    5   30    70    2
     0    0    5   70   120    3
     0    0    5  120   230    4
     0    0    5  230   360    5
     e

 これは、pointstyle 7 で点のサイズを variable とした `points` による描
 画と似ていますが、circles は x 軸の範囲で伸縮される点が異なります。以
 下も参照: `set object circle`, `fillstyle`。
2 ellipses
?plotting styles ellipses
?style ellipses
?ellipses
Ffigure_ellipses
 スタイル `ellipses` は、各データ点に楕円 (ellipse) を描画します。この
 スタイルは、2 次元描画にのみ適用されます。各楕円は、中心、主軸直径、副
 軸直径、x 軸と主軸のなす角、で表現されます。

      2 列: x y
      3 列: x y major_diam
      4 列: x y major_diam minor_diam
      5 列: x y major_diam minor_diam angle

 2 列のデータのみが与えられた場合は、それらは中心の座標とみなされ、楕円
 はデフォルトの大きさで描画されます (以下参照: `set style ellipse`)。楕
 円の向きは、主軸と x 軸のなす角で定義されますが、それもデフォルトの
 ellipse のスタイルから取られます (以下参照: `set style ellipse`)。
 3 列のデータが与えられた場合は、3 列目は主、副両軸の直径 (幅) として使
 われます。向きはデフォルトで 0 になります。
 4 列のデータが与えられた場合は、それらは中心の座標、主軸直径 (幅)、副
 軸直径として使わわれます。これらは直径であり、半径でないことに注意して
 ください。
 5 列のデータが与えられた場合は、5 列目の値は度単位の向きの角度の指定と
 して使われます。
 楕円は、3,4,5 列の値は負の値として指定することで、それらのデフォルトの
 値を利用して楕円を書かせることもできます。

 上のすべての場合で、variable color データを最後の列 (3,4,5,6 列目) と
 して追加できます。詳細は以下参照: `colorspec`。

 デフォルトでは、主軸直径は水平軸 (x または x2) の単位、副軸直径は垂直
 軸 (y または y2) の単位であるとみなされます。これは、x 軸と y 軸の縮尺
 が異なる場合、主軸と副軸の比は回転後には正しくはならない、ということを
 意味しています。しかしこの挙動は、キーワード `units` で変更できます。

 これに関しては、3 種類の代用品があります:
 `units xy` が描画指定に含まれている場合、その軸は上に述べたように縮尺
 されます。`units xx` とすると、直径は両軸とも x 軸の単位で計算され、
 `units yy` は両軸とも y 軸の単位で計算されます。後の 2 つは、描画のサ
 イズを変更しても、楕円は正しいアスペクト比を持ちます。

 `units` を省略した場合は、デフォルトの設定が使用され、`units xy` とな
 りますが、これは、`set style ellipse` で再定義可能です。

 例 (楕円を有効な線種を周期的に使用して描画):

     plot 'data' using 1:2:3:4:(0):0 with ellipses

 以下も参照: `set object ellipse`, `set style ellipse`, `fillstyle`。
2 dots
?plotting styles dots
?style dots
?dots
Ffigure_dots
 `dots` スタイルは各点に小さなドットを描画します。これはたくさんの点か
 らなる散布図の描画に便利でしょう。2 次元描画では 1 列、または 2 列の入
 力データが、3 次元描画では 3 列のデータが必要です。

 出力形式によっては (post, pdf など)、ドットの大きさは linewidth を変更
 することで制御できることもあります。

      1 列:  y         # x は行番号
      2 列:  x  y
      3 列:  x  y  z   # 3D のみ (splot)

2 filledcurves
?plotting styles filledcurves
?style filledcurves
?filledcurves
Ffigure_filledcurves
 スタイル `filledcurves` は 2 次元描画でのみ利用可能です。これは 3 種類
 の異なる指定が可能です。最初の 2 種類は関数描画、あるいは 2 列の入力デ
 ータ用のもので、後で紹介するようにオプションで更なる指定ができます。

 書式:

     plot ... with filledcurves [option]

 ここで、オプションは以下のうちのいずれかです:

     [closed | {above | below}
     {x1 | x2 | y1 | y2 | r}[=<a>] | xy=<x>,<y>]

 最初のものは `closed` で、これは曲線それ自身を閉多角形と見なします。入
 力データが 2 列の場合にはこれがデフォルトです。

 2 種類目は指定された軸、あるいは水平線、垂直線、与えられた点などと、曲
 線との間に作られる領域を塗りつぶします。

     filledcurves closed   ... 丁度閉曲線で囲まれる領域
     filledcurves x1       ... x1 軸
     filledcurves x2       ... x2 軸 (y1, y2 軸も同様)
     filledcurves y1=0     ... (y1 軸での) 直線 y=0 i.e. x1 軸と平行
     filledcurves y2=42    ... (y2 軸での) 直線 y=42 i.e. x2 軸と平行
     filledcurves xy=10,20 ... x1,y1 軸での点 10,20 (扇型のような形状)
     filledcurves above r=1.5  極座標での動径軸の 1.5 の外側の領域

 3 種類目は 3 列の入力データを必要とし、それらは x 座標と、それに対する
 2 つの y 座標からなり、それらは同じ x 座標の集合に対する 2 つの曲線の
 y 座標に対応します。そしてその 2 つの曲線の間の領域が塗りつぶされます。
 入力データが 3 列以上の場合にはこれがデフォルトです。

      3 列:  x  y1  y2

 入力された 2 つの曲線の間の領域の塗りつぶしの例:
^ <a href="http://www.gnuplot.info/demo/fillbetween.html">
 曲線間の塗りつぶしデモ。
^ </a>

     plot 'data' using 1:2:3 with filledcurves

 `above` と `below` オプションは
     ... filledcurves above {x1|x2|y1|y2|r}=<val>
 および
     ... using 1:2:3 with filledcurves below
 の形のコマンドに適用可能です。どちらの場合でも、これらのオプションは
 塗りつぶし領域を、境界線、または境界曲線の片側に制限します。

 注意: この描画モードは全ての出力形式でサポートされるとは限りません。

 データファイルから描かれた曲線の塗りつぶしを拡大すると、何もなくなった
 り正しくない領域になることがありますが、それは gnuplot が、領域ではな
 く点や線をクリッピングしているからです。

 <a>, <x>, <y> が描画領域の外にある場合、それらはグラフの境界へ移動され
 ます。よって、オプション xy=<x>,<y> を指定した場合の実際の塗りつぶし領
 域は、xrange や yrange に依存します。
2 financebars
?plotting styles financebars
?style financebars
?financebars
 `financebars` スタイルは金融データの 2 次元のデータ描画でのみ利用可能
 です。これは、x 座標 1 つ (通常日付) と、4 つの y 座標 (金額) を必要と
 します。

      5 列:   date  open  low  high  close

 入力列を追加 (6 列目) すると、それらは各行毎の variable color 情報 (以
 下参照: `linecolor`, `rgbcolor variable`) として使われます。

Ffigure_financebars
 記号は、水平方向にはその x 座標に置かれ、垂直方向には最高値 (high) と
 最安値 (low) を端とする線分が使われます。そして、その線分に水平左側の
 刻みが開始値 (open) の所に、水平右側の刻みが終り値 (close) の所につき
 ます。その刻みの長さは `set bars` で変更できます。記号は最高値と最安値
 が入れ替わっても変わりません。以下参照: `set bars`, `candlesticks`。以
 下も参照してください。
^ <a href="http://www.gnuplot.info/demo/finance.html">
 金融データデモ。
^ </a>
2 fsteps
?plotting styles fsteps
?style fsteps
?fsteps
Ffigure_fsteps
 `fsteps` スタイルは 2 次元描画でのみ利用可能です。これは 2 本の線分で
 隣り合う点をつなぎます: 1 本目は (x1,y1) から (x1,y2) まで、2 本目は
 (x1,y2) から (x2,y2) まで。入力列の条件は、`lines` や `points` に対す
 るものと同じです。`fsteps` と `steps` の違いは、`fsteps` は、折れ線を
 先に y 方向に書いてから次に x 方向に書くのに対し、`steps` は先に x 方
 向に書いてから次に y 方向に書きます。

 以下も参照
^ <a href="http://www.gnuplot.info/demo/steps.html">
 steps デモ。
^ </a>
2 fillsteps
?style fillsteps
?fillsteps
 `fillsteps` スタイルは、`steps` とほぼ同じですが、曲線と y=0 との間の
 領域を現在の fillstyle で塗り潰します。以下参照: `steps`。
2 histeps
?plotting styles histeps
?style histeps
?histeps
Ffigure_histeps
 `histeps` スタイルは 2 次元描画でのみ利用可能です。これはヒストグラム
 の描画での利用を意図しています。y の値は、x の値を中心に置くと考え、
 x1 での点は ((x0+x1)/2,y1) から ((x1+x2)/2,y1) までの水平線として表現
 されます。端の点では、その線はその x 座標が中心になるように延長されま
 す。隣り合う点同士の水平線の端は、その両者の平均値のところでの鉛直線、
 すなわち ((x1+x2)/2,y1) から ((x1+x2)/2,y2) の線分で結ばれます。
 入力列の条件は、`lines` や `points` に対するものと同じです。

 `autoscale` が有効である場合、x の範囲は、その延長された水平線の範囲で
 はなく、データ点の範囲が選択されます。よって、端の点に関してはその水平
 線は半分しか描かれないことになります。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/steps.html">
 steps デモ。
^ </a>

2 histograms
?style histograms
?set style histogram
?plotting styles histograms
?histograms
 スタイル `histograms` は 2 次元描画でのみ有効です。これは、データの各
 列の並びから平行な棒グラフを作ります。`plot` コマンドの各要素は、それ
 に関する目盛りの値や凡例 (key) のタイトルが付属するかも知れませんが、
 単一の入力データを指定する必要があります (例えば入力ファイルの 1 つの
 列)。現在は、4 種類のヒストグラム形式のスタイルをサポートしています。

       set style histogram clustered {gap <gapsize>}
       set style histogram errorbars {gap <gapsize>} {<linewidth>}
       set style histogram rowstacked
       set style histogram columnstacked
       set style histogram {title font "name,size" tc <colorspec>}

 デフォルトのスタイルは `set style histogram clustered gap 2` に対応し
 ています。このスタイルでは、並列に指定されたデータの値の集合は、選択さ
 れたデータ列のそのそれぞれの序列 (行番号) に対応する x 座標の場所に、
 各々箱のグループとして固められて置かれます。よって、<n> 個のデータ列を
 並列に指定した場合、最初の固まりは x=1 を中心とする <n> 個の箱の固まり
 からなり、その各々の高さは、その <n> データ列各々の最初 (1 行目) の値
 が取られます。その後に少し空白 (gap) が空けられ、次に各データ列の次 (2
 行目) の値に対応する箱の固まりが x=2 を中心として置かれます。以下同様
 です。デフォルトの空白 (gap) 幅の 2 は、箱の固まり同士の間の空白が、箱
 2 つの幅に等しいことを意味します。同じ列に対する箱は全て同じ色または同
 じパターンで与えられます (以下参照: `set style fill`)。

 箱の固まりそれぞれは、データファイルの 1 つの行から得られます。そのよ
 うな入力ファイルの各行の最初の項目が見出し (ラベル) でることは良くある
 ことです。その列にある見出し (ラベル) は、`using` に `xticlabels` オプ
 ションをつけることで、それに対応する箱の固まりの真下の x 軸に沿ったと
 ころに置くことができます。

 `errorbars` スタイル は、各エントリに対して追加の入力列を必要とする以
 外は `clustered` スタイルにとても良く似ています。最初の列は、
 `clustered` スタイルの場合と全く同様に箱の高さ (y の値) として保持され
 ます。
      2 列:       y yerr          # 線は y-yerr から y+err へ伸びる
      3 列:       y ymin ymax     # 線は ymin から ymax へ伸びる
 誤差線の見た目は、現在の `set bars` の値と <linewidth> オプション指定
 で制御できます。

 積み上げ型のヒストグラムも 2 つの形式がサポートされています。それらは
 コマンド `set style histogram {rowstacked|columnstacked}` で選択できま
 す。これらのスタイルにおいて、選択された列のデータの値は積み上げられた
 箱として集められます。正の値は、y=0 から上の方へ積み上げられ、負の値は
 下へ向かって積み上げられます。正の値と負の値が混じってい場合は、上向き
 と下向きの両方の積み上げが生成されます。デフォルトの積み上げモードは
 `rowstacked` です。

 スタイル `rowstacked` は、まず最初に選択された列の各行の値を x 軸のそ
 れぞれの位置に配置します: 1 行目の値は x=1 の箱、2 行目のは x=2、以下
 同様となります。2 番目以降に選択された列に対応する箱は、それらの上に積
 み重ねられて行きます。そして結果として、x=1 にできる箱の積み重ねは、各
 列の最初の値 (1 行目の値) からなり、x=2 の箱の積み重ねは各列の 2 行目
 の値、などのようになります。同じ列に対する箱は全て同じ色または同じパタ
 ーンで与えられます (以下参照: `set style fill`)。

 スタイル `columnstacked` も同様ですが、こちらは各箱の積み上げは (各行
 のデータからではなく) 各列のデータからなります。最初に指定された列の各
 行のデータが x=1 の箱の積み上げを生成し、2 番目に指定した列の各行のデ
 ータが x=2 の箱の積み上げ、などのようになります。このスタイルでは、各
 箱の色は、各データ項目の (列番号ではなく) 行番号から決定されます。

 箱の幅はコマンド `set boxwidth` で変更できます。
 箱の塗りつぶしスタイルはコマンド `set style fill` で設定できます。

 histograms は x 軸は常に x1 軸を使いますが、y 軸に関しては y1 軸か y2
 軸かを選択できます。plot 命令が、histograms と他のスタイルの描画の両方
 を含む場合、histogram でない方は、x1 軸を使うか x2 軸を使うかを選択で
 きます。

 例:
Ffigure_histclust
 入力ファイルは、2, 4, 6, ... の列にデータ値を持ち、3, 5, 7, ...  の列
 に誤差評価を持つとします。以下の例は、2 列目、4 列目の値を箱の固まり型
 (clustered; デフォルトスタイル) のヒストグラムとして描画します。ここで
 は、plot コマンドで繰り返し (iteration) を使用していますので、任意の個
 数のデータ列を一つのコマンドで処理できます。以下参照: `plot for`。

       set boxwidth 0.9 relative
       set style data histograms
       set style histogram cluster
       set style fill solid 1.0 border lt -1
       plot for [COL=2:4:2] 'file.dat' using COL

 これは、x 軸上の各整数値を中心とするそれぞれ 2 つの箱 (鉛直な棒) 毎の
 固まりによる描画を生成します。入力ファイルの最初の列にラベルが含まれて
 いるならそれを、以下の少し変更したコマンドで x 軸に沿って配置できます。

       plot for [COL=2:4:2] 'file.dat' using COL:xticlabels(1)

Ffigure_histerrorbar
 ファイルが、各データの測定値と範囲の情報の両方を含んでいる場合、描画に
 誤差線を追加することができます。以下のコマンドは誤差線を (y-<error>)
 から (y+<error>) に引き、その頭に箱と同じ幅の水平線をつけます。誤差線
 と誤差線の端の線は、黒で線幅 2 で描画されます。

       set bars fullwidth
       set style fill solid 1 border lt -1
       set style histogram errorbars gap 2 lw 2
       plot for [COL=2:4:2] 'file.dat' using COL:COL+1

 以下は、同じデータを行毎の積み上げ型 (rowstacked) のヒストグラムで描画
 する方法を示しています。これまでとは違い、以下の例では繰り返しを使うの
 でなく、明示的に別々の列を指定します。

       set style histogram rowstacked
       plot 'file.dat' using 2, '' using 4:xtic(1)

Ffigure_histrows
 これは、一つ一つの鉛直な棒が、データの一つの列に対応する描画を生成しま
 す。各棒は、2 つの部分の積み上げの形であり、それぞれの部分の高さが、デ
 ータファイルの 2 列目と 4 列目の値に対応します。


 最後に以下のコマンド

       set style histogram columnstacked
       plot 'file.dat' using 2, '' using 4

Ffigure_histcols
 は、一つ一つがそれぞれデータ列に対応する、2 つの鉛直な積み重ねの棒を生
 成します。x=1 にある棒は、データファイルの 2 列目の各行の値に対応する
 箱からなります。x=2 にある棒は、データファイルの 4 列目の各行の値に対
 応する箱からなります。

 これは、gnuplot の通常の入力の縦、横の解釈を入れ換えることになりますの
 で、凡例のタイトルや x 軸の目盛りの見出しの指定も変更する必要がありま
 す。以下のコメント部分を参照してください。

       set style histogram columnstacked
       plot '' u 5:key(1)            # 1 列目を凡例タイトルに使用
       plot '' u 5 title columnhead  #

 この 2 つの例は、全く同じデータ値を与えているのですが、異なる書式であ
 ることに注意してください。
3 newhistogram
?newhistogram
?histograms newhistogram
?plotting style histograms newhistogram
 書式:

      newhistogram {"<title>" {font "name,size"} {tc <colorspec>}}
                   {lt <linetype>} {fs <fillstyle>} {at <x-coord>}

 一回の描画に 2 つ以上のヒストグラムの組を作ることもできます。この場合
 コマンド `newhistogram` を使うことで、それらを強制的に分離し、またそれ
 ぞれのラベルを分離することができます。
 例:

       set style histogram  cluster
       plot newhistogram "Set A", 'a' using 1, '' using 2, '' using 3, \
            newhistogram "Set B", 'b' using 1, '' using 2, '' using 3

 ラベル "Set A" と "Set B" は、それぞれのヒストグラムの組の下、x 軸の全
 てのラベルの下の位置に現われます。

 コマンド newhistogram は、ヒストグラムの色付けを強制的に指定した色
 (linetype) で始めるのにも使えます。デフォルトでは、色の番号はヒストグ
 ラムの境界をまたいでさえも連続的に増加し続けます。次の例は、複数のヒス
 トグラムに同じ色付けを施します。
       plot newhistogram "Set A" lt 4, 'a' using 1, '' using 2, '' using 3, \
            newhistogram "Set B" lt 4, 'b' using 1, '' using 2, '' using 3

 同様に、次のヒストグラムを指定した fillstyle で始めさせることが可能で
 す。その fillstyle を `pattern` にセットした場合、塗り潰しに使用される
 パターン番号は自動的に増加されていきます。

Ffigure_newhist
 オプション `at <x-coord>` は、その後のヒストグラムの x 座標の位置を
 <x-coord> に設定します。例:

        set style histogram cluster
        set style data histogram
        set style fill solid 1.0 border -1
        set xtic 1 offset character 0,0.3
        plot newhistogram "Set A", \
             'file.dat' u 1 t 1, '' u 2 t 2, \
             newhistogram "Set B" at 8, \
             'file.dat' u 2 t 2, '' u 2 t 2

 この場合、2 つ目のヒストグラムの位置は x=8 から始まります。
3 複数の列に渡る自動的な繰り返し (automated)
?automated
?histograms automated
?styles histograms automated
?plotting styles histograms automated
 一つのデータファイルのたくさんの列から、一つのヒストグラムを生成したい
 場合、plot の繰り返し (iteration) 機能を使うと便利でしょう。以下参照:
 `plot for`。例えば、3 列目から 8 列目までのデータを積み上げた形のヒス
 トグラムを生成する例:

       set style histogram columnstacked
       plot for [i=3:8] "datafile" using i title columnhead
2 image
?plotting styles image
?style image
?image
?rgbimage
?rgbalpha
 描画スタイル `image`, `rgbimage`, `rgbalpha` は、いずれも一様に標本点
 を取った格子状データ値を、2 次元、または 3 次元中のある平面上に射影し
 ます。入力データは、既にあるビッマップ画像ファイル (PNG のような標準的
 なフォーマットから変換したものでよい) か、単純な数値配列です。

=heatmap
Ffigure_heatmap
 この図は、スカラー値の配列から温度分布を生成した例です (訳注: 図が表示
 されている場合)。現在のパレットを、各スカラー値から対応するピクセルの
 色への割り当てに使用します。
       plot '-' matrix with image
       5 4 3 1 0
       2 2 0 0 1
       0 0 0 1 0
       0 1 2 4 3
       e
       e

Ffigure_rgb3D
 入力 2 次元画像の各ピクセル (データ点) は、描画グラフ中では長方形、ま
 たは平行六面体となります。画像の各データ点の座標は、平行六面体の中心を
 決定します。すなわち、M x N 個のデータ集合は M x N ピクセルの画像を生
 成します。これは、M x N 個のデータ集合が (M-1) x (N-1) 要素を作成する
 pm3d の構造とは異なります。バイナリ画像データの格子の走査方向は、追加
 キーワードでさらに制御可能です。以下参照: `binary keywords flipx`,
 `keywords center`, `keywords rotate`。

Ffigure_scaled_image
 各ピクセルの x と y の大きさを示すことで、画像データを 2 次元描画座標
 系内の特定の長方形に収まるように伸縮することができます。以下参照:
 `binary keywords dx`, `dy`。右の画像を生成するのには、同じ入力画像を、
 それぞれ dx, dy, origin を指定して複数回配置しました。入力 PNG 画像で
 あるビルの絵は 50x128 ピクセルです。高いビルは、`dx=0.5 dy=1.5` で割り
 当てて描画し、低いビルは、`dx=0.5 dy=0.35` としています (訳注: 図が表
 示されている場合)。

 スタイル `image` は、グレイスケール (灰色階調)、またはカラーパレット値
 を含んでいるピクセルの入力を処理します。よって 2 次元描画 (`plot` コマ
 ンド) では 3 列のデータ (x,y,value) を、3 次元描画 (`splot` コマンド)
 では 4 列のデータ (x,y,z,value) が必要になります。

 スタイル `rgbimage` は、赤、緑、青の 3 つの色成分 (RGB) で記述されたピ
 クセルの入力を処理します。よって `plot` では 5 次元データ (x,y,r,g,b)
 が、`splot` では 6 次元データ (x,y,z,r,g,b) が必要になります。赤、緑、
 青の各成分は [0:255] の範囲内にあると仮定されます。

 スタイル `rgbalpha` は、赤、緑、青の RGB 成分に加えて、アルファ値 (透
 過パラメータ) の情報も含んだピクセルの入力を処理します。よって、`plot`
 では 6 次元データ (x,y,r,g,b,a) が、`splot` では 7 次元データ
 (x,y,z,r,g,b,a) が必要になります。赤、緑、青、およびアルファの各成分は
 [0:255] の範囲内にあると仮定されます。
3 透明化 (transparency)
?image transparency
?transparency
?alpha channel
 描画スタイル `rgbalpha` は、入力データの各ピクセルが [0:255] の範囲内
 のアルファ値を持っている必要があります。alpha = 0 のピクセルは完全な透
 明で、その下 (奥) の描画要素を全く変えません。alpha = 255 のピクセルは
 完全な不透明です。すべての出力形式は、これら 2 つの両極端な値をサポー
 トします。0 < alpha < 255 のピクセルは半透明で、これは 2,3 の出力形式
 しか完全には対応しておらず、他の出力形式ではこれを 0 か 255 として扱う
 ことによる近似しか行いません。
3 image pixels
?plotting styles image pixels
?style image pixels
?image pixels
?pixels
?plotting styles image failsafe
?style image failsafe
?image failsafe
?failsafe
 出力形式によっては、2 次元の長方形領域内での画像データ描画の、デバイス
 やライブラリに依存した最適化ルーチンを使用しています。これは、例えばク
 リッピングや伸縮がうまくなかったり、縁が欠けるなど、望ましくない出力を
 生成することがあります。キーワード `pixels` は、そのようなルーチンの代
 わりに、画像を 1 ピクセルずつ描画するような一般的なコードを使用するよ
 う gnuplot に指示します。この描画モードでは、描画は遅く、とても大きな
 出力ファイルを生成しますが、どの出力形式でも共通的な見た目を作成してく
 れるでしょう (オプション `pixels` は、以前の gnuplot では `failsafe`
 と呼ばれていました)。
 例:
       plot 'data' with image pixels
2 impulses
?plotting styles impulses
?style impulses
?impulses
Ffigure_impulses
 `impulses` スタイルは、2 次元描画では y=0 から各点の y の値への、3 次
 元描画では z=0 から各点の z の値への、垂直な線分を表示します。y や z
 の値は負の値でもよいことに注意してください。データの追加列を各垂直線分
 の色の制御に利用できます。このスタイルを 3 次元描画で使用する場合、太
 い線 (linewidth > 1) を利用するとより効果的でしょう。それは 3 次元の棒
 グラフに似たものになります。

      1 列:  y
      2 列:  x  y     # [x,0] から [x,y] への線 (2D)
      3 列:  x  y  z  # [x,y,0] から [x,y,z] への線 (3D)

2 labels
?plotting styles labels
?style labels
?labels
Ffigure_labels1
 スタイル `labels` は、データファイルから座標と文字列を読み込み、その文
 字列をその 2 次元、または 3 次元座標に置きます。これは基本的に 3 列、
 または 4 列の入力を必要とします。余分な入力列は、フォントサイズか文字
 色の変数値のような情報が提供されたものとして使用されます (以下参照:
 `rgbcolor variable`)。

      3 列:  x  y  string    # 2 次元版
      4 列:  x  y  z  string # 3 次元版

 フォント、色、回転角やその他の描画テキストの属性は追加オプションとして
 指定可能です (以下参照: `set label`)。次の例は、入力ファイルの 1 列目
 から取った市の名前から作られる文字列を、4, 5 列目から取った地図座標に
 描画します。フォントサイズは、3 列目の値から計算していて、この場合はそ
 れは人口を意味しています。

   CityName(String,Size) = sprintf("{/=%d %s}", Scale(Size), String)
   plot 'cities.dat' using 5:4:(CityName(stringcolumn(1),$3)) with labels

 フォントサイズを、個々の市の名前に対して異なるサイズに合わせなくていい
 ならば、コマンドはもっと簡単です:

   plot 'cities.dat' using 5:4:1 with labels font "Times,8"

 labels に `hypertext` がついている場合、その文字列はマウスがそれに対応
 する点の上に来たときにだけ現われます。以下参照: `hypertext`。この場合
 ハイパーテキストの置き場所として機能する点を作るためにそのラベルの
 `point` 属性を有効にする必要があります:

   plot 'cities.dat' using 5:4:1 with labels hypertext point pt 7

Ffigure_labels2
 スタイル `points` であらかじめ定義されている点の記号が適切でない、ある
 いは十分でない場合、その代わりとしてスタイル `labels` を使うこともでき
 ます。例えば、以下は単一文字として選択される組を定義し、3 列目のデータ
 値に対応するその一つをグラフの各点に割り当てる例です (訳注: 以下のサン
 プルの <UTF-8 文字列> の部分には、元々、丸に中点記号や□、＋、トランプ
 記号などの UTF-8 文字列が並んでいますが、この日本語訳とは両立しないた
 め取り除いています):

   set encoding utf8
   symbol(z) = "<UTF-8 文字列>"[int(z):int(z)]
   splot 'file' using 1:2:(symbol($3)) with labels

 以下も参照: `datastrings`, `set style data`。
2 lines
?plotting styles lines
?style lines
?lines
Ffigure_lines
 `lines` スタイルは隣接する点を真直な線分で結びます。
 これは、2 次元描画でも、3 次元描画でも使用でき、基本的には、1 列か 2
 列か 3 列かの入力データを必要とします。
 余分な入力列は、線の色の変更などの情報が提供されたものとして使用されま
 す (以下参照: `rgbcolor variable`)。

 2 次元の場合
      1 列:  y       # 行番号による暗黙の x
      2 列:  x  y
 3 次元の場合
      1 列:  z       # x は暗黙の行番号、y は index から
      3 列:  x  y  z

 以下も参照: `linetype`, `linewidth`, `linestyle`。
2 linespoints
?plotting styles linespoints
?style linespoints
?style lp
?linespoints
?lp
?pointinterval
Ffigure_linespoints
 `linespoints` スタイル (省略形 `lp`) は、隣接する点を真っ直ぐな線分で
 結び、その後で最初に戻って各点に小さな記号を描きます。点記号は、
 `set pointsize` で決まるデフォルトの大きさで描きますが、plot コマンド
 上で点のサイズを指定したり、あるいは入力データの追加列で個別の点サイズ
 を指定することもできます。追加の入力列は、個別の線の色などの情報を提供
 するのにも使われます。以下参照: `lines`, `points`。

 線種 (linetype) の属性である `pointinterval` (省略形 `pi`) で、グラフ
 のすべての点を与えた記号にするかどうかを制御できます。例えば、
 `with lp pi 3` は、すべてのデータ点間に線分を引きますが、点の記号は 3
 つおきにしか書きません。`pointinterval` を負の値にした場合は、記号の下
 の線分の部分を消します。消す部分のサイズは `set pointintervalbox` で制
 御できます。

2 parallelaxes
?plotting style parallelaxes
?style parallelaxes
?parallelaxes
Ffigure_parallel
 平行座標描画 (parallel axis plot, parallel coordinates plot とも呼ばれ
 る) は、多次元データの相関を視覚化します。各入力列は、別々のスケールの
 縦軸に割り当てられます。入力 1 行から読み込んだそれぞれの列の値は、1
 つ目の軸から 2 つ目の軸へ、2 つ目の軸から 3 つ目の軸へと線分で結ばれま
 す。すなわち平行座標描画中では、入力の各行がそれぞれ独立した折れ線にな
 ります。それらを数種類に分類して色を割り当てることはよく行われますが、
 それは、その分類と軸との間の関係を視覚的に調査することを可能にします。
 デフォルトでは、gnuplot は自動的に個々の軸の範囲、スケールを入力データ
 から決定しますが、通常の `set axis range` コマンドによってそれをカスタ
 マイズすることも可能です。以下参照: `set paxis`。
2 points
?plotting styles points
?style points
?points
Ffigure_points
 `points` スタイルは各点に小さな記号を表示します。その記号のデフォルト
 の大きさを変更するにはコマンド `set pointsize` が使えます。
 基本的に 2 次元描画では 1 列、または 2 列の入力データが必要で、3 次元
 描画では 1 列、または 3 列のデータが必要です。以下参照: `style lines`。
 余分な入力列は、点のサイズや点色の変更などの情報が提供されたものとして
 使用されます。

 最初の 8 つの点種は、すべての出力形式で共通ですが、より多くの点種を個
 別にサポートする出力形式もあります。現在の出力形式がどのような点種を持
 っているかを見るには、コマンド `test` を使用してください。また、以下の
 例のようにして、任意の印字可能文字を点種の代わりに使用することもできま
 す。より長い文字列は、描画スタイル `points` ではなく `labels` を使えば
 出力できます。

2 polar
Ffigure_polar
 極座標描画 (polar) は、実際には描画スタイルの一つではありませんが、完
 全を期すためにこの一覧に上げておきます。オプション `set polar` は、入
 力する 2 次元座標を <x>,<y> の代わりに <角>,<半径> と解釈することを
 gnuplot に指示します。すべてではないが、多くの 2 次元描画スタイルが極
 座標モードでも機能します。図は、描画スタイル `lines` と `filledcurves`
 の組み合わせを示しています。(訳注: 図が表示されている場合) 以下参照:
 `set polar`, `set rrange`, `set size square`。

2 steps
?plotting styles steps
?style steps
?steps
Ffigure_steps
 `steps` スタイルは 2 次元描画でのみ利用可能です。これは 2 本の線分で隣
 り合う点をつなぎます: 1 本目は (x1,y1) から (x2,y1) まで、2 本目は
 (x2,y1) から (x2,y2) まで。入力列の条件は、`lines` や `points` に対す
 るものと同じです。`fsteps` と `steps` の違いは、`fsteps` は、折れ線を
 先に y 方向に書いてから次に x 方向に書くのに対し、`steps` は先に x 方
 向に書いてから次に y 方向に書きます。曲線とベースラインである y=0 との
 間の領域を塗り潰すには、`fillsteps` を使用してください。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/steps.html">
 steps デモ。
^ </a>

2 rgbalpha
?plotting styles rgbalpha
?style rgbalpha
 以下参照: `image`。
2 rgbimage
?plotting styles rgbimage
?style rgbimage
 以下参照: `image`。
2 vectors
?plotting styles vectors
?style vectors
?vectors
 2 次元の `vectors` スタイルは (x,y) から (x+xdelta,y+ydelta) までのベ
 クトルを書きます。3 次元の `vectors` スタイルも同様ですが、データは基
 本的に 6 列必要です。各ベクトルの先端には小さな矢先も書かれます。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  z  xdelta  ydelta  zdelta

 両方の場合で、入力列を追加 (2D では 5 列目、3D では 7 列目) すると、そ
 れらは各データ点毎の variable color 情報 (以下参照: `linecolor`,
 `rgbcolor variable`) として使われます。

 vectors スタイルを使っての splot は `set mapping cartesian` のみでサポ
 ートされています。

 キーワード "with vectors" は、その後ろに、インラインの arrow スタイル
 指定や、あらかじめ定義されている arrow スタイルの参照、あるいは列から
 各ベクトルに対する必要な arrow スタイルのインデックスを読むような指定
 を伴うことができます。注意: "arrowstyle variable" を使用する場合、対応
 するベクトルが描画される際にはそれが arrow の属性値すべてを埋めるので
 その plot コマンド内に他の線属性や arrow スタイル指定をこのキーワード
 と混在させることはできません。

      plot ... with vectors filled heads
      plot ... with vectors arrowstyle 3
      plot ... using 1:2:3:4:5 with vectors arrowstyle variable

 例:
       plot 'file.dat' using 1:2:3:4 with vectors head filled lt 2
       splot 'file.dat' using 1:2:3:(1):(1):(1) with vectors filled head lw 2

 `set clip one` と `set clip two` は 2 次元のベクトルの描画に影響を与え
 ます。以下参照: `set clip`, `arrowstyle`。
2 xerrorbars
?plotting styles xerrorbars
?style xerrorbars
?xerrorbars
Ffigure_xerrorbars
 `xerrorbars` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xerrorbars` は、水平の誤差指示線 (error bar) が表示される以外は
 `points` と同じです。各点 (x,y) において (xlow,y) から (xhigh,y) まで、
 または (x-xdelta,y) から (x+xdelta,y) までの線分が引かれますが、これら
 はいくつのデータ列が与えられるかによって変わります。誤差指示線の端には
 刻みの印が付けられます (`set bars` が使われていなければ。詳細に関して
 は、以下参照: `set bars`)。このスタイルは基本的に、3 列か 4 列のデータ
 が必要です:

      3 列:  x  y  xdelta
      4 列:  x  y  xlow  xhigh

 入力列を追加 (4,5 列目) すると、それらは点の variable color 情報として
 使われます。

2 xyerrorbars
?plotting styles xyerrorbars
?style xyerrorbars
?xyerrorbars
Ffigure_xyerrorbars
 `xyerrorbars` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xyerrorbars` は、水平、垂直の誤差指示線 (error bar) も表示される以外
 は `points` と同じです。各点 (x,y) において (x,y-ydelta) から
 (x,y+ydelta) までと (x-xdelta,y) から (x+xdelta,y) まで、または
 (x,ylow) から (x,yhigh) までと (xlow,y) から (xhigh,y) までの線分が引
 かれますが、これらはいくつのデータ列が与えられるかによって変わります。
 誤差指示線の端には刻みの印が付けられます (`set bars` が使われていなけ
 れば。詳細に関しては、以下参照: `set bars`)。これは 4 列か、6 列のデー
 タが必要です。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  xlow  xhigh  ylow  yhigh

 データが、サポートされていない混合型の形式で与えられた場合、`plot` コ
 マンドの `using` フィルタを使って適切な形に直さないといけません。例え
 ばデータが (x,y,xdelta,ylow,yhigh) という形式である場合、以下のように
 します:

       plot 'data' using 1:2:($1-$3):($1+$3):4:5 with xyerrorbars

 入力列を追加 (5,7 列目) すると、それらは各データ点毎の variable color
 情報として使われます。

2 yerrorbars
?plotting styles yerrorbars
?plotting styles errorbars
?style yerrorbars
?style errorbars
?yerrorbars
Ffigure_yerrorbars
 `yerrorbars` (または `errorbars`) スタイルは 2 次元のデータ描画のみで
 利用可能です。`yerrorbars` は、垂直の誤差指示線 (error bar) が表示され
 る以外は `points` に似ています。各点 (x,y) において (x,y-ydelta) から
 (x,y+ydelta) まで、または (x,ylow) から (x,yhigh) までの線分が引かれま
 すが、これらはいくつのデータ列が与えられるかによって変わります。誤差指
 示線の端には刻みの印が付けられます (`set bars` が使われていなければ。
 詳細に関しては、以下参照: `set bars`)。

      2 列:  [暗黙の x]  y  ydelta
      3 列:  x  y  ydelta
      4 列:  x  y  ylow  yhigh

 入力列を追加 (4,5 列目) すると、それらは点の variable color 情報として
 使われます。

 以下も参照
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 errorbar デモ。
^ </a>
2 xerrorlines
?plotting styles xerrorlines
?style xerrorlines
?xerrorlines
Ffigure_xerrorlines
 `xerrorlines` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xerrorlines` は `linespoints` に似ていますが、水平の誤差線が描かれる
 ことが違います。各点 (x,y) で、データ列の個数に応じて (xlow,y) から
 (xhigh,y) まで、または (x-xdelta,y) から (x+xdelta,y) までの線分が描か
 れ、そして刻みの印が誤差線の端に置かれます (`set bars` が使われていな
 い場合。詳細は、以下参照: `set bars`)。基本的には、3 列か 4 列のデータ
 が必要です:

      3 列:  x  y  xdelta
      4 列:  x  y  xlow  xhigh

 入力列を追加 (4,5 列目) すると、それらは点の variable color 情報として
 使われます。

2 xyerrorlines
?plotting styles xyerrorlines
?style xyerrorlines
?xyerrorlines
Ffigure_xyerrorlines
 `xyerrorlines` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xyerrorlines` は `linespoints` に似ていますが、水平と垂直の誤差線も描
 かれることが違います。各点 (x,y) で、データ列の個数に応じて、
 (x,y-ydelta) から (x,y+ydelta) までと (x-xdelta,y) から (x+xdelta,y)
 まで、あるいは (x,ylow) から (x,yhigh) までと (xlow,y) から (xhigh,y)
 までの線分が描かれ、そして刻みの印が誤差線の端に置かれます (`set bars`
 が使われていない場合。詳細は、以下参照: `set bars`)。これは、4 列か 6
 列の入力データが必要です。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  xlow  xhigh  ylow  yhigh

 データが、サポートされていない混合型の形式で与えられた場合、`plot` コ
 マンドの `using` フィルタを使って適切な形に直さないといけません。例え
 ばデータが (x,y,xdelta,ylow,yhigh) という形式である場合、以下のように
 します:

       plot 'data' using 1:2:($1-$3):($1+$3):4:5 with xyerrorlines

 入力列を追加 (5,7 列目) すると、それらは各データ点毎の variable color
 情報として使われます。

2 yerrorlines
?plotting styles yerrorlines
?plotting styles errorlines
?style yerrorlines
?style errorlines
?yerrorlines
Ffigure_yerrorlines
 `yerrorlines` (または `errorlines`) スタイルは 2 次元のデータ描画のみ
 で利用可能です。`yerrorlines` は `linespoints` に似ていますが、垂直の
 誤差線が描かれることが違います。各点 (x,y) で、データ列の個数に応じて
 (x,y-ydelta) から (x,y+ydelta) まで、または (x,ylow) から (x,yhigh)
 までの線分が描かれ、そして刻みの印が誤差線の端に置かれます (詳細は、以
 下参照: `set bars`)。
 これは、3 列か 4 列の入力が必要です。

      3 列:  x  y  ydelta
      4 列:  x  y  ylow  yhigh

 入力列を追加 (4,5 列目) すると、それらは点の variable color 情報として
 使われます。

 以下も参照。
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 エラーバーのデモ
^ </a>
2 3 次元 (曲面) 描画 (3D (surface) plots)
?3D (surface) plots
?plotting styles 3d (surface) plots
=3D
=surface
Ffigure_surface+contours
 曲面描画は、コマンド `plot` ではなくコマンド `splot` を使って生成しま
 す。スタイル `with lines` を使えば、曲面を格子線で生成できます。曲面の
 塗り潰しは、スタイル `with pm3d` で行うことができます。曲面は通常、そ
 れが 3 次元の曲面であるとはっきりわかるような視方向から表示されます。
 その場合、X, Y, Z 軸はすべて描画内に表示されます。3 次元的な錯覚は、隠
 線処理や、曲面要素の深さ整列により、より増幅されます。以下参照:
 `hidden3d`, および `set pm3d` のオプションである `depthorder`。
 コマンド `splot` は、定数の Z 値に対する等高線を計算し描画することもで
 きます。これらの等高線は、曲面それ自体の上に書くこともできますし、XY
 平面へ射影することもできます。以下参照: `set contour`。
Ffigure_mapcontours
3 2 次元射影 (set view map)
?2D projection (set view map)
?projection
 コマンド `splot` の特別な場合として、描画の Z 方向の射影による、Z 座標
 の 2 次元曲面への地図作成 (map) があります。以下参照: `set view map`。
 この描画モードは、等高線の描画や温度分布を生成するのに利用できます。こ
 の図は描画スタイル `lines` を一度、`labels` を一度描画した等高線を示し
 ています (訳注: 図が表示されている場合)。
1 コマンド (Commands)
?commands
 このセクションでは `gnuplot` が受け付けるコマンドをアルファベット順に
 並べています。このドキュメントを紙に印刷したものは全てのコマンドを含ん
 でいますが、対話型で参照できるドキュメントの方は完全ではない可能性があ
 ります。実際、この見出しの下に何のコマンドも表示されないシステムがあり
 ます。

 ほとんどの場合、コマンド名とそのオプションは、紛らわしくない範囲で省略
 することが可能です。すなわち、"`plot f(x) with lines`" の代わりに
 "`p f(x) w li`" とすることができます。

 書式の記述において、中カッコ ({}) は追加指定できる引数を意味し、
 縦棒 (|) は互いに排他的な引数を区切るものとします。
2 cd
?commands cd
?cd
 `cd` コマンドはカレントディレクトリを変更します。

 書式:
         cd '<ディレクトリ名>'

 ディレクトリ名は引用符に囲まれていなければなりません。

 例:
         cd 'subdir'
         cd '..'

 バックスラッシュ (\) は二重引用符内 (") では特別な意味を持ってしまうた
 めにエスケープする必要がありますので、Windows ユーザには単一引用符を使
 うことを勧めます。例えば、
         cd "c:\newdata"
 では失敗しますが、
         cd 'c:\newdata'
         cd "c:\\newdata"
 なら期待通りに動くでしょう。
2 call
?commands call
?call
 `call` コマンドは、読み込むファイル名の後ろに、9 つまでのパラメータを
 与えることができることを除けば `load` コマンドと等価です。

      call "inputfile" <param-1> <param-2> <param-3> ... <param-9>

 gnuplot の以前のバージョンでは、そのパラメータ文字列の内容を、特別な記
 号 $0, $1, ..., $9 をマクロのように置換することで表現していました。こ
 の仕組みは、現在は非推奨です (以下参照: `call old-style`)。

 現在の gnuplot は、文字列変数 ARG0, ARG1, ..., ARG9 と、整数変数 ARGC
 を提供します。`call` コマンドを実行すると、ARG0 には入力ファイル名が、
 ARGC にはパラメータ数が設定され、ARG1 から ARG9 にはコマンドラインに並
 べられたパラメータの値が読み込まれます。

 通常パラメータは文字列値として保存されるので、それをマクロ展開して参照
 することもできます (古い形式の書式の類似)。しかし、多くの場合、それらは
 他の変数と同様に利用する方がより自然でしょう。
3 例 (Example)
?call example
?commands call example
      以下を call すると:
          MYFILE = "script1.gp"
          FUNC = "sin(x)"
          call MYFILE FUNC 1.23 "This is a plot title"
      呼び出されたスクリプト内では以下のようになり:
          ARG0 は "script1.gp"
          ARG1 は文字列値 "sin(x)"
          ARG2 は文字列値 "1.23"
          ARG3 は文字列値 "This is a plot title"
          ARGC は 3
      そのスクリプト内では以下のようなものを実行できる:
          plot @ARG1 with lines title ARG3
          print ARG2 * 4.56, @ARG2 * 4.56
          print "This plot produced by script ", ARG0

 この例の ARG1 はマクロとして参照しなければいけませんが、ARG2 はマクロ
 参照でも (数値定数になる)、変数のままでも (文字列 "1.23" が実数値に自
 動的に変換された後の同じ数値になる) 構わないことに注意してください。

 シェルスクリプトで gnuplot をコマンドラインオプション `-c` つきで実行
 することで、これと同じことを直接行うこともできます:

      gnuplot -persist -c "script1.gp" "sin(x)" 1.23 "This is a plot title"

3 old-style
?commands call old-style
?call old-style
 以下は、以前のバージョンの gnuplot で使われていた call の仕組みの記述
 ですが、現在は非推奨です。

       call "<input-file>" <param-0> <param-1> ... <param-9>

 入力ファイル名は引用符で囲まなければなりません。入力ファイルの各行を読
 み込む際に、以下の特別な文字列を走査します: $0 $1 $2 $3 $4 $5 $6 $7 $8
 $9 $#。それが見つかったら、「`$`+数字」の列は `call` コマンドラインの
 対応するパラメータに置き換えます。引用符はコピーせず、文字列変数置換は
 行いません。文字列 `$#` はパラメータ数に置き換えます。その他の文字が後
 ろについている `$` は、エスケープシーケンスとして処理します。例えば 1
 個 の `$` を使うには `$$` とします。

 例:

 ファイル 'calltest.gp' は以下の行を含んでいるとすると:
     print "argc=$# p0=$0 p1=$1 p2=$2 p3=$3 p4=$4 p5=$5 p6=$6 p7=x$7x"

 次の行を入力すると:
     call 'calltest.gp' "abcd" 1.2 + "'quoted'" -- "$2"

 以下のように表示されるでしょう:
     argc=7 p0=abcd p1=1.2 p2=+ p3='quoted' p4=- p5=- p6=$2 p7=xx

 注意: 文字 `$` は、gnuplot 自身のデータ列用の書式とぶつかりますし、
 Unix 系のシェルの環境変数を参照する `$` ともぶつかります。特別な文字列
 `$#` は、gnuplot のバージョン 4.5 から 4.6.3 までは、間違えてコメント
 文字列の区切り文字として解釈されていました。文字列置換では引用符は無視
 されるので、文字列定数は簡単に壊れてしまいます。
2 clear
?commands clear
?clear
 `clear` コマンドは、`set output` で選択された画面または出力装置をクリ
 アします。通常、ハードコピー装置に対しては改ページを行います。出力装置
 を選択するには `set terminal` を使用して下さい。

 いくつかの出力装置は `clear` コマンドでは `set size` で定義された描画
 領域のみを消去します。そのため、`set multiplot` とともに使用することで
 挿入図を一つ作ることができます。

 例:
       set multiplot
       plot sin(x)
       set origin 0.5,0.5
       set size 0.4,0.4
       clear
       plot cos(x)
       unset multiplot

 これらのコマンドの詳細については、以下参照: `set multiplot`,
 `set size`, `set origin`。
2 Do
?commands do
?do
 書式:
       do for <iteration-spec> {
            <commands>
            <commands>
       }
 これは、コマンド列を複数回実行します。コマンドは中カッコ {} で囲み、か
 つ開始カッコ "{" は、キーワード `do` と同じ行に置く必要があります。こ
 のコマンドは、古い形式 (かっこなし) の if/else 構文と一緒に使うことは
 できません。繰り返し指定 <iteration-spec> の例については、以下参照:
 `iteration`。例:
       set multiplot layout 2,2
       do for [name in "A B C D"] {
           filename = name . ".dat"
           set title sprintf("Condition %s",name)
           plot filename title name
       }
       unset multiplot
2 evaluate
?commands evaluate
?evaluate
 コマンド `evaluate` は、引数文字列として与えられたコマンドを実行します。
 その文字列中に改行文字を入れてはいけません。

 書式:
       eval <string expression>

 これは、特に同様のコマンドの繰り返しに有用です。

 例:
       set_label(x, y, text) \
         = sprintf("set label '%s' at %f, %f point pt 5", text, x, y)
       eval set_label(1., 1., 'one/one')
       eval set_label(2., 1., 'two/one')
       eval set_label(1., 2., 'one/two')

 文字列からコマンドを実行する別の方法に関しては、以下参照:
 `substitution macros`。
2 exit
?commands exit
?exit
 `exit` と `quit` の両コマンドは END-OF-FILE 文字 (通常 Ctrl-D) 同様、
 現在の入力ストリーム、すなわち端末の対話やパイプ入力、ファイル入力 (パ
 イプ) からの入力を終了させます。入力ストリームが入れ子 (階層的な
 `load` のスクリプトで) になっている場合、読み込みは親のストリームで継
 続されます。トップレベルのストリームが閉じられると、プログラムはそれ自
 身終了します。

 コマンド `exit gnuplot` は、直ちに、無条件に、そして例え入力ストリーム
 が多段階にネストされていても、gnuplot を終了させます。その場合、開かれ
 ていた全ての出力ファイルはきれいに完全な形では閉じられない可能性があり
 ます。使用例:

       bind "ctrl-x" "unset output; exit gnuplot"

 コマンド `exit error "error message"` は、疑似プログラムエラーを行いま
 す。対話型モードでは、そのエラーメッセージを表示し、すべのネストされた
 ループや call を中断してコマンドラインに帰ります。非対話型モードでは、
 プログラムを終了します。

 詳細は、以下参照: `batch/interactive`。
2 fit
?commands fit
?fit
?least-squares
?Marquardt
 コマンド `fit` は、Marquardt-Levenberg 法による非線形最小自乗法 (NLLS)
 を用いて、データ点の集合にユーザが与える式を当てはめます。独立変数は
 12 まで許されていて、従属変数は常に 1 つで、任意個数のパラメータを当て
 はめることができます。さらに追加で、データ点の重み付け用に誤差評価を入
 力することも可能です。

 `fit` の最も基本的な使用法は、以下の単純な例が示しています:

       f(x) = a + b*x + c*x**2
       fit f(x) 'measured.dat' using 1:2 via a,b,c
       plot 'measured.dat' u 1:2, f(x)

 書式:
       fit {<ranges>} <expression>
           '<datafile>' {datafile-modifiers}
           {{unitweights} | {y|xy|z}error | errors <var1>{,<var2>,...}}
           via '<parameter file>' | <var1>{,<var2>,...}

 範囲 (xrange, yrange 等) は、当てはめに使用するデータを制限する目的で
 使うことができ、その範囲を超えたデータは無視します。その書式は `plot`
 コマンド同様
       [{dummy_variable=}{<min>}{:<max>}],
 です。以下参照: `plot ranges`。

 <expression> は、通常はあらかじめユーザ定義された f(x) または f(x,y)
 の形の関数ですが、`gnuplot` で有効などんな数式でも指定できます。ただし
 実数値関数でなければいけません。
 独立変数の名前は、コマンド `set dummy` で設定するか、fit の範囲指定部
 分 (<rangse>) で設定します (以下を参照)。デフォルトでは、最初の 2 つは
 x, y となります。
 さらに、その数式は、当てはめの作業により決定する値を持つ 1 つ以上の変
 数 (パラメータ) に依存すべきです。

 <datafile> は `plot` コマンドと同様に扱われます。`plot datafile` の修
 飾子 (`using`, `every`,...) は、`smooth` を除いて、全て `fit` に使うこ
 とができます。以下参照:`plot datafile`。

 データファイルの内容は、plot コマンドに使用するのと同じ `using` 指定を
 使うことで柔軟に解釈させることができます。例えば、独立変数 x を2 列目
 と 3 列目の和として生成し、z の値を 6 列目から取り、重みを 1 としたい
 場合は以下のようにします:

       fit ... using ($2+$3):6

 `using` 指定がない場合、fit は暗黙に独立変数は 1 つだけと仮定します。
 ファイル自身、または using 指定が 1 列だけのデータを持つ場合、その行番
 号を独立変数値として使用します。
 `using` 指定を与えた場合、最大 12 個 (指定してコンパイルしていればさら
 にそれ以上) の独立変数を利用できます。

 オプション `unitweights` (これがデフォルト) は、すべてのデータ点が等し
 い重みを持つとみなします。これは、キーワード `error` を使用することで
 変更でき、これはデータファイルから 1 つ以上の変数の誤差評価を読み込み、
 その誤差評価を対応する変数値の標準偏差 s とみなし、各データに 1/s**2
 の重みを計算するのに使用します。

 独立変数の誤差評価において、その重みには、"有効分散法" (effective
 variance method; Jay Orear, Am. J. Phys., Vol. 50, 1982) に従って、さ
 らに当てはめ関数の微分係数をかけます。

 キーワード `errors` には、その後ろに、入力がどの変数の誤差であるのかを
 示すコンマ区切りの 1 つ以上の変数名のリストが付きます。従属変数 z は常
 にその中になければいけませんが、独立変数は必須ではありません。
 そのリストの各変数に対し、ファイルからその分の、各変数の誤差評価を持つ
 追加の列を読み込みます。繰り返しになりますが、`using` 指定により柔軟な
 解釈が可能になります。
 よって、独立変数の数は暗黙に、`using` 指定内の列の数から 1 を引いて
 (従属変数分)、さらに `errors` 指定内の変数の個数を引いた数になることに
 注意してください。

 例として、2 つの独立変数があり、そして 1 つ目の独立変数と従属変数の誤
 差データがある場合は、`errors x,z` 指定と 5 列の `using` 指定を使うこ
 とになりますが、それは x:y:z:sx:sz のように解釈されます (x, y は独立変
 数、z が従属変数、sx, sz は x, z の標準偏差)。

 `errors` 指定のちょっとした略記法も 2,3 用意されています:
 `yerrors` (独立変数が 1 列ある当てはめ用)、
 `zerrors` (より一般の場合) は、いずれも `errors z` と同値で、1 列だけ
 追加の従属変数用の誤差列があることを意味しています。

 `xyerrors` は、独立変数は 1 列で、その独立変数と従属変数の両方の 2 列
 の誤差列が追加されることを意味します。この場合、x と y の誤差は Orear
 の有効分散法 (effective variance method) で処理されます。

 `yerror` と `xyerror` の形式および解釈は、それぞれ 2 次元描画スタイル
 の `yerrorlines` と `xyerrorlines` に同等であることに注意してください。

 コマンド `set fit v4` を使用すると、fit のコマンド書式は `gnuplot` バ
 ージョン 4 以前と互換の書式になります。その場合、`using` には、独立変
 数が 2 つ以上ならば、独立変数の数より 2 つ (z と s) 多い指定が必要で、
 `gnuplot` は、`using` 指定で与えられた列の数に応じて、以下の書式に従い
 ます:

       z                           # 独立変数は 1 つ (行番号)
       x:z                         # 独立変数は 1 つ (第 1 列)
       x:z:s                       # 独立変数は 1 つ (全部で 3 列)
       x:y:z:s                     # 独立変数は 2 つ (全部で 4 列)
       x1:x2:x3:z:s                # 独立変数は 3 つ (全部で 5 列)
       x1:x2:x3:...:xN:z:s         # 独立変数は N 個 (全部で N+2 列)

 これは、2 つ以上の独立変数で fit をする場合、z-誤差 s を与える必要があ
 ることを意味することに注意してください。重みを 1 にしたい場合は、それ
 を、例えば x:y:z:(1) のような書式を using に指定することで明示的に与え
 る必要があります。

 仮変数名は、下で紹介するように範囲指定で指定することで変更できます。最
 初の範囲は `using` 指定の最初のものに対応し、以下同様です。従属変数で
 ある z の範囲指定もできますが、それは、f(x,...) の値をその範囲外にして
 しまうようなデータ点が、残差を最小化することには寄与しない場合に有効で
 す。

 複数のデータ集合も複数の 1 変数関数に同時に当てはめることも、y を '仮
 変数' とすれば可能です。例えばデータ行番号を使い、2 変数関数への当ては
 め、とすればいいでしょう。以下参照: `fit multi-branch`。

 `via` 指定子は、パラメータの最適化を、直接行うか、またはパラメータファ
 イルを参照することによって行うかを指定します。

 例:
       f(x) = a*x**2 + b*x + c
       g(x,y) = a*x**2 + b*y**2 + c*x*y
       set fit limit 1e-6
       fit f(x) 'measured.dat' via 'start.par'
       fit f(x) 'measured.dat' using 3:($7-5) via 'start.par'
       fit f(x) './data/trash.dat' using 1:2:3 yerror via a, b, c
       fit g(x,y) 'surface.dat' using 1:2:3 via a, b, c
       fit a0 + a1*x/(1 + a2*x/(1 + a3*x)) 'measured.dat' via a0,a1,a2,a3
       fit a*x + b*y 'surface.dat' using 1:2:3 via a,b
       fit [*:*][yaks=*:*] a*x+b*yaks 'surface.dat' u 1:2:3 via a,b

       fit [][][t=*:*] a*x + b*y + c*t 'foo.dat' using 1:2:3:4 via a,b,c

       set dummy x1, x2, x3, x4, x5
       h(x1,x2,x3,x4,s5) = a*x1 + b*x2 + c*x3 + d*x4 + e*x5
       fit h(x1,x2,x3,x4,x5) 'foo.dat' using 1:2:3:4:5:6 via a,b,c,d,e

 反復の個々のステップの後で、当てはめの現在の状態についての詳細な情報が
 画面に表示されます。そし最初と最後の状態に関する同じ情報が "fit.log"
 というログファイルにも書き出されます。このファイルは前の当てはめの履歴
 を消さないように常に追加されていきます。これは望むなら削除、あるいは別
 な名前にできます。コマンド `set fit logfile` を使ってログファイルの名
 前を変更することもできます。

 `set fit errorvariables` を使用した場合、各当てはめパラメータの誤差は
 そのパラメータと似た名前 ("_err" が追加された名前) の変数に保存されま
 すので、その誤差をその後の計算の入力として使用することができます。

 `set fit prescale` とした場合、当てはめパラメータを、それらの初期値か
 らスケール変換します。これにより、個々のパラメータの大きさにかなり違い
 があるような場合でも、Marquardt-Levenberg ルーチンがより早く、より信頼
 性のある値に収束させられるようになります。

 当てはめの反復は Ctrl-C (wgnuplot では Ctrl-Break) を押すことで中断で
 きます。現在の反復が正常に終了した後、以下のいずれかを選ぶことができま
 す:
 (1) 当てはめを止めて現在のパラメータの値を採用する
 (2) 当てはめを続行する
 (3) `set fit script` か、環境変数 `FIT_SCRIPT` で指定した `gnuplot` コ
 マンドを実行する。そのデフォルトは `replot` で、もしデータと当てはめ関
 数を一つのグラフにあらかじめ描画してあれば、現在の当てはめの状態を表示
 することができます。

 `fit` が終了した後は、最後のパラメータの値を保存するのに `update` コマ
 ンドを使います。その値は再びパラメータの値として使うことができます。
 詳細は、以下参照: `update`。
3 パラメータの調整 (adjustable parameters)
?commands fit parameters
?fit parameters
?commands fit adjustable_parameters
?fit adjustable_parameters
?fit_parameters
 `via` はパラメータを調節するための 2 つの方法を指定できます。一つは
 コマンドラインから直接指示するもので、もう一つはパラメータファイルを
 参照して間接的に行うものです。この 2 つは初期値の設定で違った方法を取
 ります。

 調整するパラメータは、`via` キーワードの後ろにコンマで区切られた変数名
 のリストを書くことで指定できます。定義されていない変数は初期値 1.0 と
 して作られます。しかし当てはめは、変数の初期値があらかじめ適切な値に設
 定されている方が多分速く収束するでしょう。

 パラメータファイルは個々のパラメータを、個別に 1 行に一つずつ、初期値を
 次のような形で指定して書きます。
       変数名 = 初期値

 '#' で始まるコメント行や空行も許されます。特別な形式として
       変数名 = 初期値       # FIXED

 は、この変数が固定されたパラメータであることを意味し、それはこのファイ
 ルで初期化されますが、調節はされません。これは、`fit` でレポートされる
 変数の中で、どれが固定された変数であるかを明示するのに有用でしょう。な
 お、`# FIXED` と言うキーワードは厳密にこの形でなくてはなりません。

3 fit の概略 (fit beginners_guide)
?commands fit beginners_guide
?fit beginners_guide
?fit guide
?fitting
 `fit` は、与えられたデータ点を与えられたユーザ定義関数にもっとも良く
 当てはめるようなパラメータを見つけるのに使われます。その当てはめは、
 同じ場所での入力データ点と関数値との自乗誤差、あるいは残差 (SSR:Sum
 of the Squared Residuals) の和を基に判定されます。この量は通常χ(カイ)
 自乗と呼ばれます。このアルゴリズムは SSR を 最小化することをしようと
 します。もう少し詳しく言うと、データ誤差 (または 1.0) の重みつき残差の
 自乗和 (WSSR) の最小化を行っています。詳細は、以下参照:
 `fit error_estimates`。

 これが、(非線形) 最小自乗当てはめ法と呼ばれるゆえんです。`非線形` が
 何を意味しているのかを見るための例を紹介しますが、その前にいくつかの
 仮定について述べておきます。ここでは簡単のため、1 変数のユーザー定義
 関数は z=f(x), 2 変数の関数は z=f(x,y) のようにし、いずれも従属変数と
 して z を用いることにします。パラメータとは `fit` が調整して適切な値を
 決定するユーザ定義変数で、関数の定義式中の未知数です。ここで言う、線形
 性/非線形性とは、従属変数 z と `fit` が調整するパラメータとの関係に対
 するものであり、z と独立変数 x (または x と y) との関係のことではあり
 ません (数学的に述べると、線形最小自乗問題では、当てはめ関数のパラメー
 タによる 2 階 (そして更に高階の) 導関数は 0、ということになります)。

 線形最小自乗法 (LLS) では、ユーザ定義関数は単純な関数の和であり、それ
 ぞれは一つのパラメータの定数倍で他のパラメータを含まない項になります。
 非線形最小自乗法 (NLLS) ではより複雑な関数を扱い、パラメータは色んな
 使われ方をされます。フーリエ級数は線形と非線形の最小自乗法の違いを表す
 一つの例です。フーリエ級数では一つの項は
      z=a*sin(c*x) + b*cos(c*x).
 のように表されます。もし、a と b が未知なパラメータで c は定数だとすれば
 パラメータの評価は線形最小自乗問題になります。しかし、c が未知なパラメー
 タならばそれは非線形問題になります。

 線形の場合、パラメータの値は比較的簡単な線形代数の直接法によって決定で
 きます。しかしそのような LLS は特殊な場合であり、'gnuplot' が使用する
 反復法は、もちろんそれも含めて、より一般的な NLLS 問題を解くことができ
 ます。`fit` は検索を行うことで最小値を探そうとします。反復の各ステップ
 は、パラメータの新しい値の組に対して WSSR を計算します。Marquardt-
 Levenberg のアルゴリズムは次のステップのパラメータの値を選択します。そ
 してそれはあらかじめ与えた基準、すなわち、(1) 当てはめが "収束した"
 (WSSR の相対誤差がある限界値より小さくなった場合。以下参照:
 `set fit limit`)、または (2) あらかじめ設定された反復数の限界に達した
 場合 (以下参照: `set fit maxiter`)、のいずれかを満たすまで続けられます。
 キーボードからその当てはめの反復は中断できますし、それに続いて中止する
 こともできます (以下参照: `fit`)。ユーザ変数 FIT_CONVERGED は、 直前の
 fit コマンドが収束により終了した場合は 1 を持ち、それ以外の理由で中断
 した場合は 0 を持ちます。FIT_NITER は、直前の当てはめで行われた繰り返
 しの回数を持ちます。

 当てはめに使われる関数はしばしばあるモデル (またはある理論) を元にして
 いて、それはデータの振舞を記述したり、あるいは予測しようとします。よっ
 て `fit` は、データがそのモデルにどれくらいうまく当てはまっているのかを
 決定するため、そして個々のパラメータの誤差の範囲を評価するために、モデ
 ルの自由なパラメータの値を求めるのに使われます。以下参照:
 `fit error_estimates`。

 そうでなければ、曲線による当てはめにおける関数は、モデルとは無関係に選
 ばれています (それは十分な表現力と最も少ない数のパラメータを持ち、デー
 タの傾向を記述しそうな関数として経験に基づいて選ばれるでしょう)。

 しかし、もしあなたが全てのデータ点を通るような滑らかな曲線を欲しいなら
 `fit` ではなく、むしろ `plot` の `smooth` オプションでそれを行うべきで
 しょう。
3 誤差評価 (error estimates)
?commands fit error_estimates
?fit error_estimates
?fit errors
 `fit` において "誤差" という用語は 2 つの異なった文脈で用いられます。
 一つはデータ誤差、もう一つはパラメータ誤差です。

 データ誤差は、平方残差の重み付きの和 WSSR、すなわちχ自乗を決定する際
 個々のデータ点の相対的な重みを計算するのに用いられます。それらはパラメ
 ータの評価に影響を与えます。それは、それらが、当てはめられた関数からの
 個々のデータ点の偏差が最終的な値に与える影響の大きさを決定することによ
 ります。正確なデータ誤差評価が与えられている場合には、パラメータの誤差
 評価等の `fit` が出力する情報はより役に立つでしょう。

 `statistical overview` では `fit` の出力のいくつかを説明し、
 'practical guidelines' に対する背景を述べています。
4 統計的な概要 (statistical overview)
?commands fit error statistical_overview
?fit error statistical_overview
?statistical_overview
 非線形最小自乗法 (Non-Linear Least-Squares; NLLS) の理論は、誤差の正規
 分布の点から一般的に記述されています。すなわち、入力データは与えられた
 平均とその平均に対する与えられた標準偏差を持つガウス (正規) 分布に従う
 母集団からの標本と仮定されます。十分大きい標本、そして母集団の標準偏差
 を知ることに対しては、χ自乗分布統計を用いて、通常「χ自乗」と呼ばれる
 値を調べることにより「当てはめの良さ」を述べることができます。減らされ
 た自由度のχ自乗 (χ自乗の自由度は、データ点の数から当てはめられるパラ
 メータの個数だけ引いた数) が 1.0 である場合は、データ点と当てはめられた
 関数との偏差の重みつき自乗和が、現在のパラメータ値に対する関数と与えら
 れた標準偏差によって特徴付けられた母集団の、ランダムなサンプルに対する
 自乗和とが全く同じであることを意味します。

 分散 = 総計である数え上げ統計学同様、母集団の標準偏差が定数でない場合、
 各点は観測される偏差の和と期待される偏差の和を比較するときに個別に重み
 づけされるべきです。

 最終段階で `fit` は 'stdfit'、すなわち残差の RMS (自乗平均平方根) で求
 められる当てはめの標準偏差と、データ点が重みづけられている場合に '減ら
 されたχ自乗' とも呼ばれる残差の分散をレポートします。自由度 (データ点
 の数から当てはめパラメータの数を引いたもの) はこれらの評価で使用されま
 す。なぜなら、データ点の残差の計算で使われるパラメータは同じデータから
 得られるものだからです。データ点が重みを持つ場合、`gnuplot` はいわゆる
 p-値を計算します。それはその自由度と結果のχ自乗値に対するχ自乗分布の
 累積分布関数値を 1 から引いた値です。以下参照: `practical_guidelines`。
 これらの値は以下の変数に代入されます:
       FIT_NDF = 自由度の数
       FIT_WSSR = 重みつき残差の自乗和
       FIT_STDFIT = sqrt(WSSR/NDF)
       FIT_P = p-値

 パラメータに関する信頼レベルを評価することで、当てはめから得られる最小
 のχ自乗と、要求する信頼レベルのχ自乗の値を決定するためのχ自乗の統計
 を用いることが出来ます。しかし、そのような値を生成するパラメータの組を
 決定するには、相当のさらなる計算が必要となるでしょう。

 `fit` は信頼区間の決定よりむしろ、最後の反復後の分散-共分散行列から直
 ちに得られるパラメータの誤差評価を報告します。これらの評価は、標準偏差
 として計算される量の指定に関する統計上の条件が、一般には非線形最小自乗
 問題では保証されないのですが、線形最小自乗問題での標準誤差 (各パラメー
 タの標準偏差) と同じ方法で計算されます。そしてそのため慣例により、これ
 らは "標準誤差" とか "漸近標準誤差" と呼ばれています。漸近標準誤差は一
 般に楽観過ぎ、信頼レベルの決定には使うべきではありませんが、定性的な指
 標としては役に立つでしょう。

 最終的な解は、解の範囲におけるパラメータの相関を示す相関行列も生成しま
 す: その主対角要素、すなわち自己相関は常に 1 で、全てのパラメータが独
 立ならば非対角要素はすべて 0 に近い値になります。完全に他を補いあう 2
 つの変数は、大きさが 1 で、関係が正の相関か負の相関かによって正か負に
 なる符号を持つ非対角要素を持ちます。非対角要素の大きさが小さいほど、各
 パラメータの標準偏差の評価は、漸近標準誤差に近くなります。
4 実用的なガイドライン (practical guidelines)
?commands fit error practical_guidelines
?fit error practical_guidelines
?practical_guidelines
?guidelines
 個々のデータ点への重みづけの割り当ての基礎を知っているなら、それが測定
 結果に対するより詳しい情報を使用させようとするでしょう。例えば、幾つか
 の点は他の点より当てになるということを考慮に入れることが可能です。そし
 て、それらは最終的なパラメータの値に影響します。

 データの重み付けは、最後の反復後の `fit` の追加出力に対する解釈の基礎
 を与えます。各点に同等に重み付けを行なうにしても、重み 1 を使うことよ
 りもむしろ平均標準偏差を評価することが、χ自乗が定義によりそうであるよ
 うに、WSSR を 無次元変数とすることになります。

 当てはめ反復の各段階で、当てはめの進行の評価に使うことが出来る情報が表
 示されます ('*' はより小さい WSSR を見つけられなかったこと、そして再試
 行していることを意味します)。'sum of squares of residuals' (残差の自乗
 和) は、'chisquare' (χ自乗) とも呼ばれますが、これはデータと当てはめ
 関数との間の WSSR を意味していて、`fit` はこれを最小化しようとします。
 この段階で、重み付けされたデータによって、χ自乗の値は自由度 (= データ
 点の数 - パラメータの数) に近付くことが期待されます。WSSR は補正された
 χ自乗値 (WSSR/ndf; ndf = 自由度)、または当てはめ標準偏差 (stdfit =
 sqrt(WSSR/ndf)) を計算するのに使われます。それらは最終的な WSSR に対し
 てレポートされます。

 データが重み付けされていなければ、stdfit は、ユーザの単位での、データ
 と当てはめ関数の偏差の RMS (自乗平均平方根) になります。

 もし妥当なデータ誤差を与え、データ点が十分多く、モデルが正しければ、
 補正χ自乗値はほぼ 1 になります (詳細は、適当な統計学の本の 'χ自乗分
 布' の項を参照してください)。この場合、この概要に書かれていること以外
 に、モデルがデータにどれくらい良く当てまっているかを決定するための追加
 の試験方法がいくつかあります。

 補正χ自乗が 1 よりはるかに大きくなったら、それは不正なデータ誤差評価、
 正規分布しないデータ誤差、システム上の測定誤差、孤立した標本値
 (outliers)、または良くないモデル関数などのためでしょう。例えば
 `plot 'datafile' using 1:($2-f($1))` などとして残差を描画することは、
 それらのシステム的な傾向を知るための手がかりとなります。データ点と関数
 の両者を描画することは、他のモデルを考えための手がかりとなるでしょう。

 同様に、1.0 より小さい補正χ自乗は、WSSR が、正規分布する誤差を持つラ
 ンダムなサンプルと関数に対して期待されるものよりも小さいことを意味しま
 す。データ誤差評価が大きすぎるのか、統計的な仮定が正しくないのか、また
 はモデル関数が一般的すぎて、内在的傾向に加えて特殊なサンプルによる変動
 の当てはめになっているのでしょう。最後の場合は、よりシンプルな関数にす
 ればうまく行くでしょう。

 当てはめの p-値は、自由度と結果のχ自乗値に対するχ自乗分布の累積分布
 関数値を 1 から引いた値です。これは、当てはめの良さのものさしを提供し
 ます。p-値の範囲は 0 から 1 までで、p-値がとても小さい、あるいはとても
 大きい場合は、モデルがデータとその誤差をちゃんと記述していないことを意
 味します。上で述べたように、これはデータに問題があるか、誤差かモデルに
 問題がある、またはそれらの組み合わせなのだろうと思います。p-値が小さい
 ことは、誤差が過小評価されているので、よって最終的なパラメータ誤差をス
 ケール変換すべきだろうということを意味するでしょう。以下も参照:
 `set fit errorscaling`。

 標準的なエラーを、パラメータの不確定性に関する、あるより現実的な評価に
 関係付けること、および相関行列の重要性を評価することができるようになる
 前に、あなたは `fit` と、それを適用しようとするある種の問題に慣れてお
 く必要があるでしょう。

 `fit` は、大抵の非線形最小自乗法の実装では共通して、距離の自乗
 (y-f(x))**2 の重み付きの和を最小化しようとすることに注意してください。
 それは、x の値の "誤差" を計算に関してはどんな方法も与えてはおらず、単
 に y に関する評価のみです。また、"孤立点" (正規分布のモデルのから外れ
 ているデータ点) は常に解を悪化させる可能性があります。
3 制御 (control)
?commands fit control
?fit control
 コマンド `fit` の設定は、`set fit` で制御します。以前の `gnuplot` のユ
 ーザ変数は、バージョン 5 で非推奨となっています。以下参照:
 `fit control variables`。

 `gnuplot` の起動前に `fit` に影響を与えるように定義できる多くの環境変
 数があります。以下参照: `fit control environment`。
4 制御変数 (control variables)
?commands fit control variables
?fit control variables
=FIT_LIMIT
=FIT_MAXITER
=FIT_START_LAMBDA
=FIT_LAMBDA_FACTOR
 ここで説明するユーザ定義変数は、非推奨です。以下参照: `set fit`。

 デフォルトのもっとも小さい数字の限界 (1e-5) は、変数
       FIT_LIMIT
 で変更できます。残差の平方自乗和が 2 つの反復ステップ間で、この数値よ
 り小さい数しか変化しなかった場合、当てはめルーチンは、これを '収束した'
 と見なします。

 反復数の最大値は変数
       FIT_MAXITER
 で制限されます。0 (または定義しない場合) は制限無しを意味します。

 更にそのアルゴリズムを制御したい場合で、かつ Marquardt-Levenberg アル
 ゴリズムを良く知っている場合は、さらにそれに影響を与える変数があります。
 `lambda` (λ) の最初の値は、通常 ML 行列から自動的に計算されますが、も
 しそれをあらかじめ用意した値にセットしたければ
       FIT_START_LAMBDA
 にセットしてください。FIT_START_LAMBDA を 0 以下にセットすると、自動的
 に計算されるようになります。変数
       FIT_LAMBDA_FACTOR
 は、χ自乗化された関数が増加、あるいは減少するにつれて `lambda` が増加
 あるいは減少する因数を与えます。FIT_LAMBDA_FACTOR を 0 とすると、それは
 デフォルトの因数 10.0 が使用されます。

 `fit` には FIT_ から始まる変数が他にもありますから、ユーザ定義変数とし
 てはそのような名前で始まる変数は使わないようにするのが安全でしょう。

 変数 FIT_SKIP と FIT_INDEX は、以前の版の `gnuplot` の、`gnufit` と呼
 ばれていた `fit` パッチで使われていたもので、現在は使用されていません。
 FIT_SKIP の機能はデータファイルに対する `every` 指定子で用意されていま
 す。FIT_INDEX は複数当てはめ法 (multi-branch fitting) で使われていたも
 のですが、1 変数の複数当てはめ法は、今では 疑似 3 次元当てはめとして行
 なわれていて、そこでは枝の指定には 2 変数と `using` が使われています。
 以下参照: `fit multi-branch`。
4 環境変数 (control environment)
?commands fit control environment
?fit control environment
=FIT_LOG
=FIT_SCRIPT
 環境変数は `gnuplot` が立ち上がる前に定義しなければなりません。その設
 定方法はオペレーティングシステムに依存します。

       FIT_LOG
 は、当てはめのログが書かれるファイル名 (およびパス) を変更します。デフ
 ォルトでは、作業ディレクトリ上の "fit.log" となっています。そのデフォ
 ルトの値はコマンド `set fit logfile` を使って上書きできます。

       FIT_SCRIPT
 は、ユーザが中断した後に実行するコマンドを指定します。デフォルトでは
 `replot` ですが、`plot` や `load` コマンドとすれば、当てはめの進行状
 況の表示をカスタマイズするのに便利でしょう。その設定は、
 `set fit script` を使って変更できます。
3 複数の当てはめ (multi-branch)
?commands fit multi-branch
?fit multi-branch
?multi-branch
?branch
 複数当てはめ法 (multi-branch fitting) では、複数のデータ集合を、共通の
 パラメータを持つ複数の 1 変数の関数に、WSSR の総和を最小化することによ
 って同時に当てはめることが出来ます。各データ集合に対する関数とパラメー
 タ (枝) は '疑似変数' を使うことで選択できます。例えば、データ行番号
 (-1; 'データ列' の番号) またはデータファイル番号 (-2) を 2 つ目の独立
 変数とします。

 例: 2 つの指数減衰形 z=f(x) が与えられていて、それぞれ異なるデータ集合
 を記述しているが、共通した減衰時間を持ち、そのパラメータの値を評価する。
 データファイルが x:z:s の形式であったとすると、この場合以下のようにす
 ればよい。
      f(x,y) = (y==0) ? a*exp(-x/tau) : b*exp(-x/tau)
      fit f(x,y) 'datafile' using  1:-2:2:3  via a, b, tau

 より複雑な例については、デモファイル "fit.dem" で使われる "hexa.fnc"
 を参照してください。

 もし従属変数のスケールに差がある場合、単位の重み付けでは 1 つの枝が支
 配してしまう可能性があるので、適当な重み付けが必要になります。各枝をバ
 ラバラに当てはめるのに複数当てはめ法の解を初期値として用いるのは、全体
 を合わせた解の各枝に対する相対的な影響に関する表示を与えることになるで
 しょう。
3 初期値 (starting values)
?commands fit starting_values
?fit starting_values
?starting_values
 非線形当てはめは、大域的な最適値 (残差の自乗和 (SSR) の最小値を持つ解)
 への収束は保証はしませんが、局所的な極小値を与えることはできます。その
 サブルーチンはそれを決定する方法を何も持ち合わせていないので、これが起
 こったかどうかを判断するのはあなたの責任となります。

 `fit` は、解から遠くから始めると失敗するかも知れませんし、しばしばそれ
 は起こり得ます。遠くというのは、SSR が大きく、パラメータの変化に対して
 その変化が小さい、あるいは数値的に不安定な領域 (例えば数値が大きすぎて
 浮動小数の桁あふれを起こす) に到達してしまって、その結果 "未定義値
 (undefined value)" のメッセージか `gnuplot` の停止を引き起こしてしまう
 ような場合を意味します。

 大域的な最適値を見つける可能性を改善するには、最初の値をその解に少なく
 ともほぼ近くに取るべきでしょう。例えば、もし可能ならば一桁分の大きさの
 範囲内で。最初の値が解に近いほど他の解で終了してしまう可能性は低くなり
 ます。最初の値を見つける一つの方法は、データと当てはめ関数を同じグラフ
 の上に描画して適当な近さに達するまで、パラメータの値を変更して `replot`
 することを繰り返すことです。その描画は、よくない当てはめの極小値で当て
 はめが終了したかどうかをチェックするのにも有用です。

 もちろん、適度に良い当てはめが、"それよりよい" 当てはめ (ある改良され
 た当てはめの良さの基準によって特徴付けられた統計学的な意味で、あるいは
 そのモデルのより適切な解である、という物理的な意味で) が存在しないこと
 の証明にはなりません。問題によっては、各パラメータの意味のある範囲をカ
 バーするような様々な初期値の集合に対して `fit` することが望ましいかも
 知れません。
3 ヒント (tips)
?commands fit tips
?fit tips
?tips
 ここでは、`fit` を最大限に利用するためにいくつか覚えておくべきヒントを
 紹介します。それらは組織的ではないので、その本質がしみ込むまで何回もよ
 く読んでください。

 `fit` の引数の `via` には、2 つの大きく異なる目的のための 2 つの形式が
 あります。`via "file"` の形式は、バッチ処理 (非対話型での実行が可能)
 で最も良く使われ、そのファイルで初期値を与え、またその後で結果を他の
 (または 同じ) パラメータファイルにコピーするために `update` を使うこ
 とも出来ます。

 `via var1, var2, ...` の形式は対話型の実行で良く使われ、コマンドヒスト
 リの機構が使ってパラメータリストの編集を行い、当てはめを実行したり、あ
 るいは新しい初期値を与えて次の実行を行なったりします。これは難しい問題
 に対しては特に有用で、全てのパラメータに対して 1 度だけ当てはめを直接
 実行しても、良い初期値でなければうまくいかないことが起こり得るからです。
 それを見つけるには、いくつかのパラメータのみに対して何回か反復を行ない、
 最終的には全てのパラメータに対する 1 度の当てはめがうまくいくところに
 十分近くなるまでそれを繰り返すことです。

 当てはめを行なう関数のパラメータ間に共通の依存関係がないことは確認して
 おいてください。例えば、a*exp(x+b) を当てはめに使ってはいけません。そ
 れは a*exp(x+b)=a*exp(b)*exp(x) だからです。よってこの場合は a*exp(x)
 または exp(x+b) を使ってください。

 技術的なお話: 絶対値が最も大きいパラメータと最も小さいパラメータの比が
 大きい程当てはめの収束は遅くなります。その比が、マシンの浮動小数の精度
 の逆数に近いか、またはそれ以上ならば、ほぼずっと収束しないか収束する前
 に実行が中断するでしょう。よってそのような場合は、その関数の定義で例え
 ば 'parameter' を '1e9*parameter' にするとか、最初の値を 1e9 で割ると
 かしてこれを避けるように改良するか、または `set fit prescale` でパラメ
 ータの初期値に従ってそのスケール変換を内部でやらせる機能を用いるか、の
 いずれかが必要でしょう。

 もし、関数を、当てはめるパラメータを係数とする、単純な関数の線形結合で
 書けるなら、それはとてもいいので是非そうしてください。何故なら、問題が
 もはや非線形ではないので、反復は少ない回数で収束するでしょう。もしかし
 たらたった一回ですむかもしれません。

 実際の実験の講義ではデータ解析に対するいくつかの指示が与えられ、それで
 データへの最初の関数の当てはめが行なわれます。もしかすると、基礎理論の
 複数の側面にひとつずつ対応する複数回のプロセスが必要かも知れませんが、
 そしてそれらの関数の当てはめのパラメータから本当に欲しかった情報を取り
 出すでしょう。しかし、`fit` を使えば、求めるパラメータの視点から直接モ
 デル関数を書くことにより、それはしばしば 1 回で済むのです。時々はより
 難しい当てはめ問題の計算コストがかかりますが、データ変換もかなりの割合
 で避けることが出来ます。もしこれが、当てはめ関数の単純化に関して、前の
 段落と矛盾してると思うなら、それは正解です。

 "singular matrix" のメッセージは、この Marquardt-Levenberg アルゴリズ
 ムのルーチンが、次の反復に対するパラメータの値の計算が出来ないことを意
 味します。この場合、別な初期値から始めるか、関数を別な形で書き直すか、
 より簡単な関数にしてみてください。

 最後に、他の当てはめパッケージ (fudgit) のマニュアルから、これらの文書
 を要約するようないい引用を上げます: "Nonlinear fitting is an art! (非
 線形当てはめ法は芸術だ !)"
2 help
?commands help
?help
 `help`コマンドは、組み込みヘルプを表示します。ある項についての説明を指
 定したいときには、次の書式を使って下さい:

         help {<項目名>}

 もし <項目名> が指定されなかった場合は、`gnuplot` についての簡単な説明
 が表示されます。指定した項目についての説明が表示された後、それに対する
 細目のメニューが表示され、その細目名を入力することで細目に対するヘルプ
 を続けることができます。そして、その細目の説明が表示された後に、さらな
 る細目名の入力を要求されるか、または 1 つ前の項目のレベルへ戻ります。
 これを繰り返すとやがて、`gnuplot` のコマンドラインへと戻ります。

 また、疑問符 (?) を項目として指定すると、現在のレベルの項目のリストが
 表示されます。
2 history
?commands history
?history
 コマンド `history` は、コマンド履歴の一覧を表示したり、保存したり、一
 覧の中のコマンドを再実行したりします。このコマンドの挙動を変えるには、
 以下参照: `set history`。

 例:

       history               # 履歴全体を表示
       history 5             # 履歴内の直前の 5 つを表示
       history quiet 5       # エントリ番号なしで直前の 5 つを表示
       history "hist.gp"     # 履歴全体をファイル hist.gp に書き出す
       history "hist.gp" append # 履歴全体をファイル hist.gp に追加する
       history 10 "hist.gp"  # 直前の 10 個をファイル hist.gp に出力
       history 10 "|head -5 >>diary.gp" # パイプで履歴を 5 つ書き出す
       history ?load         # 履歴内の "load" で始まるものすべてを表示
       history ?"set c"      # 上と同様 (複数の語は引用符で囲む)
       hi !reread            # "reread" で始まる最も新しい行を実行
       hist !"set xr"        # 上と同様 (複数の語は引用符で囲む)
       hist !55              # 55 番目の履歴項目のコマンドを再実行
2 if
?commands if
?if
 新しい書式:
       if (<condition>) { <commands>;
              <commands>
              <commands>
       } else {
              <commands>
       }
 以前の書式:
       if (<条件>) <コマンド行> [; else if (<条件>) ...; else ...]

 このバージョンの gnuplot は、if/else のブロック形式をサポートしていま
 す。キーワード `if`, `else` の後ろに開始カッコ "{" が続く場合、"}" で
 終了するブロックまでのすべての文 (複数の入力行も可) に条件的な実行が適
 用されます。if コマンドは入れ子にすることもできます。

 古い形式の 1 行の if/else 文もまだサポートされていますが、新しいブロッ
 ク形式の書式とは混ぜてはいけません。以下参照: `if-old`。
3 if-old
?if if-old
?if-old
 gnuplot バージョン 4.4 までは、if/else コマンドの通用範囲は 1 行内に留
 まっていましたが、現在は複数行を中カッコ { } で囲んで書くことができま
 す。古い形式も一応残されていますが、それは中カッコのブロック内で使うこ
 とはできません。

 キーワード `if` が "{" をともなわない場合は、<条件> が真 (ゼロでない)
 ならば <コマンド行> のコマンド (複数も可) が実行され、偽 (ゼロ) ならば
 スキップされます。いずれの場合も入力行の最後になるか、`else` が現れる
 ところまでそれが行われます。`;` を使うと同じ行に複数のコマンド置くこと
 が可能ですが、条件付きのコマンド (`if` の構文自体) はそこでは終らない
 ことに注意してください。

 例:
       pi=3
       if (pi!=acos(-1)) print "?Fixing pi!"; pi=acos(-1); print pi
 を実行すると、
       ?Fixing pi!
       3.14159265358979
 と表示されますが、
       if (1==2) print "Never see this"; print "Or this either"
 とすると、何も表示されません。

 その他:
       v=0
       v=v+1; if (v%2) print "2" ; else if (v%3) print "3" ; else print "fred"
 (何度も最後の行を繰り返してみてください !)
2 for
?for
 `plot`, `splot`, `set`, `unset` コマンドでは、繰り返しの for 節を使う
 こともできます。これは、基本的なコマンドを複数回実行する効果を持ち、そ
 のおのおのの実行では繰り返し制御変数によって数式は再評価されます。`do`
 コマンドでは、どんなコマンド列でも繰り返し実行させることができます。繰
 り返し節は現在は以下の 2 つの形式をサポートしています:

       for [intvar = start:end{:increment}]
       for [stringvar in "A B C D"]

 例:

       plot for [filename in "A.dat B.dat C.dat"] filename using 1:2 with lines
       plot for [basename in "A B C"] basename.".dat" using 1:2 with lines
       set for [i = 1:10] style line i lc rgb "blue"
       unset for [tag = 100:200] label tag

 繰り返しの入れ子もサポートしています:

       set for [i=1:9] for [j=1:9] label i*10+j sprintf("%d",i*10+j) at i,j

 さらなる説明については、以下参照: `iteration`, `do`。
2 import
?commands import
?import
 コマンド `import` は、ユーザ定期関数名を外部共有オブジェクトから取り込
 まれる関数に結びつけます。これは、gnuplot で利用可能な関数の設定を拡張
 するプラグイン機構を構成します。

 書式:
       import func(x[,y,z,...]) from "sharedobj[:symbol]"

 例:
       # 関数 myfun を "mylib.so" か "mylib.dll" から取り込んで作成する
       # gnuplot では描画、または数値計算で利用可能
       import myfun(x) from "mylib"
       import myfun(x) from "mylib:myfun"    # 上と同様

       # "theirlib.so" か "theirlib.dll" で定義済の関数 theirfun を作成
       # 異なる名前で利用可能
       import myfun(x,y,z) from "theirlib:theirfun"

 プログラムは共有オブジェクトとして与えられた名前に、オペレーティングシ
 ステムに従って ".so" か ".dll" を追加し、まずそれをフルパス名として検
 索し、次にカレントディレクトリからの相対パス名として検索します。オペレ
 ーティングシステム自体も LD_LIBRARY_PATH か DYLD_LIBRARY_PATH の任意の
 ディレクトリを検索します。

2 load
?commands load
?load
 `load` コマンドは、指定された入力ファイルの各行を、それが対話的に入力
 されたかのように実行します。`save` コマンドでつくられたファイルは、
 `load` することができます。有効なコマンドの書かれたテキストファイルを
 つくれば、それは、`load`コマンドによって、実行することができます。
 `load` 中のファイルの中にさらに `load` または `call` コマンドがあって
 も構いません。コマンド中のコメントについては、以下参照: `comments`。
 `load` するときに引数を与える方法については、以下参照: `call`。

 書式:
         load "<入力ファイル名>"

 入力ファイル名は引用符で囲まなければなりません。

 `load` コマンドは、標準入力からのコマンドの入力のために、特別なファイ
 ル名 "-" を用意しています。これは、`gnuplot` のコマンドファイルが、い
 くつかのコマンドを標準入力から受け付けることを意味します。詳細について
 は、以下参照: `batch/interactive`。

 Unix のように popen 関数をサポートするようなシステムでは、'<' で始まる
 ファイル名にすることで、入力ファイルをパイプから読み込むことができます。

 例:
         load 'work.gnu'
         load "func.dat"
         load "< loadfile_generator.sh"

 `gnuplot` への引数として与えられたファイル名は、暗黙のうちに `load` コ
 マンドによって実行されます。これらは、指定された順にロードされ、その後
 `gnuplot` は終了します。
2 lower
?commands lower
?lower
 書式:
       lower {plot_window_nb}

 コマンド `lower` (`raise` の反対) は、`pm`, `win`, `wxt`, `x11` 等の
 gnuplot の対話型出力形式の実行中に、描画ウィンドウを下 (背後) に下げま
 す。描画ウィンドウを、デスクトップ上のウィンドウマネージャの z 方向の
 ウィンドウの重なりの下に置きます。

 `x11` や `wxt` のように複数の描画ウィンドウをサポートしている場合、デ
 フォルトではこのコマンドはそれらの複数のウィンドウを降順に下げ、最初に
 作られたウィンドウを一番下に、最後に作られたウィンドウを一番上に並べま
 す。オプション引数の描画番号が与えられた場合、それに対応する描画ウィン
 ドウが存在すればそれのみが下げられます。

 オプション引数は、単一の描画ウィンドウの出力形式、すなわち `pm` と
 `win` では無視されます。
2 pause
?commands pause
?pause
?pause mouse
 `pause` コマンドは、コマンドに続く任意の文字列を表示した後、指定され
 た時間または、改行キーが押されるまで待ちます。`pause` コマンドは、
 `load` 用のファイルと共に使用すると、便利になるでしょう。

 書式:
       pause <time> {"<string>"}
       pause mouse {<endcondition>}{, <endcondition>} {"<string>"}

 <time> は、任意の定数または式です。-1 を指定すると改行キーが押されるま
 で待ちます。0 を指定すると一切待たず、正の数を指定するとその秒数だけ待
 ちます。実行環境が秒以下の時間指定をサポートしていない場合、その時間は
 整数の秒数に丸められます。`pause 0` は `print` と同じです。

 使用している出力形式が `mousing` (マウス機能) をサポートしている場合、
 `pause mouse` は、マウスクリックがあるか ctrl-C が押されるまで待つよう
 になります。そうでない出力形式、またはマウス機能が有効になってない場合
 `pause mouse` は `pause -1` と同じです。

 一つ、あるいは複数の終了条件 (endcondition) が `pause mouse` の後に与
 えられた場合、そのうちのどの一つでも pause は終了します。指定できる終
 了条件は、`keypress`, `button1`, `button2`, `button3`, `close`, `any`
 のいずれかです。pause がキー入力によって終了した場合、押されたキーの
 ASCII コードは MOUSE_KEY に保存され、文字それ自身は、1 文字の文字列値
 として MOUSE_CHAR に返されます。`keypress` が終了条件の一つであれば、
 ホットキー (キー割り当てコマンド) は無効になります。`buttons3` が終了
 条件の一つであれば、拡大機能は無効になります。

 どの場合でもマウスの座標は変数 MOUSE_X, MOUSE_Y, MOUSE_X2, MOUSE_Y2 に
 保存されます。以下参照: `mouse variables`。

 注意: `pause` コマンドは OS へのコマンドであり描画の一部ではないので、
 異なる出力装置では異なる動作をする可能性があります。(これは、テキスト
 とグラフィックスが、どのように混在するかによります。)

 例:
       pause -1    # 改行キーが押されるまで待つ
       pause 3     # 3 秒待つ
       pause -1  "続けるには return を打ってください"
       pause 10  "これは美しくないですか ? 3 次の spline です"
       pause mouse "選択したデータ点上で任意のボタンをクリックしてください"
       pause mouse keypress "有効なウィンドウ内で A-F の文字を入力してください"
       pause mouse button1,keypress
       pause mouse any "任意のキー、ボタンで終了します"

 亜種である "pause mouse key" は、有効な描画ウィンドウ内での任意のキー
 入力によって再開されます。特別なキー入力まで待つようにしたい場合は、以
 下のような reread によるループを使うことができます:

       print "描画ウィンドウ内で Tab キーを打つと復帰します。"
       load "wait_for_tab"

 ファイル "wait_for_tab" は以下のようなものです:

       pause mouse key
       if (MOUSE_KEY != 9) reread

2 plot
?commands plot
?plot
 `plot` は `gnuplot` で図を描くための基本的なコマンドです。 それは関数
 やデータの、多くの種類のグラフ表現を提供します。`plot` は 2 次元の関数
 やデータを描くのに使われ、`splot` は 3 次元の曲面やデータの 2 次元投影
 を描きます。

 書式:
       plot {<ranges>} <plot-element> {, <plot-element>, <plot-element>}

 各描画要素 (plot-element) は、定義 (definition) か関数 (function) かデ
 ータ (data source) のいずれか 1 つに、オプションの属性、修正子などがつ
 いたものです:
       描画要素 (plot-element):
            {<iteration>}
            <definition> | {sampling-range} <function> | <data source>
            {axes <axes>} {<title-spec>}
            {with <style>}

 各描画要素のグラフ表現形式は、例えば `with lines` や `with boxplot` な
 どのようにキーワード `with` で決定します。以下参照: `plotting styles`。

 描画するデータは、1 つの関数から生成されるもの (媒介変数モード
 (parametric) では 2 つの関数から)、または一つのデータファイルから読み
 込まれるもの、または事前に定義された名前付きデータブロックから読み込ま
 れるもの、のいずれかです。コンマで区切ることで、複数のデータファイル、
 データブロック、関数などを 1 つの plot コマンドで描画できます。以下参
 照: `data`, `inline data`, `functions`。

 関数、変数の定義の描画要素は、画像出力を生成しません。下の 3 つ目の例
 を参照してください。

 例:
       plot sin(x)
       plot sin(x), cos(x)
       plot f(x) = sin(x*a), a = .2, f(x), a = .4, f(x)
       plot "datafile.1" with lines, "datafile.2" with points
       plot [t=1:10] [-pi:pi*2] tan(t), \
            "data.1" using (tan($2)):($3/$4) smooth csplines \
                     axes x1y2 notitle with lines 5
       plot for [datafile in "spinach.dat broccoli.dat"] datafile

 以下参照: `show plot`。
3 軸 (axes)
?commands plot axes
?plot axes
?axes
 軸 (axes) は、4 種類の組が利用できます; キーワード <axes> は、特定の直
 線をどの軸に尺度を合わせるか、ということを選択するのに使われます。
 `x1y1` は下の軸と左の軸を指定; `x2y2` は上と右の軸の指定; `x1y2` は下
 と右の軸の指定; `x2y1` は上と左の軸の指定です。`plot` コマンドで指定さ
 れた範囲は、この最初の軸の組 (下と左) にのみ適用されます。
3 binary
?binary
?data binary
?datafile binary
?plot data binary
 バイナリデータファイル:

 ファイル名の後ろに `binary` のキーワードを与えなければいけません。ファ
 イル形式に関する十分詳細な情報は、ユーザがコマンドラインから与えるか、
 またはサポートしている `filetype` のバイナリ形式のファイルそれ自身から
 抜き出されるかする必要があります。バイナリファイルには、大きく 2 つの
 形式、binary matrix 形式と binary general 形式があります。

 `binary matrix` 形式は、32 ビット IEEE 規格の浮動小数値 (float) が 2
 次元配列の形で並び、それらの座標値を表す行と列が追加されています。plot
 コマンドの `using` 指定において、1 番目 (column(1)) は行列の行の座標を
 参照し、2 番目 (column(2)) は列の座標を参照し、3 番目 (column(3)) は、
 配列のそれらの座標の場所に保存されている値を参照します。

 `binary general` 形式は、任意個の列のデータを含み、それらの情報はコマ
 ンドラインで指定する必要があります。例えば `array`, `record`, `format`,
 `using` などでサイズや形式、データの次元を指定できます。他にも、ファイ
 ルヘッダ読み飛ばしたり、エンディアン (endian) を変更するための有用なコ
 マンドがありますし、配置、データの変換を行なうコマンドの組があります。
 それは、一様に標本化されたデータの場合、その座標がファイルには含まれな
 いことが良くあるからです。matrix バイナリファイルやテキストデータから
 の入力と違うところですが、general バイナリは 1,2,3 といった `using` リ
 ストで生成される列番号を使わず、代わりに 1 列目はファイルの 1 列目、あ
 るいは `format` リストで指定されたもの、になります。

 さまざまな binary オプションに対する大域的なデフォルトの設定も可能で、
 それは `(s)plot <filename> binary ...` コマンドに与えるオプションと全
 く同じ書式で指定できます。その書式は `set datafile binary ...` です。
 一般的な規則として、デフォルトのパラメータはファイルから抜き出されたパ
 ラメータで上書きされ、それはコマンドラインで指定された共通なパラメータ
 で上書きされます。

 例えば `array`, `record`, `format`, `filetype` の `binary general` 形
 式を特定するようなキーワードが何もついていなければ、デフォルトのバイナ
 リ形式は `binary matrix` です。

 general バイナリデータは、特別なファイル名 '-' を使ってコマンドライン
 から入力することもできます。しかし、これはキーボードからの入力を意図し
 たものではなく、パイプを使ってプログラムにバイナリ形式を変換させるため
 のものです。バイナリデータには最後を表す記号がありませんので、gnuplot
 はパイプからデータを読み込む場合、`array` 指定子で指定した数の点数にな
 るまでデータを読み込み続けます。詳細に関しては、以下参照:
 `binary matrix`, `binary general`。

 `index` キーワードは、ファイルフォーマットが 1 つのファイルにつき 1 つ
 の曲面しか許さないため、サポートされません。`every` や `using` フィルタ
 はサポートされます。`using` は、データがあたかも上の 3 つ組の形で読まれ
 たかのように働きます。
^ <a href="http://www.gnuplot.info/demo/binary.html">
 バイナリファイルの splot のデモ。
^ </a>
4 general
?commands plot binary general
?commands splot binary general
?plot binary general
?splot binary general
?datafile binary general
?data binary general
?binary general
 キーワード `binary` を単独で指定した場合は、非一様な格子を形成する座標
 情報と、各格子点での値の両方を持つバイナリデータであることを意味し (以
 下参照: `binary matrix`)、他の形式のバイナリデータの場合は、そのデータ
 の形式を意味する追加キーワードを指定する必要があります。残念ながら、こ
 れらの追加キーワードの書式は単純ではありませんが、それでも general バ
 イナリモードは、特に多量のデータを gnuplot に送るようなアプリケーショ
 ンに取っては有用です。

 書式:
       plot '<file_name>' {binary <binary list>} ...
       splot '<file_name>' {binary <binary list>} ...

 general バイナリ形式は、ファイル構造に関する情報に関連するキーワード、
 すなわち `array`, `record`, `format`, `filetype` などを <binary list>
 内に与えることで有効になります。それ以外の場合は、非一様な matrix バイ
 ナリ形式と見なします。(詳細に関しては、以下参照: `binary matrix`。)

 注意: 以前の版の gnuplot では、バイナリデータ用のキーワードの解釈に、
 `plot` と `splot` では少し違いがありました。その意味の違う箇所は、今後
 の版の gnuplot では、その一方あるいは両方が変更される可能性があります。

 gnuplot は、例えば PNG 画像のように完全に自己記述される標準的なバイナ
 リファイル形式の読み込み方法をいくつか知っています。その一覧は、対話画
 面で `show datafile binary` と入力することで参照できます。それら以外の
 ものについては、概念上はバイナリデータはテキストデータと同様に考えるこ
 とができます。各点には、`using` 指定で選択される情報の列があります。
 `format` 文字列を指定しなかった場合、gnuplot はバイナリ数値の数を
 `<using list>` で与えられる最大の列番号に等しく取ります。例えば、
 `using 1:3` とすると 3 列ずつデータが読み取られ、2 番目のものは無視し
 ます。各描画スタイルにはデフォルトの using 指定があります。例えば
 `with image` はデフォルトで `using 1` を、`with rgbimage` はデフォルト
 で `using 1:2:3` を使います。
4 array
?binary array
 バイナリファイルの標本の配列の大きさを設定します。座標は gnuplot が生
 成してくれます。各方向の次元を表す数を指定しなければいけません。例えば
 `array=(10,20)` は、2 次元で最初の次元方向 (x) には 10 点、2 番目の次
 元方向 (y) には 20 点の標本化データがあることを意味します。ファイルの
 終了までデータが続くことを示すのに負の値を使えます。データ次元が 1 の
 場合は、カッコは省略できます。複数のデータのサイズ指定を分離するのに、
 コロンを使うことができます。例えば `array=25:35` は 2 つの 1 次元デー
 タがファイルの中にあることを意味します。
       注意:  gnuplot バージョン 4.2 では array=(128,128) という書式で
              はなく、array=128x128 という書式を使用していました。古い
              書式は推奨されていません。
4 record
?binary record
 このキーワードは `array` と同じ書式で、同じ機能を提供します。しかし
 `record` は gnuplot に座標情報を自動生成させません。これは、そのような
 座標情報が、バイナリデータファイルのある列に含まれている場合のためのも
 のです。
4 skip
?binary skip
 このキーワードは、バイナリファイルのある区画のスキップを可能にします。
 例えば、そのファイルがデータ領域の開始位置の前に 1024 バイトのヘッダを
 持つような場合には、以下のようにしたいと思うでしょう:
       plot '<file_name>' binary skip=1024 ...
 ファイルに複数のレコードがある場合、そのそれぞれに対する先頭のずらし位
 置を指定することができます。例えば、最初のレコードの前の 512 バイトを
 スキップし、2 番目、3 番目のレコードの前の 256 バイトをスキップするに
 は以下のようにします:
       plot '<file_name> binary record=356:356:356 skip=512:256:256 ...
4 format
?binary format
 デフォルトのバイナリ形式は、単精度浮動小数 (float) が一つ、です。それ
 をより柔軟に設定するために、この format で変数のサイズに関する詳細な情
 報を指定できます。例えば `format="%uchar%int%float"` は、最初の using
 列として符号なし文字型変数 (unsigned char) を、2 番目の列は符号つき整
 数 (int) を、3 番目の列は単精度浮動小数 (float) を指定しています。もし
 サイズ指定子の数が最大列数より小さい場合は、残りの列の変数サイズは暗黙
 のうちに最後に与えた変数サイズに等しく取られます。

 さらに `using` 指定同様、`*` 文字がついた読み捨てる列を書式に指定する
 こともできますし、繰り返しフィールドへの回数指定によって暗黙の繰り返し
 を指定することもできます。例えば、`format="%*2int%3float"` は、3 つの
 実数データを読む前に、2 つの整数データを読み捨てます。使用できる変数サ
 イズの一覧は、`show datafile binary datasizes` で見ることができます。
 それらは、それぞれのコンパイルによってそのバイトサイズとともにマシンに
 依存する変数名のグループと、マシンに依存しない変数名のグループに分かれ
 ています。
4 endian
?binary endian
 ファイルのバイナリデータのエンディアンは、gnuplot が動作するプラットホ
 ームのエンディアンとは異なる場合も良くあります。いくつかの指定で
 gnuplot がバイトをどのように扱うかを制御できます。例えば
 `endian=little` は、バイナリファイルを、そのバイトの並びが小さい桁から
 大きい桁へ並んでいると見なされます。オプションは以下のものが使えます。

               little:  小さい桁から大きな桁へ並ぶ
                  big:  大きな桁から小さな桁へ並ぶ
              default:  compiler と同じエンディアンと見なす
          swap (swab):  エンディアンを変更する (おかしいようならこれを
                        使ってみてください)

 gnuplot は、コンパイル時にオプションが指定されていれば、"middle" (や
 "pdp") エンディアンもサポートできます。
4 filetype
?binary filetype
?filetype
 gnuplot は、いくつか標準的なバイナリファイル形式については必要な情報を
 そのファイルから抜き出すことができます。例えば "format=edf" は ESRF ヘ
 ッダーファイル形式のファイルとして読み込みます。現在サポートしているフ
 ァイル形式については、`show datafile binary filetypes` で見てください。

 特別なファイル形式として `auto` があり、この場合 gnuplot はバイナリフ
 ァイルの拡張子が、サポートされている形式の標準的な拡張子であるかをチェ
 ックします。

 コマンドラインキーワードはファイルから読み取る設定を上書きするのに使わ
 れ、ファイルから読み取る設定はデフォルトの設定を上書きします。以下参照:
 `set datafile binary`。
5 avs
?binary filetype avs
?filetype avs
?avs
 `avs` は、自動的に認識される画像イメージに対するバイナリファイルの型の
 一つです。AVS は非常単純なフォーマットで、アプリケーション間でやりとり
 するのに最も適しています。これは、2 つの long (xwidth と ywidth) と、
 その後続くピクセルの列から成り、その各ピクセルは alpha/red/green/blue
 の 4 バイトから成ります。
5 edf
?binary filetype edf
?filetype edf
?edf
?filetype ehf
?ehf
 `edf` は、自動的に認識される画像イメージに対するバイナリファイルの型の
 一つです。EDF は ESRF データフォーマット (ESRF Data Format) を意味して
 いて、それは edf と ehf の両方の形式をサポートしています (後者は ESRF
 Header Format)。画像の使用に関する詳しい情報は以下で見つかるでしょう:

   http://www.edfplus.info/specs
5 png
?binary filetype png
?binary filetype gif
?binary filetype jpeg
?filetype png
?filetype gif
?filetype jpeg
 gnuplot が png/gif/jpeg 出力用に libgd ライブラリを使うようにインスト
 ールされている場合、それらの画像形式をバイナリファイルとして読み込むこ
 ともできます。以下のような明示的なコマンド
       plot 'file.png' binary filetype=png
 を使うこともできますし、あらかじめ以下のように設定して、拡張子から自動
 的に画像形式を自動的に認識させることもできます。
       set datafile binary filetype=auto
4 keywords
?binary keywords
 以下のキーワード (keyword) は、バイナリファイルから座標を生成するとき
 にのみ適用されます。つまり、binary array, matrix, image の個々の要素を
 特定の x,y,z の位置への配置の制御のためのものです。
5 scan
?binary keywords scan
 gnuplot がバイナリファイルをどのように走査するか、ということと実際の描
 画で見られる軸の方向との間の関係については多くの混乱が起こり得ます。そ
 の混乱を減らすには、gnuplot はバイナリファイルを "常に" 点/線/面、また
 は速い/普通/遅い、と走査すると考えるといいでしょう。このキーワードは
 gnuplot に、その走査の方向を描画内のどの座標方向 (x/y/z) に割り当てる
 かを指定します。指定は 2 つ、または 3 つの文字の並びで表現し、最初の文
 字が点に、次の文字が線に、3 つ目の文字が面に対応します。例えば、
 `scan=yx` は、最も速い走査 (点の選択) は y 方向に対応し、普通の速さの
 走査 (線の選択) が x 方向に対応することを意味します。

 描画モードが `plot` の場合、指定には x と y の 2 つの文字を使うことが
 でき、`splot` に対しては x, y, z の 3 つの文字を使うことができます。

 割り当てに関しては、点/線/面から直交座標方向へのみに制限する内部事情は
 別にありません。この理由で、円柱座標への割り当てのための指定子も用意さ
 れていて、それらは直交座標の x, y, z に類似した形で t (角度), r, z と
 なっています。
5 transpose
?binary keywords transpose
 `scan=yx`、または `scan=yxz` と同じです。
5 dx, dy, dz
?binary keywords dx
?binary keywords dy
?dx
?dy
 gnuplot が座標を生成する場合、その間隔はこれらのキーワードで指定された
 ものが使用されます。例えば `dx=10 dy=20` は x 方向に 10、y 方向に 20
 の間隔で標本化されたことを意味します。`dy` は `dx` がなければ使えませ
 ん。同様に `dz` は `dy` がなければ使えません。もしデータの次元が指定し
 たキーワードの次元よりも大きい場合、残りの次元方向の間隔は、指定された
 最も高い次元のものと同じ値が使用されます。例えば画像がファイルから読み
 込まれ、`dx=3.5` のみ指定された場合、gnuplot は x 方向の間隔も y 方向
 の間隔も 3.5 を使用します。

 以下のキーワードも座標の生成時にのみ適用されます。しかし、以下のものは
 matrix バイナリファイルにも使われます。
5 flipx, flipy, flipz
?binary keywords flipx
 バイナリデータファイルの走査方向が gnuplot の走査方向と一致しないこと
 がたまにあります。これらのキーワードは、それぞれ x, y, z 方向のデータ
 の走査方向を逆向きにします。
5 origin
?binary keywords origin
 gnuplot は転置 (transpose) や反転 (flip) において座標を生成する場合、
 常に配列の左下の点が原点になるようにします。すなわち、データが、転置や
 反転の行なわれた後の直交座標系の第 1 象限に来るようにします。

 配列をグラフのその他の場所に配置したい場合、`origin` キーワードで指定
 した場所に gnuplot は配列の左下の点を合わせます。その指定は、`plot` で
 は 2 つの座標の組、`splot` では 3 つの座標の組を指定してください。例え
 ば `origin=(100,100):(100,200)` は、一つのファイルに含まれる 2 つのデ
 ータに対する指定で、2 次元の描画に対する指定です。2 つ目の例として
 `origin=(0,0,3.5)` をあげると、これは 3 次元描画用の指定です。
5 center
?binary keywords center
?keywords center
 `origin` と似ていますが、このキーワードは、配列の中心がこのキーワード
 で指定した点になるように配置します。例えば `center=(0,0)` のようにしま
 す。配列のサイズが `Inf` のときは center は適用されません。
5 rotate
?binary keywords rotate
?keywords rotate
 転置 (transpose) と反転 (flip) コマンドは座標の生成と座標軸の方向にあ
 る種の柔軟性を与えてくれます。しかし、角度に関する完全な制御は、2 次元
 の回転角を記述した回転角ベクトルを与えることにより行なうことが可能にな
 ります。

 キーワード `rotate` は, `plot`, `splot` の両方で、2 次元面に対して適用
 されます。回転は座標平面の正の角度に関して行なわれます。

 角度は、ラジアン単位ですが、pi や degrees の倍数としてのラジアンでも表
 現できます。例えば、`rotate=1.5708`, `rotate=0.5pi`, `rotate=90deg` は
 すべて同じ意味です。

 `origin` が指定された場合、回転は平行移動の前に左下の点を中心にして行
 なわれます。それ以外では回転は配列の中心 (`center`) に関して行なわれま
 す。
5 perpendicular
?binary keywords perpendicular
 `splot` に関して回転ベクトルの設定が、ベクトルを表現する 3 つの数字の
 組を指定することで実装されていて、このベクトルは 2 次元の xy 平面に対
 して向き付けられた法線ベクトル (perpendicular) を表しています。もちろ
 んそのデフォルトは (0,0,1) です。rotate と perpendicular の両方を指定
 することにより、3 次元空間内で無数の方向へデータを向き付けられることに
 なります。

 まず最初に 2 次元の回転が行なわれ、その次に 3 次元の回転が行なわれます。
 つまり、R' をある角による 2 x 2 の回転行列とし、P を (0,0,1) を
 (xp,yp,zp) へ子午線方向に回転させる 3 x 3 の行列とし、R' を左上の部分
 行列として持ち 3,3 成分が 1 でその他の成分が 0 であるような行列 (つま
 り z 軸周りの回転行列) とすれば、この変換を表す行列による関係式は
 v' = P R v となります。ここで、v はデータファイルから読み込まれた
 3 x 1 の位置ベクトルです。ファイルのデータが 3 次元的なものでない場合
 は、論理的なルールが適用されて 3 次元空間内のデータと見なされます (例
 えば、通常は z 座標は 0 とされ、xy 平面内の 2 次元データと見なされます)。
3 データ (data)
?commands plot datafile
?plot datafile
?data-file
?datafile
?data
?file
 ファイルに納められた離散的なデータは、`plot` コマンドライン上で、その
 データファイル名 (<datafile>) を単一引用符または二重引用符で囲んで指定
 することによって表示できます。

 書式:
       plot '<file_name>' {binary <binary list>}
                          {{nonuniform} matrix}
                          {index <index list> | index "<name>"}
                          {every <every list>}
                          {skip <number-of-lines>}
                          {using <using list>}
                          {smooth <option>}
                          {volatile} {noautoscale}

 修正子の `binary`, `index`, `every`, `skip`, `using`, `smooth` は、そ
 れぞれに分けて説明します。簡単に言うと、`binary` はデータ列をバイナリ
 ファイルから取得できるようにし、`index` はマルチデータ集合ファイルから
 どのデータ集合を表示するのかを選び、`every` が、一つのデータ集合からど
 の点を表示するのかを選び、`using` は一行からどの列を解釈するのかを決定
 し、そして `smooth` が、単純な補間と近似を行います。`splot` もよく似た
 書式を使いますが、`smooth` オプションはサポートしていません。

 キーワード `noautoscale` は、自動的に軸の範囲が決定される機能が有効で
 ある場合に、この描画を構成するデータ点については、それを無視させる (自
 動縮尺機能の計算対象から外す) ようにします。

 テキストデータファイル:

 データファイルは、一行につき少なくとも一つのデータ点を含む必要がありま
 す (`using` は一行から一つのデータポイントを選ぶことができます)。`#`
 (VMS では `!`) で始まる行は、コメントとして扱われ、無視されます。各デ
 ータ点は、(x,y) の組を表します。エラーバー、または折れ線表示付エラーバ
 ーの `plot` では (以下参照: `errorbars`, `errorlines`)、各データ点は、
 (x,y,ydelta), (x,y,ylow,yhigh), (x,y,xdelta), (x,y,xlow,xhigh),
 (x,y,xlow,xhigh,ylow,yhigh) のいずれかを意味します。

 どんな場合でも、書式の指定子が `using` オプションによって与えられてい
 なければ、データファイルの各行の数字は、ホワイトスペース (一つまたは複
 数の空白かタブ) によって区切られている必要があります。このホワイトスペ
 ースは、各行を列の項目に区切ります。ただし、二重引用符で囲まれたホワイ
 トスペースは列の勘定では無視され、よって次のようなデータ行は 3 列、と
 見なされます:
       1.0 "second column" 3.0

 データは、指数部に e, E の文字をつけた指数表記で書かれていても構いませ
 ん。コマンド `set datafile fortran` が有効な場合は、fortran の指数指定
 子 d, D, q, Q も使えます。

 必要であるのはただ一つの列 (y の値) のみです。もし x の値が省略された
 ら、`gnuplot` はそれを 0 で始まる整数値として用意します。

 データファイルにおいて、ブランク行 (空白と改行、復帰以外に文字を含まな
 い行) は重要です。

 1 行のブランク行は、`plot` に不連続を指示します; ブランク行によって区
 切られた点は線で結ばれることはありません (line style で書かれている場
 合には)。

 2 行のブランク行は、別々のデータ集合間の区切りを示します。以下参照:
 `index`。

 もし autoscale の状態であれば (以下参照: `set autoscale`)、軸は全ての
 データポイントを含むように自動的に引き伸ばされて、目盛りが書かれる状態
 ならば全ての目盛りがマークされます。これは、2 つの結果を引き起こします:
 i) `splot` では、曲面の角は底面の角に一致していないことがあります。こ
 の場合、縦の線は書かれることはありません。ii) 2 種類の軸での、同じ x
 の範囲のデータの表示の際、もし x2 の軸に対する目盛りが書かれていない場
 合は、x 座標があっていないことがあります。これは x 軸 (x1) は全ての目
 盛りにまで自動的に引き延ばされるのに対し、x2 軸はそうではないからです。
 次の例でその問題を見ることができます:

       reset; plot '-', '-' axes x2y1
       1 1
       19 19
       e
       1 1
       19 19
       e

 これを避けるには、`set autoscale` コマンドの `fixmin`/`fixmax` オプシ
 ョンを使うことができます。これは、次の目盛りの刻みに合うように軸の範囲
 を自動的に拡張する機能を無効にします。

 ラベルの座標と文字列もデータファイルから読み込むことができます (以下参
 照: `labels`)。

4 every
?commands plot datafile every
?plot datafile every
?plot every
?data-file every
?datafile every
?every
 キーワード `every` は、描画するデータをデータ集合から周期的にサンプリ
 ングすることを可能にします。

 ここでは 「ポイント」はファイル中の 1 つの行によって定義されるデータと
 し、ここでの「ブロック」は「データ・ブロック」(以下参照: `glossary`)
 と同じものを意味することとします。

 書式:
          plot 'file' every {<ポイント増分>}
                            {:{<ブロック増分>}
                              {:{<開始ポイント>}
                                {:{<開始ブロック>}
                                  {:{<終了ポイント>}
                                    {:<終了ブロック>}}}}}

 描画するデータポイントは、<開始ポイント> から <終了ポイント> まで <ポ
 イント増分> の増加で選び、ブロックは <開始ブロック> から <終了ブロック>
 まで <ブロック増分> の増加で選びます。

 各ブロックの最初のデータは、ファイル中の最初のブロックと同じように、
 「0 番」と数えます。

 プロットできない情報を含む行もカウントすることに注意して下さい。

 いくつかの数字は省略できます; 増分のデフォルトは 1 、開始の値は最初の
 ポイントか最初のブロック、そして終了の値は最後のポイントか最後のブロッ
 クに設定します。`every` のオプションが ':' で終わるのは許されていませ
 ん。`every` を指定しなければ、全ての行の全てのポイントをプロットします。

 例:
        every :::3::3   # 4 番目のブロックだけ選びます (0 番が最初)
        every :::::9    # 最初の 10 ブロックを選びます
        every 2:2       # 1 つおきのブロックで 1 つおきのポイントを選び
                        # ます
        every ::5::15   # それぞれのブロックでポイント 5 から 15 までを
                        # 選びます

 参照:
^ <a href="http://www.gnuplot.info/demo/simple.html">
 単純な plot デモ (simple.dem)
^ </a>
 ,
^ <a href="http://www.gnuplot.info/demo/surface1.html">
 非媒介変数モードでの splot デモ
^ </a>
 ,
^ <a href="http://www.gnuplot.info/demo/surface2.html">
 媒介変数モードでの splot デモ
^ </a>
 。
4 データファイルの例 (example)
?commands plot datafile example
?plot datafile example
?plot example
?datafile example
?data-file example
?example
 次の例は、ファイル "population.dat" 中のデータと理論曲線を図にするもの
 です。

       pop(x) = 103*exp((1965-x)/10)
       set xrange [1960:1990]
       plot 'population.dat', pop(x)

 ファイル "population.dat" は次のようなファイルです。

       # Gnu population in Antarctica since 1965
          1965   103
          1970   55
          1975   34
          1980   24
          1985   10

=skip
 binary の例:

       # 2 つの float の値を選択し (2 つ目の値は無意味)、一方を読み捨て、
       # 一つおきの float 値を無限に長く続く 1 次元データとして使用
       plot '<file_name>' binary format="%float%*float" using 1:2 with lines

       # データファイルから座標を生成するのに必要な情報をすべてそのヘッ
       # ダに含んでいる EDF ファイルの場合
       plot '<file_name>' binary filetype=edf with image
       plot '<file_name>.edf' binary filetype=auto with image

       # 3 つの符号なし文字型整数値 (unsigned char) を生の RGB 画像の色
       # 成分として選択し、y 方向は反転させ画像の方向を座標平面上で変更
       # する (左上が原点になるように)。ピクセルの間隔も指定し、ファイ
       # ルには 2 つの画像が含まれていて、そのうち一つは origin で平行
       # 移動する。
       plot '<file_name>' binary array=(512,1024):(1024,512) format='%uchar' \
            dx=2:1 dy=1:2 origin=(0,0):(1024,1024) flipy u 1:2:3 w rgbimage

       # 4 つの別のデータからなり、座標情報もデータファイルに含まれてい
       # る。ファイルは gnuplot が実行されているシステムとは異なるエン
       # ディアンで生成されている。
       splot '<file_name>' binary record=30:30:29:26 endian=swap u 1:2:3

       # 同じ入力ファイルで、今回は 1 番目と 3 番目のレコードをスキップ
       splot '<file_name>' binary record=30:26 skip=360:348 endian=swap u 1:2:3


 以下参照: `binary matrix`。
4 index
?commands plot datafile index
?plot datafile index
?plot index
?data-file index
?datafile index
?index
 キーワード `index` は、描画用に複数のデータ集合を持つファイルから、特
 定のデータ集合を選択することを可能にします。

 書式:
       plot 'file' index { <m>{:<n>{:<p>}} | "<name>" }

 データ集合は 2 行の空白で分離されています。`index <m>` は <m> 番目の集
 合だけを選択します; `index <m>:<n>` は <m> から <n> までのデータ集合の
 選択; `index <m>:<n>:<p>` は、<m>, <m>+<p>, <m>+2<p>, など、<p> おきの
 集合を選択し、集合 <n> で終了します。C 言語の添字 (index) の付け方に従
 い、index 0 はそのファイルの最初のデータ集合を意味します。大きすぎる
 index の指定にはエラーメッセージが返されます。<p> を指定し、<n> を空欄
 にした場合、<p> 毎のデータをファイルの最後まで読み込みます。`index` を
 指定しない場合は、ファイルのデータ全体を単一のデータ集合として描画しま
 す。

 例:
       plot 'file' index 4:5

 ファイルの各点に対して、それが含まれるデータ集合の index 値は、疑似列
 `column(-2)` で利用できます。これは、以下に見るように、そのファイル内
 の個々のデータ集合を区別する別の方法を提供します。これは、描画用に 1
 つのデータ集合の選択しかしない場合は `index` コマンドよりも不恰好です
 が、個々のデータ集合に異なる属性を割り当てたい場合にはとても便利です。
 以下参照: `pseudocolumns`, `lc variable`。

 例:
       plot 'file' using 1:(column(-2)==4 ? $2 : NaN)        # とても不恰好
       plot 'file' using 1:2:(column(-2)) linecolor variable # とても便利 !

 `index '<name>'` は、データ集合を名前 '<name>' で選択します。名前はコ
 メント行に書いてデータ集合に割り当てます。コメント文字とそれに続く空白
 をそのコメント行から取り除いて、その結果が <name> から始まっていれば、
 それに続くデータ集合に <name> という名前がつけられて、それを指定できま
 す。

 例:
       plot 'file' index 'Population'

 <name> で始まるすべてのコメントがそれに続くデータ集合の名前になること
 に注意してください。問題を避けるために、例えば '== Popolation ==' や
 '[Population]' などの命名法を選択すると便利でしょう。

^ <p>以下の Web ページも参照:
^ <a href="http://www.gnuplot.info/demo/multimsh.html">
^ index を使った splot のデモ
^ </a></p>
4 インラインデータ (inline data)
?inline data
?inline
?datablocks
 gnuplot のコマンド入力の中にデータを埋め込む仕組みは 2 種類用意されて
 います。まず、特殊ファイル名 '-' が plot コマンド中に与えると、その
 plot コマンド以下に続く行がインラインデータと解釈されます。以下参照:
 `special-filenames`。この方法で提供されるデータは、その plot コマンド
 で一度しか使用できません。

 もう一つは、ヒアドキュメントとして名前付きのデータブロックを定義する方
 法です。その名前付きのデータは残るので、複数の plot コマンドで参照でき
 ます。例:
      $Mydata << EOD
      11 22 33 first line of data
      44 55 66 second line of data
      # データファイル同様コメントも機能する
      77 88 99
      EOD
      stats $Mydata using 1:3
      plot $Mydata using 1:3 with points, $Mydata using 1:2 with impulses

 データブロック名は、他の変数と区別するために、最初の文字を $ にする必
 要があります。データの終わりの区切り (上の例では EOD) は、任意のアルフ
 ァベット、数字からなる文字列で構いません。

 コマンド `undefine` を使えば、保存した名前付きデータブロックを削除でき
 ます。`undefine $*` は、すべての名前付きデータブロックを一度に削除しま
 す。
4 skip
?plot datafile skip
?data-file skip
?datafile skip
?skip
 キーワード `skip` は、プログラムにテキストデータファイル (バイナリデー
 タは不可) の先頭の数行をスキップさせます。スキップする行は、`every` キ
 ーワード処理での行数にはカウントしません。`every ::N` はそのファイル内
 のすべてのデータブロックの先頭をスキップしますが、`skip N` はそのファ
 イルの先頭部分の行のみをスキップすることに注意してください。バイナリデ
 ータファイルに適用される同様のオプションについては、以下参照:
 `binary skip`。
4 smooth
?commands plot datafile smooth
?plot datafile smooth
?plot smooth
?data-file smooth
?datafile smooth
?smooth
 `gnuplot` は、データの補間と近似を行う汎用的なルーチンをいくつか持っ
 ています。これ `smooth` オプションの中にグループ化されています。より
 洗練されたデータ処理をしたければ、外部においてデータの前処理をするか、
 または適切なモデルで fit を使うのがいいでしょう。

 書式:
       smooth {unique | frequency | cumulative | cnormal | kdensity {bandwidth}
                      | csplines | acsplines | mcsplines | bezier | sbezier
                      | unwrap}

 `unique`, `frequency`, `cumulative`, `cnormal` は、データを単調に揃え
 た後でそれらを plot します。`unwrap` は、データがπより大きなジャンプ
 をしないように、2πの整数倍を加える操作をします。他のルーチンはいずれ
 も、データの両端の点の間を結ぶ、ある連続曲線の係数を決定するためにデー
 タを使います。この曲線は、関数として同じ方法で描画されます。すなわち、
 それらの値は x 座標に沿う同じ幅の区間ごとに選ばれ (以下参照:
 `set samples`)、それらの点を線分でつなぐことにより (もし line style が
 選ばれているのならば) 描画されます。

 もし `autoscale` の状態であれば、描画範囲はグラフの境界線の中に曲線が
 収まるように計算されます。

 もし `autoscale` の状態でなく、smooth のオプションが `acsplines` か
 `csplines` であれば、生成する曲線の標本化は、入力データを含むような x
 の範囲と、`set xrange` などで定義される固定された横座標の範囲の共通部
 分の上で行なわれます。

 選択されたオプションを適用するのにデータの点数が少なすぎる場合は、エ
 ラーメッセージが表示されます。その最小のデータ数は `unique` と
 `frequency` では 1 つ、`acsplines` では 4 つ、他のオプションでは 3 つ
 です。

 `smooth` オプションは、関数の描画のときには無視されます。
5 acsplines
?commands plot datafile smooth acsplines
?plot datafile smooth acsplines
?data-file smooth acsplines
?datafile smooth acsplines
?plot smooth acsplines
?plot acsplines
?smooth acsplines
?acsplines
 `acsplines` オプションは「自然な滑らかなスプライン」でデータを近似しま
 す。データが x に関して単調にされた後 (以下参照: `smooth unique`)、1
 つの曲線が、いくつかの 3 次多項式の一部分により区分的に構成されます。
 それらの 3 次式の係数は、個々のデータ点に合うように求められますが、
 using 指定によって 3 列目の値が与えられた場合は、その値で個々の点に重
 みをつけます。デフォルトは、以下と同じです:
       plot 'data-file' using 1:2:(1.0) smooth acsplines

 性質上、重みの絶対的な大きさは、曲線を構成するのに使われる区分の数を決
 定します。もし重みが大きければ、個々のデータの影響は大きくなり、そして
 その曲線は、隣り合う点同志を自然 3 次スプラインでつないで得られるもの
 に近づきます。もし重みが小さければ、その曲線はより少ない区分で構成され、
 それによってより平滑的になります。その最も極端な場合はただ 1 つの区分
 からなる場合であり、それは全てのデータに重みの付き線形最小 2 乗近似に
 よって作られます。誤差の立場から言えば、平滑さの重みは、その曲線に対す
 る「平滑化因子」によって分割された各点への、統計的な重みと見ることがで
 きます。それにより、そのファイル中の (標準的な) 誤差は平滑さの重みとし
 て使うことができます。

 例:
       sw(x,S)=1/(x*x*S)
       plot 'data_file' using 1:2:(sw($3,100)) smooth acsplines
5 bezier
?commands plot datafile smooth bezier
?plot datafile smooth bezier
?plot smooth bezier
?data-file smooth bezier
?datafile smooth bezier
?plot bezier
?smooth bezier
?bezier
 `bezier` オプションは、n 次 (データ点の個数) のベジェ曲線でデータを近
 似します。この曲線は両端の点をつなぎます。
5 csplines
?commands plot datafile smooth csplines
?plot datafile smooth csplines
?plot smooth csplines
?data-file smooth csplines
?datafile smooth csplines
?plot csplines
?smooth csplines
?csplines
 `csplines` オプションはデータを単調に揃えた後で (以下参照:
 `smooth unique`) 自然 3 次スプライン曲線で引き続く点をつなぎます。
5 mcsplines
?commands plot datafile smooth mcsplines
?plot datafile smooth mcsplines
?plot smooth mcsplines
?data-file smooth mcsplines
?datafile smooth mcsplines
?plot mcsplines
?smooth mcsplines
?mcsplines
 `mcsplines` オプションは、平滑化された関数が元の点の単調性と凸性を保存
 するような 3 次スプライン曲線で引き続く点をつなぎます。
 FN Fritsch & RE Carlson (1980) "Monotone Piecewise Cubic Interpolation",
 SIAM Journal on Numerical Analysis 17: 238-246.
5 sbezier
?commands plot datafile smooth sbezier
?plot datafile smooth sbezier
?plot smooth sbezier
?data-file smooth sbezier
?datafile smooth sbezier
?plot sbezier
?smooth sbezier
?sbezier
 `sbezier` オプションは、最初にデータを単調に揃え (以下参照: `unique`)
 そして `bezier` アルゴリズムを適用します。
5 unique
?commands plot datafile smooth unique
?plot datafile smooth unique
?plot smooth unique
?data-file smooth unique
?datafile smooth unique
?plot unique
?smooth unique
?unique
 `unique` オプションは、データを x 方向に単調にします。同じ x を持つデ
 ータ点は y の値を平均して一つの点で置き換えます。そしてその結果として
 得られる点を線分で結びます。
5 unwrap
?commands plot datafile smooth unwrap
?plot datafile smooth unwrap
?plot smooth unwrap
?data-file smooth unwrap
?datafile smooth unwrap
?plot unwrap
?smooth unwrap
?unwrap
 `unwrap` オプションは、2 つの続く点がπを越える違いが出ないようにデー
 タを修正します: y の値がその範囲を越えるような点に対しては、前の点との
 差がπの範囲に収まるように 2πの整数倍を加えます。この操作は、巻き戻し
 を持つ系の値を時間的に連続にさせるのに有用です。
5 frequency
?commands plot datafile smooth frequency
?plot datafile smooth frequency
?plot smooth frequency
?data-file smooth frequency
?datafile smooth frequency
?plot frequency
?smooth frequency
?frequency
=histogram
 オプション `frequency` は、データを x に関して単調にします。x 座標が同
 じ点は、それらの y の値の合計を y の値として持つ一つの点に置き換えます。
 多くの値のデータのヒストグラムを一定の階級幅 (bin) で描くには、それら
 の y の値を 1.0 にして、それでその和が同じ階級幅内の点の個数を表すよう
 にします:
 例:
      binwidth = <適当な値>  # x の値の各階級幅
      bin(val) = binwidth * floor(val/binwidth)
      plot "datafile" using (bin(column(1))):(1.0) smooth frequency
 以下も参照。
^ <a href="http://www.gnuplot.info/demo/smooth.html">
 smooth.dem
^ </a>
5 cumulative
?commands plot datafile smooth cumulative
?plot datafile smooth cumulative
?plot smooth cumulative
?data-file smooth cumulative
?datafile smooth cumulative
?plot cumulative
?smooth cumulative
?cumulative
 オプション `cumulative` は、データを x に関して単調にします。x 座標が
 同じ点は、それ以下の x の値を持つすべての点 (すなわち現在のデータ点の
 左側の点) に対する y の値の累積的な合計を y の値として持つ一つの点に置
 き換えられます。これは、データから累積分布関数を得るのに利用できます。
 以下も参照。
^ <a href="http://www.gnuplot.info/demo/smooth.html">
 smooth.dem
^ </a>
5 cnormal
?commands plot datafile smooth cnormal
?plot datafile smooth cnormal
?plot smooth cnormal
?data-file smooth cnormal
?datafile smooth cnormal
?plot cnormal
?smooth cnormal
?cnormal
 オプション `cnormal` は、x に関して単調で、y の値は [0:1] に正規化され
 たデータを生成します。同じ x の値を持つ点が複数ある場合は、それより小
 さい x の値を持つすべてのデータ点 (すなわち現在のデータ点よりも左にあ
 る点) の累積和を、すべての y の値の和で割った値を y の値として持つよう
 な一点のデータに置き変えられます。これは、データから正規化された累積分
 布関数を得るのに使えます (特に標本点数の異なるデータ集合を比較するのに
 有用です)。
 以下も参照。
^ <a href="http://www.gnuplot.info/demo/smooth.html">
 smooth.dem
^ </a>

5 kdensity
?commands plot datafile smooth kdensity
?plot datafile smooth kdensity
?plot smooth kdensity
?data-file smooth kdensity
?datafile smooth kdensity
?plot kdensity
?smooth kdensity
?kdensity
 オプション `kdensity` は、ガウス核を用いた、ランダム選択点の核密度評価
 (それは滑らかなヒストグラムになります) を描画する方法の一つです。ガウ
 ス核が第 1 列の各点の位置に置かれ、これらのガウス核すべての和が関数と
 して描画されます。2 列目の値は、ガウス核の重みとして使用されます。正規
 化されたヒストグラムを得るには、これを 1/(点の個数) とすべきです。デフ
 ォルトでは、gnuplot は正規分布のデータに対して最適となるようなバンド幅
 を計算し使用します。
      default_bandwidth = sigma * (4/3N) ** (0.2)
 これは通常はとても保守的で、すなわち幅広いバンド幅です。バンド幅は、明
 示的に指定することもできます。
      plot $DATA smooth kdensity bandwidth <value> with boxes
 前の描画で使用されたバンド幅は、変数 GPVAL_KDENSITY_BANDWIDTH に保存さ
 れます。
4 特別なファイル名 (special-filenames)
?commands plot datafile special-filenames
?plot datafile special-filenames
?plot special-filenames
?datafile special-filenames
?special-filenames
 特別な意味を持つファイル名として、次のものがあります: '', '-', '+',
 '++'

 空のファイル名 '' は、同じ plot コマンド上で、直前の入力ファイルを再び
 使用することを gnuplot に指示します。よって、同じ入力ファイルの 2 つの
 データ列を描画するには以下のようにします:

       plot 'filename' using 1:2, '' using 1:3

 '+' と '++' という特別なファイル名は、`using` 指定の全体と描画スタイル
 にインライン関数を使えるようにするための仕組みです。通常、関数描画はサ
 ンプル点毎に単一の y (または z) の値しか持てません。しかし疑似ファイル
 '+' はそれがあたかも実際の入力ファイルであるように、`using` 指定による
 1 列目の値を標本点として扱い、さらに追加の列の値を指定することも可能で
 す。返される標本点の数は、`set samples` で制御できます。標本点は、デフ
 ォルトでは x の範囲全体に渡って取られますが、'+' の直前にそれとは独立
 な標本範囲を指定することもできます。以下参照: `plot sampling`。
 例:

       plot '+' using ($1):(sin($1)):(sin($1)**2) with filledcurves
       plot $MYDATA, [sample=5:25] '+' using (sample):(f(sample)) with lines

 同様に、疑似ファイル '++' は、x 方向は `set samples` で制御される点の
 数、y 方向は `set isosamples` で制御される点の数の、標準的な [x,y] 座
 標の格子を生成する 2 列のデータを返します。媒介変数モードではサンプル
 点は x と y に関してではなく、u と v に関して取られます。'++' の描画の
 前に、xrange と yrange (または urange と vrange) を設定する必要があり
 ます。例:

       splot '++' using 1:2:(sin($1)*sin($2)) with pm3d
       plot '++' using 1:2:(sin($1)*sin($2)) with image

 `'-'` という特別なファイル名は、データがインラインであることを指示し
 ます。すなわち、データをコマンドの後に続けて指定します。このときはデ
 ータのみがコマンドに続き得ます。よって、`plot` コマンドに対するフィル
 ター、タイトル、ラインスタイルといったオプションは、`plot` のコマンド
 ラインの方に書かないといけません。これは、unix シェルスクリプトにおけ
 る << (ヒアドキュメント)、あるいは VMS DCL における $DECK と同様です。
 そのデータは、それらがファイルから読み込まれたかのように、1 行につき
 1 つずつのデータ点が入力されます。そしてデータの終りは、1 列目の始めに
 文字 "e" を置くことで指示します。`using` オプションをこれらのデータに
 適用することは可能です。ある関数を通しデータをフィルターすることに使う
 のは意味があるでしょうが、列を選ぶのに使うことは多分意味がないでしょう。

 `'-'` は、データとコマンドを一緒に持つことが有用である場合のためにあ
 ります。例えば、`gnuplot` があるフロントアプリケーションのサブプロセ
 スとして起動される場合などがこれにあたります。例として、デモンストレ
 ーションでこの機能を使うものがあるでしょう。`index` や `every` のよう
 な `plot` のオプションが与えられていると、それらはあなたに使われるこ
 とのないデータを入力する事を強要します。次の例を見てください。

       plot '-' index 0, '-' index 1
       2
       4
       6


       10
       12
       14
       e
       2
       4
       6


       10
       12
       14
       e

 これは、実際に動作しますが、

       plot '-' , '-'
       2
       4
       6
       e
       10
       12
       14
       e

 とタイプする方が楽でしょう。

 もし、`replot` コマンドで `'-'` を使うなら、あなたは 1 度以上データを
 入力する必要があるでしょう。以下参照: `replot`, `refresh`。

 空のファイル名 ('') は、直前のファイル名が再び使われることを指示しま
 す。これは、

       plot 'ある/とても/長い/ファイル名' using 1:2, '' using 1:3, '' using 1:4

 のようなときに便利です。(もし同じ plot コマンド上で、`'-'` と `''` の
 両方を使用すると、上の例にあるように、インラインデータの 2 つの集合を
 与える必要があります。)

 popen 関数を持っているシステム上では、データファイルは、'<' で始まるフ
 ァイル名によって、シェルコマンドからパイプ入力することができます。例え
 ば

       pop(x) = 103*exp(-x/10)
       plot "< awk '{print $1-1965, $2}' population.dat", pop(x)

 は、最初の人口の例と同じ情報を描画します。ただし、x 座標は 1965 年か
 らの経過年を表すようになります。この例を実行するときは、上のデータフ
 ァイルのコメント行をすべて削除しなければなりませんが、または上のコマ
 ンドの最初の部分を次のように変えることもできます (コンマに続く部分):

       plot "< awk '$0 !~ /^#/ {print $1-1965, $2}' population.dat"

 このアプローチは最も柔軟性がありますが、`using` キーワードを用いた単純
 なフィルタリングで行うことも可能です。

 fdopen() 関数を持つシステムでは、データを、ファイルかパイプに結びつけ
 られた任意のファイルデスクリプタから読み込むことができます。`n` 番のフ
 ァイルデスクリプタから読み込むには、`'<&n'` としてください。これにより、
 1 回の POSIX shell からの呼び出しの中で、複数のデータファイルからのパ
 イプ入力が容易に行えるようになります:

       $ gnuplot -p -e "plot '<&3', '<&4'" 3<data-3 4<data-4
       $ ./gnuplot 5< <(myprogram -with -options)
       gnuplot> plot '<&5'
4 thru
?commands plot datafile thru
?plot datafile thru
?plot thru
?data-file thru
?datafile thru
?thru
 キーワード `thru` は非推奨です。

 古い書式:
       plot 'file' thru f(x)

 現在の書式:
       plot 'file' using 1:(f($2))
4 using
?commands plot datafile using
?plot datafile using
?plot using
?data-file using
?datafile using
?using
 最もよく使われるデータファイルの修飾子は `using` で、これは入力ファイ
 ルのどの行を描画するのかを指示します。

 書式:
       plot 'file' using <entry> {:<entry> {:<entry> ...}} {'format'}

 format を指定すると、それを C ライブラリ関数 'scanf' に適用してデータ
 ファイルの各行を読みます。そうでなければ、各行はホワイトスペース (スペ
 ースやタブ) で区切られたデータの列 (フィールド) からなるとみなしますが
 以下も参照: `datafile separator`。

 各 <entry> は、入力ファイルの一つのフィールドを選択するための単なる列
 の番号か、一つのデータ集合の最初の行の列のラベルに一致する文字列、カッ
 コで囲まれた数式、xticlabels(2) のようにカッコで囲まない特別な関数、の
 いずれかです。

 そのエントリがカッコで囲まれた数式の場合、N 列目の値を指定するのに関数
 column(N) を使用できます。つまり、column(1) は読み込まれた最初の項目を
 参照し、column(2) は次の項目、といった具合です。column(1), column(2),
 ... の略記として、特別な記号 $1, $2, ... を使用できます。関数
 `valid(N)` で、N 番目の列が有効な数字であるかどうかテストできます。
=column
=columnhead
 入力ファイルの最初の行の各列に、データの値ではなくラベルを持っている場
 合、このラベルを入力列の特定や plot タイトルに使用できます。関数
 column() は、列番号以外にラベルで入力列を選択できます。例えば、データ
 ファイルが以下のような場合:
       Height    Weight    Age
       val1      val1      val1
       ...       ...       ...
 以下の plot コマンドは同じ意味になります:
       plot 'datafile' using 3:1, '' using 3:2
       plot 'datafile' using (column("Age")):(column(1)), \
                    '' using (column("Age")):(column(2))
       plot 'datafile' using "Age":"Height", '' using "Age":"Weight"

 指定文字列が完全に一致する必要がありますし、大文字小文字も区別します。
 列のラベルを plot タイトルに使うには、`set key autotitle columnhead`
 としてください。

 入力データファイルの 1...N という実際の列に加えて、gnuplot は管理情報
 を持ついくつかの "疑似列" を提供します。例えば、$0 または column(0) は、
 データ集合内のそのデータ行の行番号を返します。以下参照:
 `pseudocolumns`。

 <entry> に何も書かなければ、そのエントリのリストの順にデフォルトの値が
 使われます。例えば `using ::4` は、`using 1:2:4` と解釈されます。

 `using` にただ一つのエントリを指定した場合は、その <entry> は y の値と
 して使われ、データ点の番号 (疑似列 $0) が x として使われます。例えば
 "`plot 'file' using 1`" は "`plot 'file' using 0:1`" と同じ意味です。
 `using` に 2 つのエントリを与えた場合、それらは x, y として使われます。
 さらにエントリを追加して、入力からのデータを利用するような描画スタイル
 の詳細については、以下参照: `set style`, `fit`。

 'scanf' 関数では色々なデータ形式の数値入力が使えますが、`gnuplot` は全
 ての入力データを倍精度浮動小数とみなしますから、`gnuplot` では `%lf`
 が本質的に唯一の数値入力指定、ということになります。
 書式文字列には、少なくとも一つ、そして 7 つ以下の、そのような入力指定子
 を入れる必要があります。
 'scanf' は数と数の間にホワイトスペース、すなわち空白、タブ ("\t")、改行
 ("\n")、または改ページ ("\f") があると期待します。それ以外の入力は明示
 的にスキップされるべきです。

 "\t", "\n", "\f" を使うときは単一引用符よりむしろ二重引用符を使うべき
 であることに注意してください。
5 using の例 (using_examples)
?examples
?commands plot datafile using examples
?plot datafile using examples
?datafile using examples
?using examples
 次の例は、1 番目のデータに対する 2 番目と 3 番目の和の値を plot します。
 書式文字列は、各列データがスペース区切りでなく、コンマ区切りであること
 を指示していますが、同じことが `set datafile separator comma` を指定す
 ることでも可能です。
       plot 'file' using 1:($2+$3) '%lf,%lf,%lf'

 次の例は、より複雑な書式指定でデータをファイル "MyData" から読み込み
 ます。
       plot 'MyData' using "%*lf%lf%*20[^\n]%lf"

 この書式指定の意味は以下の通りです:

       %*lf        数値を無視
       %lf         倍精度浮動小数を読み込む (デフォルトでは x の値)
       %*20[^\n]   20 個の改行以外の文字を無視
       %lf         倍精度浮動小数を読み込む (デフォルトでは y の値)

 3 項演算子 `?:` を使ってデータをフィルタする一つの芸当を紹介します。

       plot 'file' using 1:($3>10 ? $2 : 1/0)

 これは、1 列目のデータに対して、3 列目のデータが 10 以上であるような
 2 列目のデータを plot します。`1/0` は未定義値であり、`gnuplot` は未定
 義の点を無視するので、よって適切でない点は隠されることになります。
 または、あらかじめ定義されている値 NaN を使っても同じことになります。
=NaN

 カッコで始まっていない限りは定数式を列番号として使うことができます。
 例えば `using 0+(複雑な式)` の様なことができます。そして、その数式は、
 カッコでスタートしていなければ数式の値が一度評価され、カッコでスタート
 していれば個々のデータ点を読み込むためにその値が一度評価される、という
 点が重要です。

 時系列フォーマットデータを使っている場合、その時間のデータは複数の列に
 渡らせることができます。その場合、他のデータの開始位置を計算するとき、
 時間のデータに空白が含まれていることに注意してください。例えば、データ
 行の最初の要素がスペースが埋め込まれた時間データであるならば、y の値は
 3 列目の値として指定されるべきです。

 `plot 'file'` と `plot 'file' using 1:2`、そして
 `plot 'file' using ($1):($2)` には微妙な違いがあることに注意してくださ
 い。1) `file` が 1 列と 2 列のデータを持つ行をそれぞれ含んでいるとする
 と、データが 1 列のみの行に対しては、最初のものは x の値を作り出し、2
 番目のものはその行は無視し、3 番目のものはそれを未定義の値として保存し
 ます (折れ線で plot している場合 (plot with lines)、その未定義の点を通
 過する線を結ばないように)。2) 1 列目に文字列を含んでいるような行がある
 場合、最初のものはエラーとして plot を中止しますが、2 番目と 3 番目の
 ものはその不要な行を読みとばします。

 実際、最初に単に

       plot 'file' using 1:2

 と指定することで、大抵の場合どんなにゴミのデータを含む行を持つファイル
 をも plot することが可能になります。しかし、どうしてもデータファイルに
 文字列を残しておきたいならば、そのテキスト行の第一列にコメント文字 (#)
 を置く方がより安全でしょう。
5 疑似列 (pseudocolumns)
?pseudocolumns
?commands plot datafile using pseudocolumns
?plot datafile using pseudocolumns
?datafile using pseudocolumns
?using pseudocolumns
 plot 文の `using` 項目内の式では、入力ファイルに含まれる実際のデータ値
 に加えて管理情報も参照でき、これらは "疑似列" (pseudocolumns) に含まれ
 ています。
       column(0)   データ集合内での各点の順番。順番は 0 から始まり、2
                   行のブランク行でリセットされます。略記 $0 も使用可。
       column(-1)  この番号は 0 から始まり、1 行のブランク行でリセット
                   されます。これは、行列、または格子状データ内のデータ
                   行に対応します。
       column(-2)  複数のデータ集合を持つファイル内の、現在のデータ集合
                   の index 番号。以下参照: `index`。
5 xticlabels
?xticlabels
?using xticlabels
?plot using xticlabels
 軸の刻みの見出し (ticlabel) は文字列関数によって作ることもでき、それは
 通常は引数としてデータ列から取得します。最も単純な形式は、データ列自身
 の文字列としての利用で、xticlabels(N) は xticlabels(stringcolumn(N))
 の省略形として使えます。以下の例は 3 列目の要素を x 軸の刻みの見出しと
 して使用します。

       plot 'datafile' using <xcol>:<ycol>:xticlabels(3) with <plotstyle>

 軸の目盛りの見出しは、任意の描画軸 x,x2,y,y2,z 用に生成できます。
 `ticlabels(<labelcol>)` 指定は、`using` 指定の中で、そのデータの座標指
 定が全て済んだ後に行う必要があります。有効な X,Y[,Z] 座標の組を持つ各
 データ点に対して、xticlabels() に与える文字列値は、それに対応する点の
 x 座標と同じ場所の x 軸の見出しのリストに追加されます。`xticlabels()`
 は `xtic()` と省略することもでき、他の軸に関しても同様です。

 例:

       splot "data" using 2:4:6:xtic(1):ytic(3):ztic(6)

 この例では、x 軸、y 軸の見出しは x,y 座標値とは別の列から取り出されま
 すが、z 軸の見出しは、対応する点の z 座標値から生成されます。

 例:

       plot "data" using 1:2:xtic( $3 > 10. ? "A" : "B" )

 この例は、x 軸の見出しの生成に文字列値関数を使用したもので、データファ
 イルの各点の x 軸の刻みの見出しは、3 列目の値によって "A" か "B" かの
 いずれかとなります。
5 x2ticlabels
?using x2ticlabels
?plot using x2ticlabels
 以下参照: `plot using xticlabels`。
5 yticlabels
?using yticlabels
?plot using yticlabels
 以下参照: `plot using xticlabels`。
5 y2ticlabels
?using y2ticlabels
?plot using y2ticlabels
 以下参照: `plot using xticlabels`。
5 zticlabels
?using zticlabels
?plot using zticlabels
 以下参照: `plot using xticlabels`。
4 volatile
?datafile volatile
?data volatile
?plot datafile volatile
?plot volatile
?volatile
 plot コマンドのキーワード `volatile` は、入力ストリームかファイルから
 以前に読み込んだデータが、再読み込み時には有効ではないことを意味します。
 これは、`replot` コマンドの代わりに、可能な限り `refresh` コマンド
 を使うよう gnuplot に指示します。以下参照: `refresh`。
3 errorbars
?commands plot errorbars
?commands splot errorbars
?plot errorbars
?splot errorbars
?errorbars
 エラーバーは、1 から 4 個の追加されたデータを読む (またはエントリを
 `using` で追加選択する) ことにより、2 次元データの描画において実現され
 ています。これら追加される値は、それぞれのエラーバースタイルで異なった
 形で使われます。

 デフォルトでは、`gnuplot` はデータファイルの各行に以下のような 3 つ、
 4 つ、あるいは 6 つの列があることを期待しています:

       (x, y, ydelta),
       (x, y, ylow, yhigh),
       (x, y, xdelta),
       (x, y, xlow, xhigh),
       (x, y, xdelta, ydelta),
       (x, y, xlow, xhigh, ylow, yhigh)

 x 座標は必ず指定しなければいけません。各数値を書く順序も上で挙げた通りで
 なくてはなりません。ただ、`using` 修飾子を使えばその順序を操作できますし、
 欠けている列の値も補うことは可能ですが。例えば、

       plot 'file' with errorbars
       plot 'file' using 1:2:(sqrt($1)) with xerrorbars
       plot 'file' using 1:2:($1-$3):($1+$3):4:5 with xyerrorbars

 最後の例は、相対的な x の誤差と絶対的な y の誤差、という、サポートされて
 いない組のファイルに対するものです。`using` エントリが相対的な x の誤差
 から絶対的な x の最小値と最大値を生成しています。

 y のエラーバーは、(x, ylow) から (x, yhigh) への鉛直な線として描かれます。
 ylow と yhigh の代わりに ydelta が指定されたときは、ylow = y - ydelta,
 yhigh = y + ydelta となります。ある行にデータが 2 つしかなければ、ylow と
 yhight はともに y となります。x エラーバーは同様に計算された水平線です。
 データの各点を結ぶ折れ線を引きたい場合は、with errorbars と with lines を
 指定して、同じデータファイルを 2 回 `plot` して下さい (ただし、キーの中に
 2 つのエントリを作らないように、その一方には `notitle` オプションを使う
 ことを忘れないで下さい)。他の選択肢として、errorlines コマンドもあります
 (以下参照: `errorlines`)。

 エラーバーには、もし `set bars` を使っていなければ、そのそれぞれの端に垂直な
 線分がつきます (詳細は、以下参照: `set bars`)。

 自動範囲指定が有効であれば、その描画範囲はエラーバーも含むように調整
 されます。

 以下も参照
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 エラーバーのデモ
^ </a>

 更なる情報に関しては、以下参照: `plot using`, `plot with`, `set style`。
3 errorlines
?commands plot errorlines
?commands splot errorlines
?plot errorlines
?splot errorlines
?errorlines
 誤差線 (errorbar) を伴う線描画は、2 次元データファイルの描画でサポート
 されていて、それは 1 個から 4 個の追加の (または `using` で指定する)
 列データを与えることで行なわれます。これらの追加される値は、様々な
 errorline スタイルのそれぞれで異なった形で使われます。

 デフォルトの状態では、`gnuplot` は、データファイルの各行に 3 個、4 個、
 6 個のいずれかの個数のデータがあることを期待し、それぞれ以下のいずれか
 に対応します。

       (x, y, ydelta),
       (x, y, ylow, yhigh),
       (x, y, xdelta),
       (x, y, xlow, xhigh),
       (x, y, xdelta, ydelta),
       (x, y, xlow, xhigh, ylow, yhigh)

 x 座標は指定する必要がありますし、データの順番も上の形式である必要があ
 りますが、`using` 修飾子でその順番を操作したり、欠けている列に対する値
 を与えたりすることができます。例えば

       plot 'file' with errorlines
       plot 'file' using 1:2:(sqrt($1)) with xerrorlines
       plot 'file' using 1:2:($1-$3):($1+$3):4:5 with xyerrorlines

 最後の例は、相対的な x の誤差と絶対的な y の誤差、というサポートされて
 いない組合せのデータのファイルに対するもので、`using` で相対的な誤差か
 ら絶対的な x の最小値と最大値を生成しています。

 y 誤差線は (x, ylow) から (x, yhigh) へ描画される縦線です。ylow, yhigh
 代わりに ydelta が指定された場合は、ylow = y - ydelta, yhigh = y + ydelta
 と扱われます。ある行に 2 つのデータしかない場合、yhigh, ylow は両方と
 も y になります。x 誤差線は同様の方法で計算される水平線です。

 誤差線には、`set bars` が指定されていない場合、その両端で垂直に交わる
 線分が付きます (詳細は、以下参照: `set bars`)。

 自動縮尺 (autoscaling) が ON の場合、描画範囲は誤差線が入るように調整
 されます。

 更なる情報については、以下参照: `plot using`, `plot with`, `set style`。
3 関数描画 (functions)
?commands plot functions
?plot functions
?functions
 コマンド `plot`, `splot` では、ファイルから読み込んだデータの描画だけ
 でなく、組み込み関数やユーザ定義関数を描画することもできます。関数の値
 は、独立な軸の通常の範囲に渡ってデータサンプルを取ることで評価します。
 以下参照: `set samples`, `set isosamples`。

 例:
       approx(ang) = ang - ang**3 / (3*2)
       plot sin(x) title "sin(x)", approx(x) title "approximation"

 関数のデフォルトの描画スタイルを設定する方法については、以下参照:
 `set style function`。組み込み関数の情報については、以下参照:
 `expressions functions`。自前で関数を定義する方法については、以下参照:
 `user-defined`。
3 媒介変数モード描画 (parametric)
?commands plot parametric
?commands splot parametric
?plot parametric
?splot parametric
 媒介変数モード (`set parametric`) では、`plot` では 2 つの数式の組を、
 `splot` では 3 つの数式の組を与える必要があります。

 例:
       plot sin(t),t**2
       splot cos(u)*cos(v),cos(u)*sin(v),sin(u)

 データファイルは前と同じように描画されます。ただし、データファイルが
 描画のために与えられる前に、任意の媒介変数関数が先に完全に指定された
 場合を除いてです。言い換えると、x の媒介変数関数 (上の例では `sin(t)`)
 と y の媒介変数関数 (上の例では `t**2`) との間に、他の修飾子やデータ
 関数をはさみこんではいけません。そのようなことをすると、構文エラーにな
 り、媒介変数関数が完全には指定されていない、と表示されます。

 `with` や `title` のような他の修飾子は、媒介変数関数の指定が完了した
 後に指定しなければいけません。

       plot sin(t),t**2 title 'Parametric example' with linespoints

 以下も参照
^ <a href="http://www.gnuplot.info/demo/param.html">
 媒介変数モードのデモ。
^ </a>
3 範囲 (ranges)
?commands plot ranges
?commands splot ranges
?plot ranges
?splot ranges
?ranges
 このセクションでは、コマンド `plot` の一番最初の項目として書く、軸の範
 囲のオプションについてのみ説明します。これを指定すると、その範囲は、そ
 れ以前のどの `set range` による範囲の制限よりも優先して扱われます。コ
 マンド `plot` の別な場所に指定する、個々の描画要素の範囲の制限ためのオ
 プションについては以下参照: `sampling`。

 書式:
       [{<dummy-var>=}{{<min>}:{<max>}}]
       [{{<min>}:{<max>}}]

 1 つ目の形式の範囲指定は独立変数の範囲 (`xrange`、または媒介変数モード
 での `trange`) 用で、2 つ目の形式は従属変数の範囲用です。オプションの
 <dummy-var> で独立変数の新しい名前を利用できます (デフォルトの変数名は
 `set dummy` で変更できます)。

 媒介変数モード (parametric) でなければ、範囲指定は以下の順に与えなけれ
 ばいけません:
       plot [<xrange>][<yrange>][<x2range>][<y2range>] ...

 媒介変数モード (parametric) では、範囲指定は以下の順に与えなければいけ
 ません:
       plot [<trange>][<xrange>][<yrange>][<x2range>][<y2range>] ...
 以下の `plot` コマンドは、`trange` を [-pi:pi], `xrange` を [-1.3:1.3],
 `yrange` を [-1:1] に設定する例です:

       plot [-pi:pi] [-1.3:1.3] [-1:1] sin(t),t**2

 `*` は、min (最小値) や max (最大値) に自動範囲指定 (autoscale) の機能
 を使うことを可能にします。指定順番のためだけに必要な範囲指定には、空の
 範囲 `[]` を使ってください。

 `plot` や `splot` のコマンド行で指定された範囲はそのグラフ一つにのみ影
 響を及ぼします。よって、その後のグラフのデフォルトの範囲を変更するには
 `set xrange` や `set yrange` を使用してください。

 時間データに対しては、範囲は、データファイルから読み込むのに使用するの
 と同じ書式で、引用符で囲んで指定する必要があります。以下参照:
 `set timefmt`。

 例:

 以下は現在の範囲を使用します:
       plot cos(x)

 以下は x の範囲のみの指定です:
       plot [-10:30] sin(pi*x)/(pi*x)

 以下は上と同じですが、仮変数として t を使います:
       plot [t = -10 :30]  sin(pi*t)/(pi*t)

 以下は x と y の両方の範囲の指定です:
       plot [-pi:pi] [-3:3]  tan(x), 1/x

 以下は、y の範囲のみの指定です:
       plot [ ] [-2:sin(5)*-8] sin(x)**besj0(x)

 以下は x の最大値と y の最小値のみの指定です。
       plot [:200] [-pi:]  $mydata using 1:2

 以下は x の範囲を時系列データとして指定しています:
       set timefmt "%d/%m/%y %H:%M"
       plot ["1/6/93 12:00":"5/6/93 12:00"] 'timedata.dat'

3 sampling
?sampling
?commands plot sampling
?plot sampling
=sample
 デフォルトでは、関数や疑似ファイル "+" で生成されるデータは、描画範囲
 全体にわたって標本化 (sample) されます。この範囲は、plot コマンドの直
 前に前もって明示的にグローバルな範囲指定をコマンド `set xrange` で指定
 することができますが、そうでなければ plot コマンドのすべての要素に関す
 るデータ全体を含むように範囲が自動縮尺 (autoscaling) されます。しかし、
 その標本化範囲は個々の描画要素毎に制限して割り当てることもできます。

 例:

 以下は、x 全体の範囲を 0 から 1000 としてファイルのデータを描画し、2
 つの関数を全体の範囲の一部分だけそれぞれ描画します:
       plot [0:1000] 'datafile', [0:200] func1(x), [200:500] func2(x)

 以下は、上とほぼ同様ですが、全体の範囲はデータファイルの内容によって決
 定します。この場合、標本化される関数は、全体がグラフ内に収まるかもしれ
 ませんし、収まらないかもしれません:
       set autoscale x
       plot 'datafile', [0:200] func1(x), [200:500] func2(x)

 以下のコマンドにはあいまいさが含まれます。先頭の範囲は、多分最初の関数
 の標本化のみに向けたのだと思いますが、実際はそうではなく、すべての描画
 要素に適用するように解釈されます:
       plot [0:10] f(x), [10:20] g(x), [20:30] h(x)

 以下のコマンドは、上の例のあいまいさを除くためにキーワード `sample` を
 追加したもので、その範囲指定を plot 全体に適用しないようにしています:
       plot sample [0:10] f(x), [10:20] g(x), [20:30] h(x)

 以下の例は、3 次元グラフにらせんの曲線を描く一つの方法を提示します:
       splot [-2:2][-2:2] sample [h=1:10] '+' using (cos(h)):(sin(h)):(h)

3 plot コマンドの for ループ (for loops in plot command)
?commands plot for
?commands splot for
?plot for
?splot for
?for loops
=iteration
 多くの同等のファイルや関数を同時に描画する場合は、それぞれの plot コマ
 ンドの繰り返し (iteration) でそれを行うのが便利です。

 書式:
       plot for [<variable> = <start> : <end> {:<increment>}]
       plot for [<variable> in "string of words"]

 繰り返しの適用範囲 (scope) は、次のコンマ (,) かコマンドの終わり、のい
 ずれか先に現れたところまでです。よって、繰り返しは媒介変数モード
 (parametric) では機能しません。

 繰り返し文がコンマまでなので、以下は一つの曲線 sin(3x) を描画します。
       plot for [i=1:3] j=i, sin(j*x)
 j の後にコンマがないので、以下は 3 つの曲線を描画します。
       plot for [i=1:3] j=i sin(j*x)

 例:
       plot for [dataset in "apples bananas"] dataset."dat" title dataset

 この例では、繰り返しはファイル名と対応するタイトルの生成の両方で使われ
 ています。

 例:
       file(n) = sprintf("dataset_%d.dat",n)
       splot for [i=1:10] file(i) title sprintf("dataset %d",i)

 この例は、ファイル名で生成される文字列値関数を定義し、そのような 10 個
 のファイルを同時に描画します。繰り返しの変数 (この例では 'i') は一つの
 整数として扱われ、それを 2 度以上使用できます。

 例:
       set key left
       plot for [n=1:4] x**n sprintf("%d",n)

 この例は、関数の組を描画します。

 例:
       list = "apple banana cabbage daikon eggplant"
       item(n) = word(list,n)
       plot for [i=1:words(list)] item(i).".dat" title item(i)
       list = "new stuff"
       replot

 この例では、リストに従って各ステップが進行し、その各項目に対して一つの
 描画が行われます。この各項目は動的に取得されますので、そのリストを変更
 し、そのまま replot することができます。

 例:
       list = "apple banana cabbage daikon eggplant"
       plot for [i in list] i.".dat" title i
       list = "new stuff"
       replot

 この例は、整数の繰り返し変数ではなく、文字列の繰り返し変数形式を用いて
 いること以外は前の例と全く同じです。

3 title
?commands plot title
?commands splot title
?plot title
?splot title
?columnheader
 デフォルトでは各曲線は、対応する関数やファイル名でキーの中に一覧表示さ
 れますが、plot のオプション `title` を使うことで、明示的なタイトルを与
 えることもできます。

 書式:
       title <text> | notitle [<ignored text>]
       title columnheader | title columnheader(N)
             {at {beginning|end}}

 ここで <text> は、引用符で囲まれた文字列か、文字列と評価される式のいず
 れかです。引用符はキーには表示されません。

 入力データの列の最初の項目 (すなわち列の先頭) を文字列フィールドと解釈
 し、それをキータイトルとして利用するオプションもあります。以下参照:
 `datastrings`。これは、`set key autotitle columnhead` を指定すればデフ
 ォルトの挙動となります。

 曲線タイトルとサンプルは予約語 `notitle` を使うことでキーから削除でき
 ます。何もないタイトル (`title ''`) は `notitle` と同じ意味を持ちます。
 サンプルだけが欲しいときは、一つ以上の空白をタイトルの後ろに入れてく
 ださい (`tilte ' '`)。`notilte` の後ろに文字列をつけた場合、その文字列
 は無視されます。

 `key autotitles` が設定されて (デフォルト)、かつ `title` も `notitle`
 も指定されなかった場合、曲線のタイトルは `plot` コマンド上にある関数名
 かデータファイル名になります。ファイル名の場合は、指定される任意のデー
 タファイル修飾子もそのデフォルトタイトルに含まれます。

 位置やタイトルの位置揃えなどの凡例のレイアウトは、`set key` で制御でき
 ます。詳細は、以下参照: `set key`。

 描画する曲線のタイトルを、グラフの曲線自身の直前、あるいは直後に置くに
 は、`at {beginning|end}` を使用します。このオプションは、`with lines`
 で描画する場合は有用ですが、他の描画スタイルでは意味がない場合もありま
 す。

 例:

 以下は y=x をタイトル 'x' で表示します:
       plot x

 以下は、x の 2 乗をタイトル "x^2" で、ファイル "data.1" をタイトル
 "measured data" で表示します:
       plot x**2 title "x^2", 'data.1' t "measured data"

 以下は、極座標グラフの周りに円形の境界を書き、タイトルなしで表示します:
       set polar; plot my_function(t), 1 notitle

 以下は、ファイルの先頭行の各列にタイトルを含む複数列のデータを描画しま
 す。各タイトルは、独立した凡例ではなく、対応する曲線の後ろに置きます:
       unset key
       set offset 0, graph 0.1
       plot for [i=1:4] 'data' using i with lines title columnhead at end

3 with
?commands plot with
?commands splot with
?commands plot style
?commands splot style
?plot with
?plot style
?splot with
?splot style
?style
?with
 関数やデータの表示にはたくさんのスタイルのうちの一つを使うことができます。
 キーワード `with` がその選択のために用意されています。

 書式:
       with <style> { {linestyle | ls <line_style>}
                      | {{linetype  | lt <line_type>}
                         {linewidth | lw <line_width>}
                         {linecolor | lc <colorspec>}
                         {pointtype | pt <point_type>}
                         {pointsize | ps <point_size>}
                         {fill | fs <fillstyle>}
                         {nohidden3d} {nocontours} {nosurface}
                         {palette}}
                    }


 ここで、<style> は以下のいずれか:

      lines        dots       steps     errorbars     xerrorbar    xyerrorlines
      points       impulses   fsteps    errorlines    xerrorlines  yerrorbars
      linespoints  labels     histeps   financebars   xyerrorbars  yerrorlines
      surface      vectors    parallelaxes
 または、
      boxes            boxplot        ellipses       image
      boxerrorbars     candlesticks   filledcurves   rgbimage
      boxxyerrorbars   circles        histograms     rgbalpha   pm3d

 最初のグループのスタイルは、線、点、文字の属性を持ち、第 2 のグループ
 のスタイルは、さらに塗り潰し属性も持っています。以下参照: `fillstyle`。
 さらにサブスタイルを持つスタイルもあります。個々のスタイルの詳細につい
 ては、以下参照: `plotting styles`。

 デフォルトのスタイルは、`set style function` と `set style data` で選
 択できます。

 デフォルトでは、それぞれの関数やデータファイルは、使うことができる型の
 最大数に達するまで異なる線種、点種を使います。すべての端末用ドライバは
 最低 6 つの異なる点種をサポートしていて、もしたくさん要求された場合、
 それらを順に再利用していきます。使用中の出力形式での線種、点種の集合全
 体を見たければ、`test` としてください。

 一つの描画で線種や点種を選びたいならば、<line_type> や <point_type> を
 指定してください。これらの値は、その描画で使われる線種や点種を指定する
 正の整定数 (または数式) です。使用する端末で使える線種、点種を表示する
 には `test` コマンドを使ってください。

 描画の線の幅や点の大きさは <line_width> や <point_size> で変更できます。
 これらはその各々の端末のデフォルトの値に対する相対的な値として指定しま
 す。点の大きさは全体に通用するように変更できます。詳細は、以下参照:
 `set pointsize`。しかし、ここでセットされる <point_size> と、
 `set pointsize` でセットされる大きさは、いずれもデフォルトのポイントサ
 イズに掛けられることに注意してください。すなわち、それらの効果は累積は
 しません。例えば、`set pointsize 2; plot x w p ps 3` は、デフォルトの
 サイズの 3 倍であって、6 倍ではありません。

 ラインスタイルの一部分、あるいは各 plot において `pointsize variable`
 という指定も可能です。この場合、入力には追加の 1 列が要求されます。例
 えば 2D 描画では 3 列、3D 描画では 4 列のデータが必要になります。個々
 の点のサイズは、全体を通しての pointsize に、データファイルからの入力
 による値をかけたものとして決定されます。

 `set style line` を使って線種/線幅、点種/点幅の組を定義すれば、そのス
 タイルの番号を <line_style> にセットすることでそれらを使うことができま
 す。

 gnuplot が `pm3d` をサポートするようにインストールされているならば、
 `splots` において lines, points, dots の色を滑らかに変化させるための特
 別なキーワード `palette` が使えます。その色は、コマンド `set palette`
 であらかじめ設定された滑らかに変化するカラーパレットから選択します。色
 の値は、点の z 座標の値か、または `using` で 4 番目のパラメータとして
 指定される色座標に対応します。2 次元、3 次元の描画 (`plot` と `splot`
 コマンド) の両方で、パレット色を小数値かまたはカラーボックスの範囲へ対
 応づけられた値のいずれかで指定することができます。パレット色の値は、
 `using` 指定で明示的に指定された入力列から読み込むことも可能です。
 以下参照: `colors`, `set palette`, `linetype`。

 キーワード `nohidden3d` は、`splot` コマンドで生成される描画にのみ適用
 されます。通常、グローバルなオプション `set hidden3d` はグラフ上の全て
 の描画に適用されますが、各々の描画に `nohidden3d` オプションをつけるこ
 とで、それを hidden3d の処理から除外することができます。`nohidden3d`
 がマークされた曲面以外の個々の描画要素 (線分、点、ラベル等) は、通常は
 他の何らかの描画要素で隠されてしまう場合も全て描画されます。

 同様に、キーワード `nocontours` は、グローバルに `set contour` 指定が
 有効な場合でも、個別の plot に対する等高線描画機能をオフにします。

 同様に、キーワード `nosurface` は、グローバルに `set surface` 指定が有
 効な場合でも、個別の plot に対する 3 次元曲面描画をオフにします。

 キーワードは暗示するような形で省略可能です。

 `linewidth`, `pointsize`, `palette` オプションは全ての端末装置でサポー
 トされているわけではないことに注意してください。

 例:

 以下は、sin(x) を鉛直線で描画します:
       plot sin(x) with impulses

 以下は、x を点で描画し、x**2 をデフォルトの方式で描画します:
       plot x w points, x**2

 以下は、tan(x) を関数のデフォルトの方式で、"data.1" を折れ線で描画します:
       plot [ ] [-2:5] tan(x), 'data.1' with l

 以下は、"leastsq.dat" を鉛直線で描画します:
       plot 'leastsq.dat' w i

 以下は、データファイル "population" を矩形で描画します:
       plot 'population' with boxes

 以下は、"exper.dat" をエラーバー付きの折れ線で描画します (エラーバーは
 3 列、あるいは 4 列のデータを必要とします):
       plot 'exper.dat' w lines, 'exper.dat' notitle w errorbars

 もう一つの "exper.dat" のエラーバー付きの折れ線 (errorlines) での描画
 方法 (エラーバーは 3 列、あるいは 4 列のデータが必要):
       plot 'exper.dat' w errorlines

 以下は、sin(x) と cos(x) をマーカー付きの折れ線で描画します。折れ線は
 同じ線種ですが、マーカーは異なったものを使います:
       plot sin(x) with linesp lt 1 pt 3, cos(x) with linesp lt 1 pt 4

 以下は、"data" を点種 3 で、点の大きさを通常の 2 倍で描画します:
       plot 'data' with points pointtype 3 pointsize 2

 以下は、"data" を描画しますが、4 列目から読んだデータを pointsize の値
 として使用します:
       plot 'data' using 1:2:4 with points pt 5 pointsize variable

 以下は、2 つのデータ集合に対して、幅のみ異なる線を用いて描画します:
       plot 'd1' t "good" w l lt 2 lw 3, 'd2' t "bad" w l lt 2 lw 1

 以下は、x*x の曲線の内部の塗りつぶしと色の帯を描画します:
       plot x*x with filledcurve closed, 40 with filledcurve y1=10

 以下は、x*x の曲線と色の箱を描画します:
       plot x*x, (x>=-5 && x<=5 ? 40 : 1/0) with filledcurve y1=10 lt 8

 以下は、滑らかに変化する色の線で曲面を描画します:
       splot x*x-y*y with line palette

 以下は、2 つの色のついた曲面を、異なる高さで表示します:
       splot x*x-y*y with pm3d, x*x+y*y with pm3d at t

2 print
?commands print
?print
 `print` コマンドは <式> の値を画面に表示します。これは `pause 0` と同
 じです。<式> は、数を生成する `gnuplot` の数式か、または文字列です。

 書式:
         print <式> {, <式>, ...}

 以下参照: `expressions`。出力ファイルは `set print` で設定できます。
2 pwd
?commands pwd
?pwd
 `pwd` コマンドはカレントディレクトリの名前を画面に表示します。

 カレントディレクトリを文字列変数に保存したり、文字式の中で使いたい場合
 は、変数 GPVAL_PWD を使うことができることに注意してください。以下参照:
 `show variables all`。
2 quit
?commands quit
?quit
 `exit` と `quit` の両コマンドと END-OF-FILE 文字は、`gnuplot` を終了
 させます。これらのコマンドは、出力装置を (`clear` コマンドと同様に)
 クリアしてから終了させます。
2 raise
?commands raise
?raise
 書式:
       raise {plot_window_nb}

 コマンド `raise` (`lower` の反対) は、`pm`, `win`, `wxt`, `x11` 等の
 gnuplot の対話型出力形式の実行中に、描画ウィンドウを上 (前面) に上げま
 す。描画ウィンドウを、デスクトップ上のウィンドウマネージャの z 方向の
 ウィンドウの重なりの前 (上) に置きます。

 `x11` や `wxt` のように複数の描画ウィンドウをサポートしている場合、デ
 フォルトではこのコマンドはそれらの複数のウィンドウを降順に上げ、最初に
 作られたウィンドウを一番下に、最後に作られたウィンドウを一番上に並べま
 す。オプション引数の描画番号が与えられた場合、それに対応する描画ウィン
 ドウが存在すればそれのみが上げられます。

 オプション引数は、単一の描画ウィンドウの出力形式、すなわち `pm` と
 `win` では無視されます。

 ウィンドウが X11 で前面に出ない場合、もしかすると描画ウィンドウは、異
 なる X11 セッションで動作している (例えば telnet や ssh セッションなど
 によって) か、または前面に出すことがウィンドウマネージャの設定によって
 防害されている可能性があります。
2 refresh
?commands refresh
?refresh
 コマンド `refresh` は、`replot` に似ていますが、主に 2 つの点で違いが
 あります。`refresh` は、既に読み込んだデータを用いて、現在の描画を再整
 形し再描画します。これは、`refresh` を (疑似デバイス '-' からの) イン
 ラインデータの描画、および内容が変化しうるデータファイルからの描画に使
 えるということを意味します。ただし、コマンド `refresh` は、既に存在す
 る描画に新しいデータを追加するのには使えません。

 マウス操作、特にズームインとズームアウトでは、適切な場合は `replot` の
 代わりにむしろ `refresh` を使用します。例:

       plot 'datafile' volatile with lines, '-' with labels
       100 200 "Special point"
       e
       # 色んなマウス操作をここで実行
       set title "Zoomed in view"
       set term post
       set output 'zoom.ps'
       refresh

2 replot
?commands replot
?replot
 `replot` コマンドを引数なしで実行すると、最後に実行した `plot` または
 `splot` コマンドを再実行します。これは、あるプロットを異なる `set` オ
 プションでみたり、同じプロットを異なる装置に出力したりするときに便利
 でしょう。

 `replot` コマンドに対する引数は最後に実行した `plot` または `splot`
 コマンドの引数に (暗黙の ',' と共に) 追加され、それから再実行されます。
 `replot` は、範囲 (range) を除いては、`plot` や `splot` と同じ引数を
 とることができます。よって、直前のコマンドが `splot` ではなく `plot`
 の場合は、関数をもう一つの軸刻みでプロットするのに `replot` を使うこと
 ができます。

 注意:

       plot '-' ; ... ; replot

 という使い方は推奨されません。それは、これがあなたに再び同じデータすべ
 ての入力を要求することになるからです。たいていの場合、代わりにコマンド
 `refresh` を使えます。これは、以前に読み込んだデータを使ってグラフを再
 描画します。

 `multiplot` モードでは、`replot` コマンドはすべての plot ではなく、直
 前の plot 部分だけしか再実行しないことに注意してください。

 最後に実行した `plot` (`splot`) コマンドの内容を修正する方法については
 以下も参照: `command-line-editing`。

 直前の描画コマンドの全体を表示させることや、それを `history` の中に
 コピーする方法については、以下も参照: `show plot`。
2 reread
?commands reread
?reread
 `reread` コマンドは、`load` コマンドまたはコマンドラインで指定した
 `gnuplot` のコマンドファイルを、その次のコマンドが読まれる前に、開
 始点に再設定します。これは、コマンドファイルの最初から `reread` コマ
 ンドまでのコマンドの無限ループを本質的に実装していることになります。
 (しかし、これは何も悪いことではありません。`reread` は `if` と組み合
 わせることでとても有用なコマンドとなります。)
 標準入力からの入力の場合は、`reread` コマンドは何も影響を与えません。

 例:

 ファイル "looper" が次のようなファイルで
       a=a+1
       plot sin(x*a)
       pause -1
       if(a<5) reread
 そして、`gnuplot` から次のように実行するとします。
       a=0
       load 'looper'
 すると、pause のメッセージで分割された 5 回のプロットが行われることに
 なります。

 ファイル "data" が、各行に、0 から 10 までの範囲 (yrange) の 6 つのデ
 ータ を持ち、最初が x 座標で、その他は 5 つの異なる関数の、その x での
 値であるとします。そして、ファイル "plotter" が
       c_p = c_p+1
       plot "$0" using 1:c_p with lines linetype c_p
       if(c_p <  n_p) reread
 で、`gnuplot` から次のように実行するとします。
       n_p=6
       c_p=1
       unset key
       set yrange [0:10]
       set multiplot
       call 'plotter' 'data'
       unset multiplot
 すると、5 つのプロットを合わせた 1 つのグラフができます。yrange は、
 multiplot モードで最初のものに続けて書かれる 5 つのグラフが、同じ軸を
 持つように、明示的に指定する必要があります。線種も指定しなければなりま
 せん。さもないと、全てのグラフが同じ線種で書かれることになります。
 アニメーションのサンプルとして、demo ディレクトリの animate.dem も参照
 してください。

2 reset
?commands reset
?reset
?reset errors
?reset bind
?reset session
 コマンド `reset` は、`set` コマンドで定義できる、グラフに関する全ての
 オプションをデフォルトの値に戻します。このコマンドは、load したコマン
 ドファイルを実行した後でデフォルトの設定を復帰したり、設定をたくさん変
 更した後で元の状態に戻したいときなどに便利です。

 以下のものは、`reset` の影響を受けません。
      `set term` `set output` `set loadpath` `set fontpath` `set linetype`
      `set encoding` `set decimalsign` `set locale` `set psdir`

 `reset` は、必ずしもプログラム立ち上がった初期状態には戻さないことに注
 意してください。それは、初期設定ファイル gnuplotrc や $HOME/.gnuplot
 内のコマンドでデフォルトの値を変更した場合は、それもリセットされてしま
 うからです。しかし `reset session` とすれば、それらのコマンドも再実行
 します。

=session
 `reset session` は、ユーザ定義変数、ユーザ定義関数すべてを削除し、デフ
 ォルトの設定を復帰し、システム全体の初期設定ファイル gnuplotrc と個人
 用の初期設定ファイル $HOME/.gnuplot を再実行します。以下参照:
 `initialization`。

=error state
 `reset errors` は、エラー状態変数 GPVAL_ERRNO と GPVAL_ERRMSG のみをク
 リアします。

=bind
 `reset bind` は、キー定義をデフォルトの状態に復帰します。
2 save
?commands save
?save set
?save
 `save` コマンドは、ユーザ定義関数、変数、`set term` の状態、`set` で設
 定する全てのオプションのいずれかか、あるいはこれらすべてと、それに加え
 て最後に実行した `plot` (または `splot`) コマンドを、指定したファイル
 に保存します。

 書式:
         save  {<オプション>} '<ファイル名>'

 ここで、<オプション> は、`functions`, `variables`, `terminal`, `set`
 のいずれかです。どれも指定されなかった場合には、`gnuplot` は、ユーザ定
 義関数、変数、set で設定するオプション、最後に実行した `plot` (または
 `splot`) コマンドの全てを保存します。

 `save` は、テキスト形式で出力します。また、このファイルは `load` コマ
 ンドで読み込むことができます。`set` オプション付き、または何もオプショ
 ンをつけずに `save` を実行した場合、`terminal` の選択と `output` のフ
 ァイル名はコメント記号つきで書き出されます。これはその出力ファイルを
 他の環境にインストールされた gnuplot 上で動かす場合に、修正なしに使え
 るようにする、あるいはうっかりファイルを上書きしてしまったりする危険性
 を避ける、といった意味があります。

 `save terminal` は、`terminal` の状態を、コメント記号をつけずに書き出
 します。これは主に、ちょっとの間だけ `terminal` の設定を入れ替え、その
 後保存しておいた `terminal` の状態を読み込むことで以前の terminal の設
 定に戻す場合などに役立ちます。ただ、単一の gnuplot セッションでは、現
 在の terminal を保存/復元する他の方法であるコマンド `set term push` と
 `set term pop` を使う方がむしろいいかもしれません。以下参照:
 `set term`。

 ファイル名は引用符に囲われていなければなりません。

 特別なファイル名 "-" により `save` コマンドに標準出力に出力させること
 ができます。popen 関数をサポートするようなシステム (Unix など) では、
 save の出力をパイプ経由で他の外部プログラムに渡すことができます。その
 場合、ファイル名としてコマンド名の先頭に '|' をつけたものを使います。
 これは、`gnuplot` とパイプを通して通信するプログラムに、`gnuplot` の内
 部設定に関する首尾一貫したインターフェースを提供します。詳細は、以下参
 照: `batch/interactive`。

 例:
       save 'work.gnu'
       save functions 'func.dat'
       save var 'var.dat'
       save set 'options.dat'
       save term 'myterm.gnu'
       save '-'
       save '|grep title >t.gp'
2 set-show
?commands set
?commands show
?set
?show
?show all
 `set` コマンドは実に多くのオプションを設定するのに使われます。しかし、
 `plot`, `splot`, `replot` コマンドが与えられるまで何も表示しません。

 `show` コマンドはそれらの設定値を表示します。`show all` でそれら全て
 を表示します。

 `set` コマンドで変更されたオプションは、それに対応する `unset` コマン
 ドを実行することでデフォルトの状態に戻すことができます。以下も参照:
 `reset`。これは全てのパラメータの設定をデフォルトの値に戻します。

=iteration
 `set` と `unset` コマンドには繰り返し節も利用できます。以下参照:
 `plot for`。

3 角の単位 (angles)
?commands set angles
?commands show angles
?set angles
?show angles
?angles
?commands set angles degrees
?set angles degrees
?angles degrees
?degrees
 デフォルトでは `gnuplot` は極座標グラフの独立変数の単位はラジアンを仮定
 します。`set polar` の前に `set angles degrees` を指定すると、その単位
 は度になり、デフォルトの範囲は [0:360] となります。これはデータファイル
 の描画で特に便利でしょう。角度の設定は、`set mapping` コマンドを設定す
 ることにより 3 次元でも有効です。

 書式:
       set angles {degrees | radians}
       show angles

 `set grid polar` で指定される角度も、`set angles` で指定した単位で読まれ
 表示されます。

 `set angles` は組み込み関数 sin(x), cos(x), tan(x) の引数や asin(x),
 acos(x), atan8x), atan2(x), arg(x) の出力にも影響を与えます。双曲線関
 数や、ベッセル関数の引数には影響を与えません。しかし、複素数を引数とす
 る逆双曲線関数の出力には影響が出ます。それらの関数が使われるときは、
 `set angles radians` は入出力の引数の間に一貫性を持った管理を実現して
 いなければなりません。

       x={1.0,0.1}
       set angles radians
       y=sinh(x)
       print y         #{1.16933, 0.154051} と表示
       print asinh(y)  #{1.0, 0.1} と表示
 しかし、
       set angles degrees
       y=sinh(x)
       print y         #{1.16933, 0.154051} と表示
       print asinh(y)  #{57.29578, 5.729578} と表示
 以下も参照
^ <a href="http://www.gnuplot.info/demo/poldat.html">
 poldat.dem: `set angles` を用いた極座標描画のデモ
^ </a>
3 矢印 (arrow)
?commands set arrow
?commands unset arrow
?commands show arrow
?set arrow
?unset arrow
?show arrow
?arrow
?noarrow
 `set arrow` コマンドを使うことにより、グラフ上の任意の位置に矢印を表示
 することができます。

 書式:
       set arrow {<tag>} from <position> to <position>
       set arrow {<tag>} from <position> rto <position>
       set arrow {<tag>} from <position> length <coord> angle <ang>
       set arrow <tag> arrowstyle | as <arrow_style>
       set arrow <tag> {nohead | head | backhead | heads}
                       {size <headlength>,<headangle>{,<backangle>}}
                       {filled | empty | nofilled | noborder}
                       {front | back}
                       {linestyle <line_style>}
                       {linetype <line_type>} {linewidth <line_width>}

       unset arrow {<tag>}
       show arrow {<tag>}

 タグ <tag> は各矢印を識別する整数です。タグを指定しない場合は、その時
 点で未使用の最も小さい数が自動的に割り当てられます。タグを使うことで、
 特定の矢印を変更したり、削除したりできます。既に存在する矢印の属性を変
 更する場合は、タグを明示した `set arrow` コマンドで変更箇所を指定して
 ください。

 矢印の最初の端点の位置は、常に "from" で指定しますが、もう一つの端点は
 以下で説明する 3 つの異なる仕組みのいずれかで指定できます。<position>
 は  x,y あるいは x,y,z で指定します。そしてその前に座標系を選択するた
 めに `first`, `second`, `graph`, `screen`, `character` を置くことがで
 きます。座標を指定しなければデフォルトでは 0 と見なされます。詳細は以
 下参照: `coordinates`。最初の端点に対する座標指定子は、2 番目の端点に
 は影響しません。

 1) "to <position>" は、もう一つの端点の絶対座標を指定します。

 2) "rto <position>" は、"from" の位置からのずれを指定します。この場合、
 線形軸 (非対数軸)、および `graph`, `screen` 座標に対しては、始点と終点
 の距離が与えられた相対的な値に対応します。一方、対数軸に対しては、与え
 られた相対的な値は、始点から終点への倍数に対応します。よって、対数軸の
 場合、相対的な値として 0 や負の値を与えることは許されません。

 3) "length <coordinate> angle <angle>" は、グラフ平面内での矢印の方向
 を指定します。length には任意の座標系を適用できます。angle の単位は常
 に度になっています。

 矢印の他の属性も、あらかじめ定義した矢のスタイルで、またはコマンド
 `set arrow` でそれぞれ与えることが可能です。矢印の他の属性の詳細につい
 ては以下参照: `arrowstyle`。

 例:

 原点から (1,2) への矢印をユーザ定義済のラインスタイル 5 で描くには:
       set arrow to 1,2 ls 5

 描画領域の左下角から (-5,5,3) へタグ番号 3 の矢印を描くには:
       set arrow 3 from graph 0,0 to -5,5,3

 矢印の端を 1,1,1 に変更し、矢先を外して幅を 2 にするには:
       set arrow 3 to 1,1,1 nohead lw 2

 x=3 の所へグラフの下から上まで鉛直線を描くには:
       set arrow from 3, graph 0 to 3, graph 1 nohead

 T 字型の矢先を両端に持つ鉛直方向の矢を描くには:
       set arrow 3 from 0,-5 to 0,5 heads size screen 0.1,90

 始点からの相対的な距離をグラフ座標で与えて矢を描くには:
       set arrow from 0,-5 rto graph 0.1,0.1

 x の対数軸に相対的な終点を指定して矢を描く場合:
       set logscale x
       set arrow from 100,-5 rto 10,10
 これは 100,-5 から 1000,5 までの矢を描きます。線形軸 (y) に対しては相
 対的な座標 10 が "差 10" を意味するのに対し、対数軸 (x) に対しては相対
 的な座標 10 は "倍数 10" として働きます。

 2 番の矢印を消すには:
       unset arrow 2

 全ての矢印を消すには:
       unset arrow

 全ての矢印の情報を (タグの順に) 見るには:
       show arrow

^ <a href="http://www.gnuplot.info/demo/arrowstyle.html">
 矢印のデモ
^ </a>

3 自動縮尺 (autoscale)
?commands set autoscale
?commands unset autoscale
?commands show autoscale
?set autoscale
?unset autoscale
?show autoscale
?autoscale
?noautoscale
 自動縮尺機能 (autoscale) は x, y, z の各軸に対して独立に、または一括し
 て指定できます。デフォルトでは全ての軸に対して自動縮尺設定を行います。
 図の中の一部の描画 (`plot`) の組のみを元に autoscale したい場合は、そ
 の対象でない `plot` にフラグ `noautoscale` をつけることができます。
 以下参照: `datafile`。

 書式:
       set autoscale {<axes>{|min|max|fixmin|fixmax|fix} | fix | keepfix}
       set autoscale noextend
       unset autoscale {<axes>}
       show autoscale

 ここで、<axes> (軸) は `x`, `y`, `z`, `cb`, `x2`, `y2`, `xy` のいずれ
 かです。`min` または `max` を軸に追加指定すると (`xy` では使えませんが)
 それは `gnuplot` にその軸の最小値、または最大値のみを自動縮尺させるこ
 とになります。軸も何も指定されていない場合は全ての軸が対象となります。

?noextend
 デフォルトでは、自動縮尺機能は軸の範囲の限界を、描画データ全体を含む、
 最も近い目盛りラベル位置に設定します。キーワード `fixmin`, `fixmax`,
 `fix`, `noextend` は、次の目盛り位置までの範囲の自動拡大を gnuplot に
 行わせないようにします。その場合軸の範囲の限界は、一番端にあるデータ点
 の座標値に完全に一致します。`set autoscale noextend` は、
 `set autscale fix` と同じです。軸の範囲指定コマンドの後ろにキーワード
 `noextend` を追加すれば、一つの軸の範囲の延長機能だけ無効にすることも
 できます。例:
      set yrange [0:*] noextend

 `set autoscale keepfix` は、fix の設定を変更せずに残したまま、すべての
 軸を自動縮尺にします。

 自動縮尺機能を使うときは、描画範囲は自動的に割り出され、従属変数軸
 (`plot` のときは y 軸、`splot` のときは z 軸) は、関数やデータの値域が
 収まるように設定されます。

 従属変数軸 (y または z) の自動縮尺機能が指定されていない場合は、現在の
 y や z の描画範囲がそのまま使われます。

 独立変数軸 (`plot` のときは x 軸、`splot` のときは x,y 軸) の自動縮尺
 機能が指定されている場合は、描画される全てのデータファイルの点が収まる
 ように定義域をとるようになります。データファイルが 1 つも指定されてい
 ない場合は、自動縮尺機能はなんの効果もありません。つまり、関数のみが
 指定されていてデーターファイルを使わない場合は、x 軸の描画範囲
 (z = f(x,y) を描画しているときは y 軸も) は影響をうけません。

 範囲に関するより詳しい情報に関しては、以下参照: `set xrange`。

 媒介変数モード (parametric) でも自動縮尺機能は有効です (以下参照:
 `set parametric`)。この場合、より多くの従属変数があるので、x, y, z 各
 軸に関して、より多くの制御が行われます。媒介変数モードでの独立変数 (仮
 変数) は `plot` では t で `splot` では u, v です。そして媒介変数モード
 では、自動縮尺機能は (t, u, v, x, y, z) の全ての描画範囲を制御し、x,
 y, z の範囲の自動設定を完全に行います。

 自動縮尺機能は、極座標モード (polar mode) でも `plot` の媒介変数モード
 と同様に機能しますが、極座標モードでは `set dummy` で独立変数を t から
 変更するできる (以下参照: `set dummy`) という拡張があります。

 目盛りが第 2 の軸に表示され、しかもこれらの軸に対する描画が行われなか
 った場合には、x2range と y2range は xrange と yrange の値を受け継ぎま
 す。これは、範囲のずらしの実行や、範囲を整数個の目盛り幅に自動伸縮する
 「前」に行いますので、場合によって予期しない結果をもたらす可能性があり
 ます。これを避けるのに、第 2 軸の範囲を第 1 軸の範囲に明示的にリンク
 (link) する方法があります。以下参照: `set link`。

 例:

 以下は y 軸の自動縮尺機能を指定します (他の軸には影響を与えません):
       set autoscale y

 以下は y 軸の最小値に対してのみ自動縮尺機能を指定します (y 軸の最大値、
 および他の軸には影響を与えません):
       set autoscale ymin

 以下は x2 軸の隣の目盛りへの自動範囲拡大機能を無効にし、よって描画デー
 タ内、または関数に対する丁度の描画範囲を維持します:
       set autoscale x2fixmin
       set autoscale x2fixmax

 以下は x, y 両軸の自動縮尺機能を指定します:
       set autoscale xy

 以下は x, y, z, x2, y2 全軸の自動縮尺機能を指定します:
       set autoscale

 以下は x, y, z, x2, y2 全軸の自動縮尺機能を禁止します:
       unset autoscale

 以下は z 軸のみについて自動縮尺機能を禁止します:
       unset autoscale z
4 媒介変数モード (parametric)
?commands set autoscale parametric
?set autoscale parametric
?set autoscale t
 媒介変数表示モード (`set parametric`) においては、xrange も yrange と
 同様に縮尺を変えることができます。つまり、媒介変数モードにおいては、
 x 軸方向も自動的に縮尺が調整され、描こうとしている媒介変数表示の関数が
 収まるようになります。もちろん、y 軸方向も媒介変数モードでない時同様に
 自動的に縮尺を変えます。x 軸について自動縮尺機能が設定されていない場合
 は、現在の x の範囲が使われます。

 データファイルは媒介変数モードでもそうでない状態でも同様に描画され
 ます。しかし、データファイルと関数が混在している場合には、違いがあ
 ります: 媒介変数モードでなければ、x の自動縮尺機能は、関数の範囲を
 データの描画範囲に合わせます。しかし媒介変数モードではデータの範囲
 は関数の範囲に影響しません。

 それには、片手落ちにならないように `set autoscale t` というコマンド
 も用意されています。しかしその効果は非常に小さいものです。自動縮尺
 機能が設定されていると、`gnuplot` が t の範囲が無くなってしまうと
 判断した場合に範囲を少し調整します。自動縮尺機能が設定されていないと
 このようなときにはエラーとなります。このような動作は実はあまり意味が
 なく、よって `set autoscale t` というコマンドは存在意義に疑問があり
 ます。

 `splot` では上記の発想の元に拡張されています。自動縮尺機能が設定され
 ている場合、x, y, z の各描画範囲は計算結果が収まるように設定され縮尺
 調整されます。
4 極座標モード (polar)
?commands set autoscale polar
?set autoscale polar
 極座標モード (`set polar`) では、xrange と yrange は自動縮尺モードでは
 なくなります。動径軸の範囲制限用に `set rrange` を使用した場合、xrange
 と yrange はそれに合うように自動的に調整されます。しかし、さらにそれを
 調整したければ、その後に明示的に xrange や yrange コマンドを使うことが
 できます。以下参照: `set rrange`。trange は自動範囲設定がなされます。
 もし、trange がある象限 (四分円) に収まるならば、自動縮尺機能によりそ
 の象限のみの描画が行われることに注意してください。

 1 つ、あるいは 2 つの範囲は明示的に設定してその他のものを指定しない場合は
 予期しない結果を引き起こすかも知れません。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/poldat.html">
 極座標のデモ。
^ </a>
3 飾り棒 (bars)
?commands set bars
?commands show bars
?set bars
?show bars
?bars
 コマンド `set bars` は誤差グラフ (errorbar) の両端、および boxplot に
 つく箱ひげの両端のマークを制御します。

 書式:
       set bars {small | large | fullwidth | <size>} {front | back}
       unset bars
       show bars

 `small` は 0.0, `large` は 1.0 と同じです。サイズを指定しなければデフォ
 ルトの値は 1.0 です。

 キーワード `fullwidth` は、errorbar を伴う boxplot と histograms にの
 み関連します。これは errorbar の両端の幅を、対応する箱の幅と同じに設定
 しますが、箱の幅自体を変更することはありません。

 キーワード `front`, `back` は、塗り潰し長方形のついた errorbar のみに
 関連します (boxes, candlesticks, histograms)。
3 bind
?commands show bind
?show bind
=bind
 現在のホットキーの割り当て (binding) を表示します。以下参照: `bind`。
3 bmargin
?commands set bmargin
?set bmargin
?bmargin
 コマンド `set bmargin` は、下部の余白のサイズを設定します。詳細は
 以下参照: `set margin`。
3 グラフの枠線 (border)
?commands set border
?commands unset border
?commands show border
?set border
?unset border
?show border
?border
?noborder
 `set border` と `unset border` は `plot` や `splot` でのグラフの枠の
 表示を制御します。枠は必ずしも軸とは一致しないことに注意してください。
 `plot` では大抵一致しますが、`splot` では大抵一致していません。

 書式:
       set border {<integer>}
                  {front | back | behind} {linewidth | lw <line_width>}
                  {{linestyle | ls <line_style>} | {linetype | lt <line_type>}}
       unset border
       show border

 `set view 56,103` のように任意の方向で表示されうる `splot` では、 x-y
 平面上の 4 つの角は 手前 (`front`), 後ろ (`back`) , 左 (`left`), 右
 (`right`) のように呼ばれます。もちろんこの同じ 4 つの角は天井の面にも
 あります。よって、例えば x-y 平面上の後ろと右の角をつなぐ境界を
 "底の右後ろ (bottom right back)" と言い、底と天井の手前の角をつなぐ境
 界を "鉛直手前 (front vertical)" と呼ぶことにします (この命名法は、読
 者が下の表を理解するためだけに使われます)。

 枠は、12 ビットの整数に符号化されています: 下位 4 ビットは `plot` に対
 する外枠、`splot` に対しては底面の外枠、次の 4 ビットは `splot` の鉛直
 な外枠、そして上位 4 ビットは `splot` の天井面の外枠を制御します。よっ
 て外枠の設定は、次の表の対応する項目の数字の和になります:

@start table - first is interactive cleartext form
          ビット     plot        splot
               1      下      底の左手前
               2      左      底の左後ろ
               4      上      底の右手前
               8      右      底の右後ろ
              16    効果なし  鉛直左
              32    効果なし  鉛直後ろ
              64    効果なし  鉛直右
             128    効果なし  鉛直手前
             256    効果なし  天井の左後ろ
             512    効果なし  天井の右後ろ
            1024    効果なし  天井の左手前
            2048    効果なし  天井の右手前
#\begin{tabular}{|c|c|c|} \hline
#\multicolumn{3}{|c|}{グラフ境界の符号化} \\ \hline \hline
#ビット & plot & splot \\ \hline
#1 & 下 & 底の左手前 \\
#2 & 左 & 底の左後ろ  \\
#4 & 上 & 底の右手前  \\
#8 & 右 & 底の右後ろ  \\
#16 & 効果なし & 鉛直左  \\
#32 & 効果なし & 鉛直後ろ  \\
#64 & 効果なし & 鉛直右  \\
#128 & 効果なし & 鉛直の手前  \\
#256 & 効果なし & 天井の左後ろ \\
#512 & 効果なし & 天井の右後ろ  \\
#1024 & 効果なし & 天井の左手前  \\
#2048 & 効果なし & 天井の右手前  \\
%c c c .
%ビット @plot@splot
%_
%1@下@底の左手前
%2@左@底の左後ろ
%4@上@底の右手前
%8@右@底の右後ろ
%16@効果なし@鉛直左
%32@効果なし@鉛直後ろ
%64@効果なし@鉛直右
%128@効果なし@鉛直手前
%256@効果なし@天井の左後ろ
%512@効果なし@天井の右後ろ
%1024@効果なし@天井の左手前
%2048@効果なし@天井の右手前
@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="right">
^  <col align="center">
^  <col align="center">
^</colgroup>
^<thead>
^<tr>    <th>ビット</th>    <th>plot</th>    <th>splot</th></tr>
^</thead>
^<tbody>
^<tr>    <td>1</td>    <td>下</td>    <td>底の左手前</td></tr>
^<tr>    <td>2</td>    <td>左</td>    <td>底の左後ろ</td></tr>
^<tr>    <td>4</td>    <td>上</td>    <td>底の右手前</td></tr>
^<tr>    <td>8</td>    <td>右</td>    <td>底の右後ろ</td></tr>
^<tr>    <td>16</td>    <td>効果なし</td>    <td>鉛直左</td></tr>
^<tr>    <td>32</td>    <td>効果なし</td>    <td>鉛直後ろ</td></tr>
^<tr>    <td>64</td>    <td>効果なし</td>    <td>鉛直右</td></tr>
^<tr>    <td>128</td>    <td>効果なし</td>    <td>鉛直手前</td></tr>
^<tr>    <td>256</td>    <td>効果なし</td>    <td>天井の左後ろ</td></tr>
^<tr>    <td>512</td>    <td>効果なし</td>    <td>天井の右後ろ</td></tr>
^<tr>    <td>1024</td>    <td>効果なし</td>    <td>天井の左手前</td></tr>
^<tr>    <td>2048</td>    <td>効果なし</td>    <td>天井の右手前</td></tr>
^</tbody>
^</table>

 デフォルトの設定値は 31 で、これは `plot` では 4 方向の外枠全て、
 `splot` では底面の枠線全部と z 軸を描くことを意味します。

 2 次元描画では境界はすべての描画要素の一番上に描かれます (`front`)。
 もし境界を描画要素の下に描かせたい場合は、`set border back` としてくだ
 さい。

 3 次元隠線処理 (hidden3d) 描画では、通常は境界を構成する線も描画要素と
 同様に隠線処理の対象になります。`set border behind` とするとこのデフォ
 ルトの挙動が変わります。

 <line_style>, <line_type>, <line_width> を指定して、枠線の描画にそれ
 らを反映させることができます (現在の出力装置がサポートするものに限定
 されます)。

 `plot` では、第 2 軸を有効にすることで、下と左以外の境界に目盛りを描く
 ことができます。詳細は、以下参照: `xtics`。

 "`unset surface; set contour base`" などによって `splot` で底面にのみ
 描画する場合、鉛直線や天井はそれらが指定されていても描画されません。

 `set grid` のオプション 'back', 'front', 'layerdefault' でも、描画出力
 の境界線を書く順番を制御できます。

 例:

 以下は、デフォルトの枠線を描きます:
       set border

 以下は、`plot` では左と下、`splot` では底面の左手前と左後ろの枠線を描
 きます:
       set border 3

 以下は、`splot` で周りに完全な箱を描きます:
       set border 4095

 以下は、手前の鉛直面と天井のない箱を描きます:
       set border 127+256+512 # または set border 1023-128

 以下は、`plot` に対して上と右枠線のみを描き、それらを軸として目盛りづ
 けします:
       unset xtics; unset ytics; set x2tics; set y2tics; set border 12

3 棒グラフ幅 (boxwidth)
?commands set boxwidth
?commands show boxwidth
?set boxwidth
?show boxwidth
?boxwidth
 コマンド `set boxwidth` は `boxes`, `boxerrorbars`, `boxplot`,
 `candlesticks`, `histograms` スタイルにおける棒のデフォルトの幅を設定
 するために使います。

 書式:
       set boxwidth {<width>} {absolute|relative}
       show boxwidth

 デフォルトでは、隣り合う棒が接するように各々の棒の幅が広げられます。そ
 れとは異なるデフォルトの幅を設定するには `set boxwidth` コマンドを使用
 します。`relative` の場合の幅は、デフォルトの幅に対する比であると解釈
 されます。

 修飾子 `relative` を指定しなかった場合、棒の幅 (boxwidth) として指定さ
 れた明示的な値は、現在の x 軸の単位での数字 (`absolute`) であると解釈
 されます。x 軸が対数軸 (以下参照: `set log`) である場合、boxwidth の値
 は実際には x=1 でのみ "絶対的" となり、その物理的な長さが軸全体を通じ
 て保持されます (すなわち、棒は x 座標の増加にともなって狭くなったりは
 しません)。対数軸の x 軸の範囲が x=1 から離れている場合は、適切な幅を
 見出すには何度か試してみる必要があるかも知れません。

 デフォルトの値は、`boxes` や `boxerrorbars` スタイルの幅指定用の追加の
 データ列の明示的な値があればそれによって置き換えられます。4 列のデータ
 の場合、第 4 列目の値が棒の幅として使われます。ただし、その幅が -2.0
 の場合には棒の幅は自動計算されます。詳細は、以下参照: `style boxes`,
 `style boxerrorbars`。

 棒の幅を自動的にセットするには
       set boxwidth

 とする、あるいは 4 列のデータに対しては以下のようにします。
       set boxwidth -2

 `plot` のキーワード `using` を使っても同じ効果を得ることができます:
       plot 'file' using 1:2:3:4:(-2)

 棒の幅を自動的な値の半分にするには
       set boxwidth 0.5 relative

 棒の幅を絶対的な値 2 にするには
       set boxwidth 2 absolute
3 色巡回列 (colorsequence)
?commands set colorsequence
?set colorsequence
?colorsequence
 書式:
      set colorsequence {default|classic|podo}

 `set colorsequence default` は、出力形式に依存しない 8 色の巡回列を選
 択します。以下参照: `set linetype`, `colors`。

 `set colorsequence classic` は、出力形式別にそのドライバが用意する線色
 の列を選択します。色の種類は、4 色から 100 色超まで幅がありますが、そ
 の多くは、赤、緑、青、紫、水色、黄色、で始まります。これが以前の版の
 gnuplot のデフォルトの挙動です。

 `set colorsequence podo` は、Wong (2011) [Nature Methods 8:441] で推奨
 されている、P 型、D 型 (Protanopia, Deuteranopia) の色弱者が容易に区別
 できる 8 色の組を選択します。

 いずれの場合でも、色列の長さとその色についてはさらにカスタマイズできま
 す。以下参照: `set linetype`, `colors`。
3 clabel
?commands set clabel
?commands unset clabel
?commands show clabel
?set clabel
?unset clabel
?show clabel
?clabel
 このコマンドは非推奨です。代わりに `set cntrlabel` を使用してください。
 `unset clabel` は `set cntrlabel onecolor` に、`set clabel "format"`
 は `set cntrlabel format "format"` に置き換わっています。
3 クリッピング (clip)
?commands set clip
?commands unset clip
?commands show clip
?set clip
?unset clip
?show clip
?clip
?noclip
 `gnuplot` はグラフの端の辺りのデータ点や線をクリッピングすることができ
 ます。

 書式:
         set clip <clip-type>
         unset clip <clip-type>
         show clip

 `gnuplot` は点や線に対するクリップ型 (clip-type) として、`points`,
 `one`, `two` の 3 種類をサポートしています。ある描画に対して、これらの
 クリップ型は任意の組み合せで設定することができます。`pm3d` の色地図や
 カラー曲面で塗りつぶされた四角形はこのコマンドでは制御できませんが、
 `set pm3d clip1in` や `set pm3d clip4in` によって可能であることに注意
 してください。

 クリップ型 `points` を設定すると、描画領域内にはあるけれど境界線に非
 常に近いような点をクリップする (実際には描画しないだけですが) ように
 `gnuplot` に指示します。これは点として大きなマークを使用したときに、
 そのマークが境界線からはみ出さないようにする効果があります。`points`
 をクリップしない場合、境界線の辺りの点が汚く見えるかもしれません。
 その場合、x や y の描画範囲 (xrange, yrange) を調整してみて下さい。

 クリップ型 `one` を設定すると、一端のみが描画領域にあるような線分も
 描画するように `gnuplot` に指示します。この際、描画領域内にある部分
 のみが実際に描画される範囲です。設定しなかった場合、このような線分は
 描画対象とならず、どの部分も描画されません。

 両端は共に描画範囲に無いが描画領域を通過するという線分もあります。
 クリップ型 `two` を設定することによって、このような線分の描画領域の
 部分を描画することができます。

 どのような状況でも、描画範囲の外に線が引かれることはありません。

 デフォルトでは、`noclip points`, `clip one`, `noclip two` となって
 います。

 全てのクリップ型の設定状況を見るには以下のようにします:
         show clip

 過去のバージョンとの互換性のため以下の書式も使用可能です:
        set clip
        unset clip

 `set clip` は `set clip points` と同義です。`unset clip` は 3 種の
 クリップ型全てを無効にします。
3 等高線ラベル (cntrlabel)
?commands set cntrlabel
?commands show cntrlabel
?set cntrlabel
?show cntrlabel
?cntrlabel
 書式:
       set cntrlabel {format "format"} {font "font"}
       set cntrlabel {start <int>} {interval <int>}
       set contrlabel onecolor

 `set cntrlabel` は、凡例内 (デフォルト) か、`splot ... with labels` の
 際のグラフ上の等高線のラベルを制御します。後者の場合、ラベルはラベル記
 述属性の "pointinterval" に従って各等高線に沿って配置されます。デフォ
 ルトではラベルは等高線を構成する 5 番目の線分の上に置かれ、20 個の線分
 毎に繰り返されます。
 このデフォルトは、以下と同じです:
       set cntrlabel start 5 interval 20
 これらの値はコマンド `set cntrlabel` で、あるいは `splot` コマンドに間
 隔を指定することで変更できます:
       set contours; splot $FOO with labels point pointinterval -1
 間隔を負の値に設定すると、ラベルは各等高線に 1 つだけつきます。しかし
 `set samples` か `set isosamples` が大きな値の場合は多くの等高線をラベ
 ル一つだけで描きます。

 凡例 (key) には、等高線ラベルをそれぞれの線種 (linetype) を使用して書
 きます。デフォルトでは、線種自身が各等高線のレベルを与えるので、それぞ
 れに対する別々のラベルが現れます。コマンド `set cntrlabel onecolor` は
 すべての等高線を同じ線種で描画するので、凡例には一つのラベルのみを書き
 ます。このコマンドは、古いコマンド `unset clabel` を置き換えるものです。
3 等高線制御 (cntrparam)
?commands set cntrparam
?commands show cntrparam
?set cntrparam
?show cntrparam
?cntrparam
 `set cntrparam` は等高線の生成方法、およびそれを滑らかに描画する方法を
 制御します。`show contour` は現在の `contour` の設定だけでなく `cntrparam`
 の設定をも表示します。

 書式:
       set cntrparam { { linear
                       | cubicspline
                       | bspline
                       | points <n>
                       | order <n>
                       | levels { auto {<n>} | <n>
                                  | discrete <z1> {,<z2>{,<z3>...}}
                                  | incremental <start>, <incr> {,<end>}
                                }
                       }
                     }
       show contour

 このコマンドは 2 つの機能を持っています。一つは等高線上の点 (データ点
 の線形補間、あるいは関数の標本化 (isosample) による点) での z の値の設
 定で、もう一つは、そのように決定された z が等しい点同士を等高線で結ぶ
 方法の制御です。<n> は整数型の定数式、<z1>, <z2> ... は任意の定数式で
 す。各オプション変数の意味は次の通りです:

 `linear`, `cubicspline`, `bspline` --- 近似 (補間) 方法を指定します。
 `linear` ならば、等高線は曲面から得られた値を区分的に直線で結びます。
 `cubicspline` (3 次スプライン) ならば、区分的な直線はいくぶんなめらか
 な等高線が得られるように補間されますが、多少波打つ可能性があります。
 `bspline` (B-spline) は、より滑らかな曲線を描くことが保証されますが、
 これは z の等しい点の位置を近似しているだけです。

 `points` --- 最終的には、全ての描画は、区分的な直線で行われます。ここ
 で指定する数は、`bspline` または `cubicspline` での近似に使われる線分
 の数を制御します。実際には cubicspline と bspline の区間 (曲線線分) の
 数は `points` と線分の数の積に等しくなります。

 `order` --- bspline 近似の次数です。この次数が大きくなるにつれて、等高
 線はなめらかになります (もちろん、高次の bspline 曲線になるほど、元の
 区分的直線からは離れていきます)。このオプションは `bspline` モードでの
 み有効です。指定できる値は、2 (直線) から 10 までの整数です。

 `levels` --- 等高線のレベルの数は、`auto` (デフォルト), `discrete`,
 `incremental` と等高線のレベル数 <n> で制御します。

 `auto` では、<n> は仮のレベルの数であり、実際のレベルの数は、簡単なラ
 ベルを生成するように調節されます。曲面の z 座標が zmin から zman の範
 囲にあるとき、等高線はその間の dz の整数倍になるように生成されます。こ
 こで、dz は 10 のあるべき乗の 1, 2, 5 倍、のいずれかです (2 つの目盛り
 の間を丁度割り切るように)。

 `levels discrete` では、等高線は指定された z = <z1>, <z2> ... に対して
 生成されます。指定した個数が等高線のレベルの個数となります。`discrete`
 モードでは、`set cntrparams levels <n>` という指定は常に無視されます。

 `incremental` では、等高線は z = <start> から始まり、<increment> ずつ
 増えて行き限界の個数に達するまで書かれます。<end> はその等高線の数を決
 定するのに使われますが、これは後の `set cntrparam levels <n>` によって
 常に変更されます。z 軸が対数軸の場合、`set ztics` の場合と同様に、
 <increment> は倍数として解釈されます。

 コマンド `set cntrparam` が引数なしに呼ばれた場合は、次のデフォルトの
 値が使われます: linear, 5 points, order 4, 5 auto levels

 例:
       set cntrparam bspline
       set cntrparam points 7
       set cntrparam order 10

 以下はレベルの基準が合えば 5 個のレベルがに自動的に選択されます:
       set cntrparam levels auto 5

 以下は .1, .37, .9 にレベルを設定します:
       set cntrparam levels discrete .1,1/exp(1),.9

 以下は 0 から 4 まで、1 ずつ増やすレベルを設定します:
       set cntrparam levels incremental  0,1,4

 以下はレベルの数を 10 に設定します (増加の最後の値 (end) または自動で
 設定されるレベルの数は変更されます):
       set cntrparam levels 10

 以下はレベルの数は保持したままレベルの開始値と増分値を設定します:
       set cntrparam levels incremental 100,50

 等高線を描く場所の制御に関しては、以下参照: `set contour`。等高線のラ
 ベルの書式と線種の制御に関しては、以下参照: `set cntrlabel`。

 以下も参照してください。
^ <a href="http://www.gnuplot.info/demo/contours.html">
 等高線のデモ (contours.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/discrete.html">
 ユーザ定義レベルの等高線のデモ (discrete.dem).
^ </a>
3 カラーボックス (colorbox)
?commands set colorbox
?commands show colorbox
?commands unset colorbox
?set colorbox
?show colorbox
?unset colorbox
?colorbox

 色の一覧表、すなわち `pm3d` の `palette` の min_z から max_z までの滑
 らかな色の勾配は、`unset colorbox` が使われていない限りカラーボックス
 (colorbox) に描かれます。

       set colorbox
       set colorbox {
                  { vertical | horizontal }
                  { default | user }
                  { origin x, y }
                  { size x, y }
                  { front | back }
                  { noborder | bdefault | border [line style] }
                }
       show colorbox
       unset colorbox

 カラーボックスの位置は、`default` または `user` で指定でき、後者の場合
 その位置や大きさを `origin` や `size` コマンドで設定します。カラーボッ
 クスは、グラフや曲面の後 (`front`) あるいは先 (`back`) に描画させるこ
 ともできます。

 色勾配の方向は、オプション `vertical` と `horizontal` で切替えることが
 可能です。

 `origin x, y` と `size x, y` は `user` オプションとの組でのみ使用され
 ます。x, y の値は、デフォルトではスクリーン座標と解釈されますが、これ
 は 3 次元描画用のかしこまったオプションに過ぎません。`set view map` に
 よる splot を含む 2 次元描画では、任意の座標系での指定が可能です。例え
 ば以下を試してみてください:
     set colorbox horiz user origin .1,.02 size .8,.04
 これは水平方向の色勾配をグラフの下の辺りに描画します。

 `border` は境界描画を ON にします (デフォルト) し、`noborder` は境界描
 画を OFF にします。`border` の後ろに正の整数を与えると、それを境界を描
 画する時の line style のタグとして使います。例えば:
     set style line 2604 linetype -1 linewidth .4
     set colorbox border 2604
 は line style `2604`、すなわち細い線のデフォルトの境界色 (-1) で境界を
 描画します。`bdefault` (デフォルト) は、カラーボックスの境界の描画にデ
 フォルトの境界の line style を使います。

 カラーボックスの軸は `cb` と呼ばれ、通常の軸のコマンドで制御されます。
 すなわち `set/unset/show` で `cbrange`, `[m]cbtics`, `format cb`,
 `grid [m]cb`, `cblabel` などが、そして多分 `cbdata`, `[no]cbdtics`,
 `[no]cbmtics` なども使えるでしょう。

 パラメータ無しの `set colorbox` はデフォルトの位置へ切替えます。
 `unset colorbox` はカラーボックスのパラメータをデフォルト値にリセット
 し、その上でカラーボックスを OFF にします。

 以下も参照: `set pm3d`, `set palette`, `x11 pm3d`, `set style line`。
3 色名 (colornames)
?colornames
?show colornames
?commands show colornames
?show palette colornames
 gnuplot は限定された個数の色の名前を持っています。これらは、pm3d パレ
 ットでつながれる色の範囲を定義するのに、あるいは個々の線種やラインスタ
 イルの色を出力形式に依存しない形で定義したりするのに使えます。gnuplot
 の持つ色名の一覧を見るには、コマンド `show colornames` を使用してくだ
 さい。例:

       set style line 1 linecolor "sea-green"
3 等高線 (contour)
?commands set contour
?commands unset contour
?commands show contour
?set contour
?unset contour
?show contour
?contour
?contours
?nocontour
 コマンド `set contour` は曲面の等高線を引くことを指示します。このオプ
 ションは `splot` でのみ有効です。これは、格子状データ (grid data) を必
 要とします。詳細は、以下参照: `grid_data`。非格子状データで等高線を描
 きたい場合は、格子を生成するために `set dgrid3d` を使用します。

 書式:
       set contour {base | surface | both}
       unset contour
       show contour

 これらの 3 つのオプションは等高線をどこに引くかを指定します。`base` で
 は等高線を x/y 軸の刻みのある底面に描かれ、`surface` では等高線はその
 曲面自体の上に描かれ、`both` では底面と曲面上の両方に描かれます。オプ
 ションが指定されていない場合は `base` であると仮定されます。

 等高線の描画に影響を与えるパラメータについては、以下参照:
 `set cntrparam`。等高線のラベルの制御に関しては、以下参照:
 `set cntrlabel`。

 等高線のみのグラフを得るために、曲面自身の描画をしないようにすることも
 できます (以下参照: `unset surface`)。`set size` を使って、グラフを画
 面一杯に描画することも可能ですが、そういった出力形式よりも、等高線のデ
 ータをデータブロックに書き出し、それを再び 2 次元データとして読み込ん
 で描画すればよりよい制御が可能になります:

       unset surface
       set contour
       set cntrparam ...
       set table $datablock
       splot ...
       unset table
       # 等高線の情報は今 $datablock の中にある
       set term <whatever>
       plot $datablock

 等高線を描くためには、データは格子状データ ("grid data") である必要が
 あります。そのようなファイルでは、一つの y-孤立線上の全ての点が順に
 並べられていきます。そして隣の y-孤立線上の点が順に並べられ、そして隣、
 と続いていきます。y-孤立線同士を分離するには一行の空行 (空白、復帰、改
 行以外の文字を含まない行) を挟みます。以下参照: `splot datafile`。

 以下も参照してください。
^ <a href="http://www.gnuplot.info/demo/contours.html">
 等高線のデモ (contours.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/discrete.html">
 ユーザ定義レベルの等高線のデモ (discrete.dem).
^ </a>
3 点線/破線設定 (dashtype)
?commands set dashtype
?commands show dashtype
?set dashtype
?show dashtype
 コマンド `set dashtype` は、点線/破線パターンを番号で参照できるように
 登録します。これはとても便利で、その点線/破線パターンをその番号で受け
 つけてくれる場所ならば、どこでも明示的な点線/破線パターンも受けつけて
 くれます。
 例:
      set dashtype 5 (2,4,2,6)   # 5 番の dashtype を定義または再定義
      plot f1(x) dt 5            # その dashtype を使って plot
      plot f1(x) dt (2,4,2,6)    # 上と全く同じグラフ
      set linetype 5 dt 5        # このパターンを linetype 5 で常に使う
      set dashtype 66 "..-"      # 文字列で新しい dashtype を定義
 以下参照: `dashtype`。
3 data style
?set data style
 このコマンドの形式は現在は推奨されていません。以下参照:
 `set style data`。
3 datafile
?set datafile
?show datafile
 コマンド `set datafile` は、`plot`, `splot`, `fit` コマンドで入力デー
 タを読む場合に、その列 (field) の解釈の仕方を制御するオプションを持ち
 ます。現在は、6 つのそのようなオプションが実装されています。
4 set datafile fortran
?set datafile fortran
?show datafile fortran
?fortran
 コマンド `set datafile fortran` は、入力ファイルの Fortran D 型、Q 型
 の定数値の特別なチェックを可能にします。この特別なチェックは入力処理を
 遅くしますので、実際にそのデータファイルが Fortran D 型、Q 型の定数を
 持っている場合にのみこれを選択すべきです。このオプションは、その後で
 `unset datafile fortran` を行えば無効にできます。
4 set datafile nofpe_trap
?set datafile nofpe_trap
?fpe_trap
?nofpe_trap
=floating point exceptions
 コマンド `set datafile nofpe_trap` は、入力ファイルからデータの読み込
 みの際に、すべての数式の評価の前に浮動小数点例外ハンドラの再初期化をし
 ないように gnuplot に命令します。これにより、とても大きなファイルから
 のデータの入力がかなり速くなりますが、浮動小数点例外が起きた場合にプロ
 グラムが異常終了してしまう危険はあります。
4 set datafile missing
?set datafile missing
?show datafile missing
?set missing
?missing
 コマンド `set datafile missing` は、入力データファイル中で欠損データを
 記述する特別な文字列があることを `gnuplot` に指示します。`missing` に
 関するデフォルト値はありませんが、数値を期待する場面で数値とは認識でき
 ない文字列に出会った場合は、たいていその行は欠損データであると扱われる
 ことになります。欠損データと無効な値 (例えば "NaN" や 1/0) は区別され
 ます。無効な値は、その点を通るグラフの曲線がそこで切れますが、欠損デー
 タの場合はそうではありません。

 書式:
       set datafile missing "<string>"
       show datafile missing
       unset datafile

 `注意`: このバージョンの gnuplot では、ある場合の処理の方法が変更され
 ています。以下の例でその違いを示します。
Ffigure_missing
 例:
       set style data linespoints
       plot '-' title "(a)"
          1 10
          2 20
          3 ?
          4 40
          5 50
          e
       set datafile missing "?"
       plot '-' title "(b)"
          1 10
          2 20
          3 ?
          4 40
          5 50
          e
       plot '-' using 1:2 title "(c)"
          1 10
          2 20
          3 NaN
          4 40
          5 50
          e
       plot '-' using 1:($2) title "(d)"
          1 10
          2 20
          3 NaN
          4 40
          5 50
          e

 (a) のグラフは、3 行目に 1 つ無効値があるため、バージョン間の違いがあ
 ります。古い版の gnuplot では、そこに 1 行に 1 つしかデータがなかった
 場合の規則を適用し、行番号を "x" に、データを "y" と見なし、誤ってその
 点を (2,3) に描画していました。

 文字 '?' が欠損データを意味するものとして指定されている (b) では、古い
 版の gnuplot でも新しい版でも同じデータを正しく処理します。

 (c), (d) のグラフに見られるように、古い gnuplot では NaN を using の指
 定の仕方によって異なった処理をしていました。現在は、gnuplot は入力列と
 して N と指定されていても ($N) と指定されていても NaN に対しては同じ処
 理を行います。以下のデモも参照してください。
^ <a href="http://www.gnuplot.info/demo/mgr.html">
 imageNaN デモ。
^ </a>

4 set datafile separator
?set datafile separator
?show datafile separator
?datafile separator
?separator
 コマンド `set datafile separator` は、この後の入力ファイルのデータ列の
 分離文字が、空白 (whitespace) でなくて、ここで指定する文字であると
 `gnuplot` に指示します。このコマンドの最も一般的な使用例は、表計算ソフ
 トやデータベースソフトが作る csv (コンマ区切り) ファイルを読む場合でし
 ょう。デフォルトのデータ列の分離文字は空白 (whitespace) です。

 書式:
       set datafile separator {whitespace | tab | comma | "<chars>"}

 例:
       # タブ区切りのファイルを入力
       set datafile separator "\t"

       # コンマ区切りのファイルを入力
       set datafile separator comma

       # 入力ファイルが * か | のいずれかで区切られた列を持つ場合
       set datafile separator "*|"
4 set datafile commentschars
?set datafile commentschars
?commentschars
 コマンド `set datafile commentschars` は、どの文字がデータファイル中の
 コメント行の開始文字を意味するのかを `gnuplot` に指示します。指定され
 た文字の中の一つがデータ行の最初の非空白文字として現われた場合、その入
 力行のそれ以降の部分を無視します。デフォルト文字列は、VMS では "#!"、
 それ以外では "#" です。

 書式:
       set datafile commentschars {"<string>"}
       show datafile commentschars
       unset commentschars

 よって、データファイルの以下の行は完全に無視されます:
     # 1 2 3 4
 が、以下の行
     1 # 3 4
 は、もし
     set datafile missing '#'
 が同時に指定されていなければ、予期せぬ結果を生じます。

 例:
       set datafile commentschars "#!%"
4 set datafile binary
?set datafile binary
 コマンド `set datafile binary` は、データファイルの読み込み時にバイナ
 リファイルをデフォルトと設定するのに使われます。書式は、それが `plot`
 または `splot` コマンドで使われるのと正確に同じです。<binary list> に
 書けるキーワードに関しては、詳しくは、以下参照: `binary matrix`,
 `binary general`。

 書式:
       set datafile binary <binary list>
       show datafile binary
       show datafile
       unset datafile

 例:
       set datafile binary filetype=auto
       set datafile binary array=(512,512) format="%uchar"

?show datafile binary
       show datafile binary   # 現在の設定の一覧表示
3 小数点設定 (desimalsign)
?commands set decimalsign
?commands show decimalsign
?commands unset decimalsign
?set decimalsign
?show decimalsign
?unset decimalsign
?decimalsign
=locale
 コマンド `set decimalsign` は、目盛りの見出し、あるいは `set label` 文
 字列に書かれる数の小数点記号を選択します。

 書式:
       set decimalsign {<value> | locale {"<locale>"}}
       unset decimalsign
       show decimalsign

 引数 <value> は、通常の小数点記号に置き換えて使う文字列です。典型的な
 ものはピリオド '.' やコンマ ',' ですが他にも有用なものがあるでしょう。
 引数 <value> を省略すると、小数点の区切りはデフォルト (ピリオド) から
 変更されません。unset decimalsign も <value> を省略するのと同じ効果を
 持ちます。

 例:

 多くのヨーロッパ諸国での正しい出力形式を得るには:
       set decimalsign ','

 次のことに注意してください: 明示的な文字列を設定した場合、これは軸の目
 盛りなどの gnuplot の gprintf() 書式関数で出力される数値のみに影響し、
 入力データの書式指定や sprintf() 書式関数で出力される数値には影響しま
 せん。それらの入力や出力の形式の挙動も変更したい場合は、代わりに以下を
 使用してください:

       set decimalsign locale

 これは、gnuplot に、入力と出力の書式を、環境変数 LC_ALL, LC_NUMERIC,
 LANG の現在の設定に従ったものを使わせるようにします。

       set decimalsign locale "foo"

 これは、gnuplot に、入力と出力の書式を、ロケール "foo" に従ったものに
 しますが、そのロケールがインストールされている必要があります。もしロケ
 ール "foo" が見つからなかった場合、エラーメッセージが出力され、小数点
 の設定は変更されません。linux システム上では、そこにインストールされて
 いるロケールの一覧は "locale -a" で見ることができます。linux のロケー
 ル文字列はだいたい "sl_SI.UTF-8" のような形式をしていますが、Windows
 のロケール文字列は "Slovenian_Slovenia.1250"、または "slovenian" のよ
 うな形式です。ロケール文字列の解釈は、C のランタイムライブラリが行うこ
 とに注意してください。古い C ライブラリでは、ロケール設定のサポート
 (例えば数字の 3 桁毎の区切り文字など) を部分的にしか提供していないかも
 しれません。

       set decimalsign locale; set decimalsign "."

 これは、現在のロケールに合ったどんな小数点でも、全ての入出力に対して使
 用するように設定しますが、gnuplot の内部関数 gprintf() を使って書式化
 する数値は明示的に指定された '.' になります (上書き)。
3 格子状データ処理 (dgrid3d)
?commands set dgrid3d
?commands unset dgrid3d
?commands show dgrid3d
?set dgrid3d
?unset dgrid3d
?show dgrid3d
?dgrid3d
?nodgrid3d
=kdensity
 コマンド `set dgrid3d` は、非格子状データから格子状データへの写像機能を
 有効にし、そのためのパラメータを設定します。格子状データの構造について
 の詳細は、以下参照: `splot grid_data`。

 書式:
       set dgrid3d {<rows>} {,{<cols>}}
                   { splines |
                     qnorm {<norm>} |
                     (gauss | cauchy | exp | box | hann)
                       {kdensity} {<dx>} {,<dy>} }
       unset dgrid3d
       show dgrid3d

 デフォルトでは `dgrid3d` は無効になっています。有効になると、ファイル
 から読み込まれる 3 次元のデータは「散在した」データ (非格子状データ)
 であると見なされます。格子は、グラフと等高線の描画のために、散在したデ
 ータを囲む矩形から得られる寸法と、row_size/col_size で指定される数の行
 と列を持つように生成されます。格子は x 方向 (行) と y 方向 (列) に等間
 隔です。z の値は散在するデータの z の値の重み付きの平均、またはスプラ
 イン補間として計算されます。言い変えれば、規則的な間隔の格子が生成され、
 全ての格子点で元のデータの滑かな近似値が評価されます。元のデータの代わ
 りにこの近似値が描画されます。

 デフォルトの列の数は行の数に等しく、そのデフォルトの値は 10 です。

 元のデータから近似値を計算するためのいくつかのアルゴリズムが用意されて
 いて、追加のパラメータを指定できるものもあります。これらの補間は、格子
 点に近いデータ点ほど、その格子点に対してより強い影響を与えます。

 `splines` アルゴリズムは、"薄いつぎ板" を元にした補間計算を行います。
 これは追加パラメータを取りません。

 `qnorm` アルゴリズムは各格子点で入力データの重み付き平均を計算します。
 各点は格子点からの距離の norm 乗の逆数で重み付けされます。(実際には、
 dx, dy を各データ点と格子点との差の成分であるとすると、重みは dx^norm
 + dy^norm で与えられます。2 のべきのノルム、特に 4, 8, 16 に関しては、
 その重みの計算はユークリッド距離を使うことで (dx^2+dy^2)^norm/2 のよう
 に最適化されてますが、任意の負でない整数を使うことも可能です。) ノルム
 のべきの値をただ一つの追加パラメータとして指定できます。このアルゴリズ
 ムがデフォルトになっています。

 最後に、重み付き平均の計算用に、いくつかの平滑化重み付け関数 (kernel)
 が用意されています: z = Sum_i w(d_i) * z_i / Sum_i w(d_i), ここで z_i
 は i 番目のデータの値で、d_i は現在の格子点と i 番目のデータ点の位置と
 の距離です。すべての重み付け関数が、現在の格子点に近い方のデータ点には
 大きな重み、遠い方のデータ点には小さい重みを付けます。

 以下の重み付け関数が使用できます:
       gauss :     w(d) = exp(-d*d)
       cauchy :    w(d) = 1/(1 + d*d)
       exp :       w(d) = exp(-d)
       box :       w(d) = 1                     d<1 の場合
                        = 0                     その他
       hann :      w(d) = 0.5*(1-cos(2*pi*d))   d<1 の場合
                   w(d) = 0                     その他

 これら 5 つの平滑化重み付け関数のうち一つを使用する場合、2 つまでの追
 加パラメータ dx と dy を指定できます。これらは、距離の計算時に座標の違
 いをスケール変換するのに使えます:
 d_i = sqrt( ((x-x_i)/dx)**2 + ((y-y_i)/dy)**2 ), ここで、x,y は現在の
 格子点の座標で、x_i,y_i は i 番目のデータ点の座標です。dy のデフォルト
 の値は dx で、そのデフォルトの値は 1 になっています。パラメータ dx と
 dy は、データ点が格子点へ「データそれ自身の単位で」の寄与を行う範囲の
 制御を可能にします。

 オプションキーワード `kdensity` は、重み付け関数名の後ろで (オプション
 の) スケール変換のパラメータの前に置くもので、これはアルゴリズムを変更
 して、格子点用に計算する値を重みの和 ( z = Sum_i w(d_i) * z_i ) では割
 らないようにします。z_i がすべて定数の場合、これは事実上 2 変数の重み
 付け評価を描画します: (上の 5 つのうちの一つの) 重み付け関数が各データ
 点に置かれ、それらの重みの和がすべての格子点で評価され、そして元のデー
 タの代わりにこの滑らかな曲面が描画されます。これは、1 次元のデータ集合
 に対する `smooth kdensity` オプションが行うこととおおまかには同じです
 (使用例は kdensity2d.dem を参照してください)。

 後方互換性のために、わずかに異なる書式もサポートされています。どのアル
 ゴリズムも明示的に選択しなかった場合、`qnorm` アルゴリズムが仮定され、
 3 つ以下の、コンマ (,) 区切りのオプションパラメータを指定した場合は、
 それらをそれぞれ行数、列数、そして norm 値であると解釈します。

 オプション `dgrid3d` は、散在するデータを重み付き平均で規則的な格子に
 置き変える単純な仕組みに過ぎません。この問題に対するより洗練された手法
 が存在しますので、この単純な方法が不十分であれば、`gnuplot` の外でその
 ような方法でデータを前処理するべきでしょう。

 以下も参照
^ <a href="http://www.gnuplot.info/demo/dgrid3d.html">
 dgrid3d.dem: dgrid3d のデモ
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/scatter.html">
 scatter.dem: dgrid3d のデモ
^ </a>

3 仮変数 (dummy)
?commands set dummy
?commands show dummy
?set dummy
?show dummy
?unset dummy
?dummy
 コマンド `set dummy` はデフォルトの仮変数名を変更します。

 書式:
       set dummy {<dummy-var>} {,<dummy-var>}
       show dummy

 デフォルトでは、`gnuplot` は `plot` では、媒介変数モード、あるいは極座
 標モードでは "t", そうでなければ "x" を独立変数 (仮変数) とし、同様に
 `splot` では、媒介変数モードでは (`splot` は極座標モードでは使えません)
 "u" と "v", そうでなければ "x" と "y" を独立変数とします。

 仮変数は、物理的に意味のある名前、あるいはより便利な名前として使う方が
 便利でしょう。例えば、時間の関数を描画する場合:

       set dummy t
       plot sin(t), cos(t)

 例:
       set dummy u,v
       set dummy ,s

 第二の例は、2 番目の変数を s とします。仮変数名をデフォルトの値に戻す
 には以下のようにしてください。

       unset dummy
3 文字エンコード (encoding)
?commands set encoding
?commands show encoding
?set encoding
?show encoding
?encoding
?encodings
=UTF-8
=SJIS
 コマンド `set encoding` は文字のエンコード (encoding) を選択します。

 書式:
       set encoding {<value>}
       set encoding locale
       show encoding

 有効な値 (value) は以下の通りです。
    default     - 出力形式にデフォルトのエンコードの使用を命令
    iso_8859_1  - 多くの Unix ワークステーションや MS-Windows で使用可
                  能な最も一般的な西ヨーロッパエンコード。このエンコー
                  ドは PostScript の世界で 'ISO-Latin1' として知られて
                  いるものです。
    iso_8859_15 - ユーロ記号を含む iso_8859_1 の亜種
    iso_8859_2  - 中央/東ヨーロッパで使用されるエンコード
    iso_8859_9  - (Latin5 として知られる) トルコで使用されるエンコード
    koi8r       - 良く使われる Unix のキリル文字エンコード
    koi8u       - Unix のウクライナ地方のキリル文字エンコード
    cp437       - MS-DOS のコードページ
    cp850       - 西ヨーロッパの OS/2 のコードページ
    cp852       - 中央/東ヨーロッパの OS/2 のコードページ
    cp950       - MS 版の Big5 (emf terminal のみ)
    cp1250      - 中央/東ヨーロッパの MS Windows のコードページ
    cp1251      - ロシア、セルビア、ブルガリア、マケドニア語 (8 ビット)
    cp1252      - 西ヨーロッパの MS Windows のコードページ
    cp1254      - トルコの MS Windows のコードページ (Latin5 の拡張)
    sjis        - Shift_JIS 日本語エンコード
    utf8        - 各文字の Unicode エントリポイントの、可変長 (マルチバ
                  イト) 表現

 コマンド `set encoding locale` は、他のオプションとは違い、これは現在
 のロカールを実行時の環境から決定しようとします。たいていのシステムでは
 これは環境変数 LC_ALL, LC_CTYPE, LANG のいずれかによって制御されます。
 この仕組みは、例えば wxt, cairopdf 出力形式で、UTF-8 や EUC-JP のよう
 なマルチバイト文字エンコードを通すために必要です。このコマンドは日付や
 数字などのロカール特有の表現には影響を与えません。
 以下も参照: `set locale`, `set decimalsign`。

 一般に、エンコードの設定は出力形式の設定の前に行なう必要があります。こ
 のエンコードはどんな出力形式でもサポートされているとは限らず、そして出
 力形式は要求されたどんな非標準文字も生成できなければいけません。
3 非線形関数回帰 (fit)
?commands set fit
?commands show fit
?set fit
?show fit
?set fit quiet
?set fit verbose
?set fit brief
?set fit results
?set fit prescale
?set fit limit
?set fit maxiter
?set fit errorscaling
?set fit errorvariables
?set fit logfile
?set fit script
?set fit v4
?set fit v5
 コマンド `set fit` は、`fit` コマンド用のオプションを制御します。

 書式:
       set fit {logfile {"<filename>"|default}}
               {{no}quiet|results|brief|verbose}
               {{no}errorvariables}
               {{no}covariancevariables}
               {{no}errorscaling}
               {{no}prescale}
               {maxiter <value>|default}
               {limit <epsilon>|default}
               {limit_abs <epsilon_abs>}
               {start-lambda <value>|default}
               {lambda-factor <value>|default}
               {script {"<command>"|default}}
               {v4 | v5}
       unset fit
       show fit

 オプション `logfile` は、`fit` コマンドがその出力を書き出す場所を定義
 します。 引数 <filename> は、単一引用符か二重引用符で囲む必要がありま
 す。ファイル名を指定しなかった場合、または `unset fit` を使用した場合
 は、ログファイルはデフォルトの値である "fit.log"、または環境変数
 `FIT_LOG` の値にリセットされます。与えられたログファイル名が / か \ で
 終っている場合、それはディレクトリ名と解釈され、ログファイルはそのディ
 レクトリの "fit.log" となります。

 デフォルトでは、そのログファイルに書かれる情報は、対話型出力にも出力し
 ます。`set fit quiet` はその対話型出力をオフにし、`results` は最終結果
 のみを出力します。`brief` は、追加で fit のすべての繰り返しに関して 1
 行の要約を提供します。`verbose` は、バージョン 5 以前でデフォルトだっ
 た、詳細な繰り返しの報告を行います。

 オプション `errorvariables` を ON にすると、`fit` コマンドで計算された
 個々の当てはめパラメータの誤差が、そのパラメータの名前に "_err" をつけ
 た名前のユーザ定義変数にコピーされます。これは主に、当てはめ関数とデー
 タの描画グラフの上にパラメータとその誤差を参照用に出力するのに使われま
 す。例:

        set fit errorvariables
        fit f(x) 'datafile' using 1:2 via a, b
        print "error of a is:", a_err
        set label 'a=%6.2f', a, '+/- %6.2f', a_err
        plot 'datafile' using 1:2, f(x)

 オプション `errorscaling` を指定すると (デフォルト)、パラメータの計算
 誤差を補正χ自乗 (reduced χ-square) で伸縮します。これは、結果として
 補正χ自乗値になる、当てはめ計算の標準偏差 (FIT_STDFIT) に等しいデータ
 誤差を提供することと同等になります。オプション `noerrorscaling` では、
 評価誤差は、伸縮されない当てはめパラメータの標準偏差になります。
 データの重みを指定しなければ、パラメータの誤差は常に伸縮されます。

 オプション `prescale` をオンにすると、Marquardt-Levenberg ルーチンに渡
 す前に、各パラメータの値をそれらの初期値に従って事前にスケール変換しま
 す。これは、各パラメータの大きさにかなり大きな違いがある場合に、大変有
 効です。ただし、初期値が完全に 0 の当てはめパラメータには、決してこの
 スケール変換は行いません。

 反復数の限界値は、オプション `maxiter` で制限できます。それを 0 か
 `default` とすると、それは限界がないことを意味します。

 オプション `limit` は、収束を検出するためのもっとも小さい数字の限界
 (1e-5) のデフォルトの値を変更するのに使えます。自乗残差の和がこの数値
 未満の比率の変化しかしない場合は、当てはめは「収束した」と判断されます。

 オプション `limit_abs` は、自乗残差の和の変化の限界 (絶対値) を追加し
 ます。デフォルトは 0 です。

 アルゴリズムに関する別の制御をしたい場合、そして Marquardt-Levenberg
 アルゴリズムを良く知っている場合、それに影響を与える以下のオプションが
 利用できます: `lambda` の初期値は、通常自動的に ML-行列から計算されま
 すが、必要ならばオプション `start_lambda` を使ってそれを与えることがで
 きます。それを `default` とすると、再び自動設定が有効になります。オプ
 ション `lambda_factor` は、対象とする関数のχ自乗値が意味ありげに増加
 する/減少するときは常に `lambda` を増加させる/減少させる因子を設定しま
 す。それを `default` とすると、デフォルトの因子である 10.0 にします。

 オプション `script` は、fit を中断したときに実行する `gnuplot` コマン
 ドを指定するものです。以下参照: `fit`。この設定はデフォルトの `replot`
 や環境変数 `FIT_SCRIPT` よりも優先順位は上です。

 オプション `covariancevariables` をオンにすると、最終的なパラメータ間
 の共分散をユーザ定義変数に保存します。各パラメータの組に対してその共分
 散を保存する変数名は、"FIT_COV_" に最初のパラメータ名と "_" と 2 つ目
 のパラメータをつなげた名前になります。例えばパラメータ "a" と "b" に対
 しては、その共分散変数名は "FIT_COV_a_b" となります。

 バージョン 5 では、コマンド fit の書式は変更され、キーワード `error`
 が指定されていない場合は単位重み (`unitweights`) がデフォルトになりま
 した。オプション `v4` で gnuplot バージョン 4 のデフォルトの挙動に戻り
 ます。以下も参照: `fit`。
3 フォントパス (fontpath)
?commands set fontpath
?commands show fontpath
?set fontpath
?show fontpath
?fontpath
 `fontpath` の設定は、フォントファイルを読み込む場合のファイルの検索パ
 スを追加定義します。今のところ、postscript 出力形式のみが `fontpath`
 をサポートしています。ファイルが現在のディレクトリに見つからなかった場
 合、`fontpath` のディレクトリが検索されます。サポートしているフォント
 ファイルの形式に関するより詳しい説明は `terminal postscript` セクショ
 ンの文書中にあります。

 書式:
       set fontpath {"pathlist1" {"pathlist2"...}}
       show fontpath

 パス名は単一のディレクトリ名、または複数のパス名のリストとして入力しま
 す。複数のパスからなるパスリストは OS 固有のパス区切り、例えば Unix で
 はコロン (':'), MS-DOS, Windows, OS/2 ではセミコロン (';') 等で区切り
 ます。`show fontpath`, `save`, `save set` コマンドは、可搬性のために
 OS 固有のパス区切りをスペース (' ') で置き換えます。ディレクトリ名がエ
 クスクラメーションマーク ('!') で終っている場合、そのディレクトリのサ
 ブディレクトリも検索されます。

 環境変数 GNUPLOT_FONTPATH が設定されている場合、その内容は `fontpath`
 に追加されますが、それが設定されていない場合システムに依存したデフォル
 トの値が使用されます。最初にフォントパスを使ったときに、その幾つかのデ
 ィレクトリが存在するかテストされ、セットされます。よって、一番最初の
 `set fontpath`, `show fontpath`, `save fontpath` や、埋め込みフォント
 を使用した場合の `plot`, `splot` は、少し時間がかかります。それを少し
 でも短くしたければ、環境変数 GNUPLOT_FONTPATH を設定してください。そう
 すればディレクトリのチェックは OFF になります。デフォルトのフォントパ
 スが何であるかは、`show fontpath` で見ることができます。

 `show fontpath` は、ユーザ定義の fontpath とシステムの fontpath を別々
 に表示しますが、`save`, `save set` コマンドは、ユーザ定義の `fontpath`
 のみを保存します。

 gd ライブラリを通じてファイル名でフォントにアクセスする出力ドライバに
 関しては、フォント検索パスは環境変数 GDFONTPATH で制御されます。
3 軸の刻み書式 (format)
?commands set format
?commands show format
?set format
?show format
?format
?format cb
 座標軸の刻みの見出しは、コマンド `set format` または `set tics format`
 または個別にコマンド `set {軸}tics format` で書式を設定できます。

 書式:
       set format {<axes>} {"<format-string>"} {numeric|timedate|geographic}
       show format

 ここで、<axes> (軸) は `x`, `y`, `xy`, `x2`, `y2`, `z`, `cb`、または何
 も指定しないか (その場合その書式はすべての軸に適用されます) のいずれか
 です。以下の 2 つのコマンドは全く同等です:
       set format y "%.2f"
       set ytics format "%.2f"

 書式文字列の長さは 100 文字まで、と制限されています。デフォルトの書式
 文字列は "% h" で、LaTeX 系の出力形式では "$%h$" です。他に "%.2f" や
 "%3.0em" のような書式が好まれることも多いでしょう。"set format" の後ろ
 に何もつけずに実行すると、デフォルトに戻します。

 空文字列 "" を指定した場合、刻み自身は表示しますが見出しはつけません。
 刻み自身を消すには、 `unset xtics` または `set tics scale 0` を使用し
 てください。

 書式文字列では、改行文字 (\n) や拡張文字列処理 (enhanced text) 用のマ
 ークアップも使えます。 この場合は、単一引用符 (') でなく (") を使って
 ください。以下も参照: `syntax`。
 "%" が頭につかない文字はそのまま表示されます。よって、書式文字列内に
 スペースや文字列などを入れることができます。例えば "%g m" とすれば、
 数値の後に " m" が表示されます。"%" 自身を表示する場合には "%g %%" の
 ように 2 つ重ねます。

 刻みに関するより詳しい情報については、以下も参照: `set xtics`。また、
 この方法で出力される数字にデフォルト以外の小数分離文字を使うやり方につ
 いては、以下参照: `set decimalsign`。
 以下も参照。
^ <a href="http://www.gnuplot.info/demo/electron.html">
 エレクトロン (電子) デモ (electron.dem).
^ </a>
4 gprintf
?gprintf
 文字列関数 gprintf("format",x) は、gnuplot コマンドの `set format`,
 `set timestamp` などと同様の、gnuplot 独自の書式指定子を使います。これ
 らの書式指定子は、標準的な C 言語の関数である sprintf() のものと全く同
 じではありません。gprintf() は、整形化される引数は一つしか受けつけませ
 ん。そのために、gnuplot には sprintf("format",x1,x2,...) 関数も用意さ
 れています。gnuplot の書式オプションの一覧については、以下参照:
 `format specifiers`。
4 書式指定子 (format specifiers)
?commands set format specifiers
?set format specifiers
?format specifiers
?format_specifiers
 使用可能な書式 (時間/日付モードでない場合) は以下の通りです:

@start table - first is interactive cleartext form
       書式       説明
       %f         固定小数点表記
       %e, %E     指数表記; 指数の前に "e", "E" をつける
       %g, %G     %e (または %E) と %f の略記
       %h, %H     %g に "e%S" でなく "x10^{%S}" か "*10^{%S}" をつける
       %x, %X     16 進表記
       %o, %O     8 進表記
       %t         10 進の仮数部
       %l         現在の対数尺の底を基数とする仮数部
       %s         現在の対数尺の底を基数とする仮数部; 補助単位 (scientific power)
       %T         10 進の指数部
       %L         現在の対数尺の底を基数とする指数部
       %S         補助単位の指数部 (scientific power)
       %c         補助単位文字
       %b         ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の仮数部
       %B         ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の接頭辞
       %P         πの倍数
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{目盛りラベルの数値書式指定子}\\
#\hline \hline
#書式 & 説明 \\ \hline
#\verb@%f@ & 固定小数点表記 \\
#\verb@%e@, \verb@%E@ & 指数表記; 指数の前に "e", "E" をつける \\
#\verb@%g@, \verb@%G@ & \verb@%e@ (または \verb@%E@) と \verb@%f@ の略記 \\
#\verb@%h@, \verb@%H@ & \verb@%g に "e%S" でなく "x10^{%S}" か "*10^{%S}" をつける@\\
#\verb@%x@, \verb@%X@ & 16 進表記 \\
#\verb@%o@, \verb@%O@ & 8 進表記 \\
#\verb@%t@ & 10 進の仮数部 \\
#\verb@%l@ & 現在の対数尺の底を基数とする仮数部 \\
#\verb@%s@ & 現在の対数尺の底を基数とする仮数部; 補助単位 (scientific power) \\
#\verb@%T@ & 10 進の指数部 \\
#\verb@%L@ & 現在の対数尺の底を基数とする指数部 \\
#\verb@%S@ & 補助単位の指数部 (scientific power) \\
#\verb@%c@ & 補助単位文字 \\
#\verb@%b@ & ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の仮数部\\
#\verb@%B@ & ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の接頭辞\\
#\verb@%P@ & πの倍数 \\
%c l .
%書式@説明
%_
%%f@固定小数点表記
%%e, %E@指数表記; 指数の前に "e", "E" をつける
%%g, %G@%e (または %E) と %f の略記
%%h, %H@%g に "e%S" でなく "x10^{%S}" か "*10^{%S}" をつける
%%x, %X@16 進表記
%%o, %O@8 進表記
%%t@10 進の仮数部
%%l@現在の対数尺の底を基数とする仮数部
%%s@現在の対数尺の底を基数とする仮数部; 補助単位 (scientific power)
%%T@10 進の指数部
%%L@現在の対数尺の底を基数とする指数部
%%S@補助単位の指数部 (scientific power)
%%c@補助単位文字
%%b@ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の仮数部
%%B@ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の接頭辞
%%P@πの倍数
%_
@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>書式</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>%f</tt></td>    <td>固定小数点表記</td></tr>
^<tr>    <td><tt>%e</tt>, <tt>%E</tt></td>    <td>指数表記; 指数の前に "e", "E" をつける</td></tr>
^<tr>    <td><tt>%g</tt>, <tt>%G</tt></td>    <td><tt>%e</tt> (または <tt>%E</tt>) と <tt>%f</tt>の略記</td></tr>
^<tr>    <td><tt>%h</tt>, <tt>%H</tt></td>    <td><tt>%g</tt> に "e%S" の代わりに "x10^{%S}" か "*10^{%S}" をつける</td></tr>
^<tr>    <td><tt>%x</tt>, <tt>%X</tt></td>    <td>16 進表記</td></tr>
^<tr>    <td><tt>%o</tt>, <tt>%O</tt></td>    <td>8 進表記</td></tr>
^<tr>    <td><tt>%t</tt></td>    <td>10 進の仮数部</td></tr>
^<tr>    <td><tt>%l</tt></td>    <td>現在の対数尺の底を基数とする仮数部</td></tr>
^<tr>    <td><tt>%s</tt></td>    <td>現在の対数尺の底を基数とする仮数部; 補助単位 (scientific power)</td></tr>
^<tr>    <td><tt>%T</tt></td>    <td>10 進の指数部</td></tr>
^<tr>    <td><tt>%L</tt></td>    <td>現在の対数尺の底を基数とする指数部</td></tr>
^<tr>    <td><tt>%S</tt></td>    <td>補助単位の指数部 (scientific power)</td></tr>
^<tr>    <td><tt>%c</tt></td>    <td>補助単位文字</td></tr>
^<tr>    <td><tt>%b</tt></td>    <td>ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の仮数部</td></tr>
^<tr>    <td><tt>%B</tt></td>    <td>ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の接頭辞</td></tr>
^<tr>    <td><tt>%P</tt></td>    <td>&pi; の倍数</td></tr>
^</tbody>
^</table>

 補助単位 ('scientific' power) は、指数が 3 の倍数であるようなものです。
 補助単位指数 (`"%c"`) の文字への変換は -18 から +18 までの指数に対して
 サポートされています。この範囲外の指数の場合、書式は通常の指数形式に
 戻ります。

 ほかに使うことのできる修飾詞 ("%" と書式指定子の間に書くもの) には、
 次のいくつかがあります: "-" は数字を左詰めにし、"+" は正の数にも符号を
 つけ、" " (空白一つ) は負の数に "-" をつけるべき場所に正の数の場合に空
 白を一つつけ、"#" は小数点以下の数字が 0 だけであっても小数点をつけ、
 正の整数は出力幅を定め、出力幅指定の直前の "0" (文字でなく数字) は先頭
 に空いた部分を空白で埋める代わりに 0 で埋め、小数点の後に非負の整数を
 書いたものは精度を意味します (整数の場合は最小桁、小数の場合は小数点以
 下の桁数)。

 これらの全ての修飾詞をサポートしていない OS もあるでしょうし、逆にこれ
 以外のものをもサポートする OS もあるでしょう。疑わしい場合は、適切な資
 料を調べ、そして実験してみてください。

 例:
       set format y "%t"; set ytics (5,10)          # "5.0" と "1.0"
       set format y "%s"; set ytics (500,1000)      # "500" と "1.0"
       set format y "%+-12.3f"; set ytics(12345)    # "+12345.000  "
       set format y "%.2t*10^%+03T"; set ytic(12345)# "1.23*10^+04"
       set format y "%s*10^{%S}"; set ytic(12345)   # "12.345*10^{3}"
       set format y "%s %cg"; set ytic(12345)       # "12.345 kg"
       set format y "%.0P pi"; set ytic(6.283185)   # "2 pi"
       set format y "%.0f%%"; set ytic(50)          # "50%"

       set log y 2; set format y '%l'; set ytics (1,2,3)
       #"1.0", "1.0", "1.5" と表示される (3 は 1.5 * 2^1 なので)

 丸めと指数が必要となるような書式で 9.999 の様な数字が書かれる場合は
 問題が起こることがあります。

 軸のデータ型が日時データ (time/date) の場合、書式文字列は 'strftime'
 関数 ('gnuplot' 外。"man strftime" としてみてください) に関する有効な
 指定を行う必要があります。使える入力書式指定の一覧に関しては、以下参照:
 `set timefmt`。
4 日時データ指定子 (time/date specifiers)
?commands set format date_specifiers
?commands set format time_specifiers
?set format date_specifiers
?set format time_specifiers
?set date_specifiers
?set time_specifiers
?date_specifiers
?time_specifiers
 日時データモード (time/date mode) では、次の書式が使用できます:

@start table - first is interactive cleartext form
       書式         説明
       %a           曜日名の省略形 (Sun,Mon,...)
       %A           曜日名 (Sunday,Monday,...)
       %b, %h       月名の省略形 (Jan,Feb,...)
       %B           月名 (January,February,...)
       %d           日 (01--31)
       %D           "%m/%d/%y" の簡略形 (出力のみ)
       %F           "%Y-%m-%d" の簡略形 (出力のみ)
       %k           時 (0--23; 1 桁または 2 桁)
       %H           時 (00--23; 常に 2 桁)
       %l           時 (1--12; 1 桁または 2 桁)
       %I           時 (01--12; 常に 2 桁)
       %j           その年の通算日 (001--366)
       %m           月 (01--12)
       %M           分 (00--60)
       %p           "am" または "pm"
       %r           "%I:%M:%S %p" の簡略形 (出力のみ)
       %R           "%H:%M" の簡略形 (出力のみ)
       %S           秒 (出力では 00--60 の整数、入力では実数)
       %s           1970 年最初からの秒数
       %T           "%H:%M:%S" の簡略形 (出力のみ)
       %U           その年の通算週 (週は日曜日からと数える)
       %w           曜日番号 (0--6, 日曜 = 0)
       %W           その年の通算週 (週は月曜日からと数える)
       %y           西暦 (2000-2068 年は 0-68、1969-1999 年は 69-99)
       %Y           西暦 (4 桁)
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{日付指定子}\\
#\hline \hline
#書式 & 説明 \\ \hline
#\verb@%a@ & 曜日名の省略形 (Sun,Mon,...) \\
#\verb@%A@ & 曜日名 (Sunday,Monday,...) \\
#\verb@%b@, \verb@%h@ & 月名の省略形 (Jan,Feb,...) \\
#\verb@%B@ & 月名 (January,February,...) \\
#\verb@%d@ & 日 (01--31) \\
#\verb@%D@ & \verb@"%m/%d/%y"@ の簡略形 (出力のみ)\\
#\verb@%F@ & \verb@"%Y-%m-%d"@ の簡略形 (出力のみ)\\
#\verb@%k@ & 時 (0--23; 1 桁または 2 桁) \\
#\verb@%H@ & 時 (00--23; 常に 2 桁) \\
#\verb@%l@ & 時 (1--12; 1 桁または 2 桁) \\
#\verb@%I@ & 時 (01--12; 常に 2 桁) \\
#\verb@%j@ & その年の通算日 (001--366) \\
#\verb@%m@ & 月 (01--12) \\
#\verb@%M@ & 分 (00--60) \\
#\verb@%p@ & "am" または "pm" \\
#\verb@%r@ & \verb@"%I:%M:%S %p"@ の簡略形 (出力のみ)\\
#\verb@%R@ & \verb@"%H:%M"@ の簡略形 (出力のみ)\\
#\verb@%S@ & 秒 (出力では 00--60 の整数、入力では実数)\\
#\verb@%s@ & 1970 年最初からの秒数 \\
#\verb@%T@ & \verb@"%H:%M:%S"@ の簡略形 (出力のみ)\\
#\verb@%U@ & その年の通算週 (週は日曜日からと数える) \\
#\verb@%w@ & 曜日番号 (0--6, 日曜 = 0) \\
#\verb@%W@ & その年の通算週 (週は月曜日からと数える) \\
#\verb@%y@ & 西暦 (0-99、1969-2068 年の下 2 桁) \\
#\verb@%Y@ & 西暦 (4 桁) \\
%c l .
%書式@説明
%_
%%a@曜日名の省略形 (Sun,Mon,...)
%%A@曜日名 (Sunday,Monday,...)
%%b, %h@月名の省略形 (Jan,Feb,...)
%%B@月名 (January,February,...)
%%d@日 (01--31)
%%D@"%m/%d/%y" の簡略形 (出力のみ)
%%F@"%Y-%m-%d" の簡略形 (出力のみ)
%%k@時 (0--23; 1 桁または 2 桁)
%%H@時 (00--23; 常に 2 桁)
%%l@時 (1--12; 1 桁または 2 桁)
%%I@時 (01--12; 常に 2 桁)
%%j@その年の通算日 (1--366)
%%m@月 (01--12)
%%M@分 (0--60)
%%p@"am" または "pm"
%%r@"%I:%M:%S %p" の簡略形 (出力のみ)
%%R@"%H:%M" の簡略形 (出力のみ)
%%S@秒 (出力では 0--60 の整数、入力では実数)
%%s@1970 年最初からの秒数
%%T@"%H:%M:%S" の簡略形 (出力のみ)
%%U@その年の通算週 (週は日曜日からと数える)
%%w@曜日番号 (0--6, 日曜 = 0)
%%W@その年の通算週 (週は月曜日からと数える)
%%y@西暦 (0-99、1969-2068 年の下 2 桁)
%%Y@西暦 (4 桁)
%_
@end table


^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>日付書式</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>%a</tt></td>    <td>曜日名の省略形 (Sun,Mon,...)</td></tr>
^<tr>    <td><tt>%A</tt></td>    <td>曜日名 (Sunday,Monday,...)</td></tr>
^<tr>    <td><tt>%b</tt>, <tt>%h</tt></td>    <td>月名の省略形 (Jan,Feb,...)</td></tr>
^<tr>    <td><tt>%B</tt></td>    <td>月名 (January,February,...)</td></tr>
^<tr>    <td><tt>%d</tt></td>    <td>日 (01&ndash;31)</td></tr>
^<tr>    <td><tt>%D</tt></td>    <td><tt>%m/%d/%y</tt> の簡略形 (出力のみ)</td></tr>
^<tr>    <td><tt>%F</tt></td>    <td><tt>%Y-%m-%d</tt> の簡略形 (出力のみ)</td></tr>
^<tr>    <td><tt>%k</tt></td>    <td>時 (0&ndash;23; 1 桁または 2 桁)</td></tr>
^<tr>    <td><tt>%H</tt></td>    <td>時 (00&ndash;23; 常に 2 桁)</td></tr>
^<tr>    <td><tt>%l</tt></td>    <td>時 (1&ndash;12; 1 桁または 2 桁)</td></tr>
^<tr>    <td><tt>%I</tt></td>    <td>時 (01&ndash;12; 常に 2 桁)</td></tr>
^<tr>    <td><tt>%j</tt></td>    <td>その年の通算日 (1&ndash;366)</td></tr>
^<tr>    <td><tt>%m</tt></td>    <td>月 (01&ndash;12)</td></tr>
^<tr>    <td><tt>%M</tt></td>    <td>分 (0&ndash;60)</td></tr>
^<tr>    <td><tt>%p</tt></td>    <td>"am" または "pm"</td></tr>
^<tr>    <td><tt>%r</tt></td>    <td><tt>%I:%M:%S %p</tt> の簡略形 (出力のみ)</td></tr>
^<tr>    <td><tt>%R</tt></td>    <td><tt>%H:%M</tt> の簡略形 (出力のみ)</td></tr>
^<tr>    <td><tt>%S</tt></td>    <td>秒 (出力では 0&ndash;60 の整数、入力では実数)</td></tr>
^<tr>    <td><tt>%s</tt></td>    <td>1970 年最初からの秒数</td></tr>
^<tr>    <td><tt>%T</tt></td>    <td><tt>%H:%M:%S</tt> の簡略形 (出力のみ)</td></tr>
^<tr>    <td><tt>%U</tt></td>    <td>その年の通算週 (週は日曜日からと数える)</td></tr>
^<tr>    <td><tt>%w</tt></td>    <td>曜日番号 (0&ndash;6, 日曜 = 0)</td></tr>
^<tr>    <td><tt>%W</tt></td>    <td>その年の通算週 (週は月曜日からと数える)</td></tr>
^<tr>    <td><tt>%y</tt></td>    <td>西暦 (0-99、1969-2068 年の下 2 桁)</td></tr>
^<tr>    <td><tt>%Y</tt></td>    <td>西暦 (4 桁)</td></tr>
^</tbody>
^</table>

 数字を表す書式には、先頭に 0 を埋めるために "0" (ゼロ) を前につけるこ
 とができ、また最小の出力幅を指定するために正の整数を前につけることもで
 きます。書式 %S と %t は精度指定も受けつけるので、小数の時/分/秒を書く
 こともできます。

@start table - first is interactive cleartext form
       書式         説明
       %tH          エポック時への相対的な正負の時 (24 での巻戻しなし)
       %tM          エポック時への相対的な正負の分
       %tS          直前の tH, tM 項目に対応する正負の秒数
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{時刻指定子}\\
#\hline \hline
#書式 & 説明 \\ \hline
#\verb@%tH@ & エポック時への相対的な正負の時 (24 での巻戻しなし) \\
#\verb@%tM@ & エポック時への相対的な正負の分 \\
#\verb@%tS@ & 直前の tH, tM 項目に対応する正負の秒数 \\
%c l .
%書式@説明
%_
%%tH@エポック時への相対的な正負の時 (24 での巻戻しなし)
%%tM@エポック時への相対的な正負の分
%%tS@直前の tH, tM 項目に対応する正負の秒数
%_
@end table


^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>時刻書式</th>        <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>%tH</tt></td>    <td>エポック時への相対的な正負の時 (24 での巻戻しなし)</td></tr>
^<tr>    <td><tt>%tM</tt></td>    <td>エポック時への相対的な正負の分</td></tr>
^<tr>    <td><tt>%tS</tt></td>    <td>直前の tH, tM 項目に対応する正負の秒数</td></tr>
^</tbody>
^</table>

5 例 (Examples)
?commands set format date_specifiers examples
?commands set format time_specifiers examples
?set format date_specifiers examples
?set format time_specifiers examples
?set date_specifiers examples
?set time_specifiers examples
?date_specifiers examples
?time_specifiers examples

 日付書式の例:

 x の値が、1976 年 12 月 25 日の深夜少し前の時刻に対応する秒数であると
 仮定します。この位置の軸の刻みラベル文字列は、以下のようになります:

       set format x                 # デフォルトでは "12/25/76 \n 23:11"
       set format x "%A, %d %b %Y"  # "Saturday, 25 Dec 1976"
       set format x "%r %D"         # "11:11:11 pm 12/25/76"

 時刻書式の例:

 日付書式指定は、秒数での時間の値を、ある特定の日の時計の時刻にエンコー
 ドします。よって、時は 0 から 23 まで、分は 0 から 59 までのみを動きま
 すが、それらの負の値は、エポック (1970 年 1 月 1 日) より前の日付に対
 応します。秒数での時間の値を、時間 0 に対する相対的な時/分/秒の数値と
 して出力させるには、時間書式 %tH %tM %tS を使用します。-3672.50 秒の値
 は以下のように出力されます。

       set format x                 # デフォルトでは "12/31/69 \n 22:58"
       set format x "%tH:%tM:%tS"   # "-01:01:12"
       set format x "%.2tH hours"   # "-1.02 hours"
       set format x "%tM:%.2tS"     # "-61:12.50"

3 function style
?set function style
 このコマンドの形式は現在は推奨されていません。以下参照:
 `set style function`。
3 functions
?commands show functions
?show functions
 `show functions` コマンドはユーザーが定義した関数とその定義内容を表示
 します。

 書式:
         show functions

 gnuplot における関数の定義とその使い方については、以下参照:
 `expressions`。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/spline.html">
 ユーザ定義関数でのスプライン (spline.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/airfoil.html">
 関数と複素変数を翼に使用 (airfoil.dem)。
^ </a>
3 格子線 (grid)
?commands set grid
?commands unset grid
?commands show grid
?set grid
?unset grid
?show grid
?grid
?nogrid
 コマンド `set grid` は格子線を描きます。

 書式:
       set grid {{no}{m}xtics} {{no}{m}ytics} {{no}{m}ztics}
                {{no}{m}x2tics} {{no}{m}y2tics}
                {{no}{m}cbtics}
                {polar {<angle>}}
                {layerdefault | front | back}
                { {linestyle <major_linestyle>}
                  | {linetype | lt <major_linetype>}
                    {linewidth | lw <major_linewidth>}
                  { , {linestyle | ls <minor_linestyle>}
                      | {linetype | lt <minor_linetype>}
                        {linewidth | lw <minor_linewidth>} } }
       unset grid
       show grid

 格子線は任意の軸の任意の大目盛り/小目盛りに対して有効/無効にでき、その
 大目盛りと小目盛りに対する線種、線幅も指定でき、現在の出力装置がサポー
 トする範囲で、あらかじめ定義したラインスタイルを使用することもできます。

 さらに、2 次元の描画では極座標格子も使うことができます。定義可能な区間
 に対して、選択された目盛りを通る同心円と中心からの放射状の線が描かれま
 す (その区間は `set angles` の設定にしたがって度、またはラジアンで指定
 します)。極座標格子は現在は極座標モードでは自動的には生成されないこと
 に注意してください。

 `set grid` が描く前に、必要な目盛りは有効になっていなければなりません。
 `gnuplot` は、存在しない目盛りに対する格子の描画の命令は単に無視します。
 しかし、後でその目盛りが有効になればそれに対する格子も描きます。

 小格子線に対する線種を何も指定しなければ、大格子線と同じ線種が使われま
 す。デフォルトの極座標の角度は 30 度です。

 `front` を指定すると、格子線はグラフのデータの上に描かれます。`back`
 が指定された場合は格子線はグラフのデータの下に描かれます。`front` を使
 えば、密集したデータで格子線が見えなくなることを防ぐことができます。デ
 フォルトでは `layerdefault` で、これは 2D 描画では `back` と同じです。
 3D 描画のデフォルトは、格子とグラフの枠を 2 つの描画単位に分離し、格子
 は後ろに、枠は描画データまたは関数の前に書きます。ただし、`hidden3d`
 モードでは、それがそれ自身の並び換えをしていますので、格子線の順番のオ
 プションは全て無視され、格子線も隠線処理にかけられます。これらのオプシ
 ョンは、実際には格子線だけでなく、`set border` による境界線とその目盛
 りの刻み (以下参照: `set xtics`) にも影響を及ぼします。

 z の格子線は描画の底面に描かれます。これは描画の周りに部分的な箱が描画
 されている場合にはいいでしょう。以下参照: `set border`。
3 隠線処理 (hidden3d)
?commands set hidden3d
?commands unset hidden3d
?commands show hidden3d
?set hidden3d
?unset hidden3d
?show hidden3d
?hidden3d
?nohidden3d
 `set hidden3d` コマンドは曲面描画 (以下参照: `splot`) で隠線処理を行な
 うように指示します。その処理の内部アルゴリズムに関する追加機能もこのコ
 マンドで制御できます。

 書式:
       set hidden3d {defaults} |
                    { {front|back}
                      {{offset <offset>} | {nooffset}}
                      {trianglepattern <bitpattern>}
                      {{undefined <level>} | {noundefined}}
                      {{no}altdiagonal}
                      {{no}bentover} }
       unset hidden3d
       show hidden3d

 gnuplot の通常の表示とは異なり、隠線処理では与えられた関数、またはデー
 タの格子線を、実際の曲面がその曲面の背後にあって隠されている描画要素は
 見せないのと同じように処理します。これが機能するためには、その曲面が
 '格子状' (以下参照: `splot datafile`) である必要があり、またそれらは
 `with lines` か `with linespoints` で描かれていなければいけません。

 `hidden3d` が有効なときは、格子線だけでなく、面部分や土台の上の等高線
 (以下参照: `set contour`) も隠されます。複数の面を描画している場合は、
 各曲面は自分自身と他の曲面で隠される部分も持ちます。曲面上への等高線の
 表示 (`set contour surface`) は機能しません。

 gnuplot バージョン 4.6 では、グラフ上に曲面が一つもない状態でも、
 hidden3d は `points`, `labels`, `vectors`, `impulses` の 3 次元の描画
 スタイルに影響を与えます。`vectors` は、隠されない部分は線分 (矢先なし)
 として表示されます。グラフ内の各々の描画をこの処理から明示的に除外した
 いときは、`with` 指定に特別のオプション `nohidden3d` を追加してくださ
 い。

 hidden3d は、pm3d モードで描画された、塗り潰された曲面には影響を与えま
 せん。pm3d の曲面に対して同様の効果を純粋に得たいならば、これの代わり
 に `set pm3d depthorder` を使ってください。複数の pm3d 曲面に通常の
 `hidden3d` 処理を組み合わせるには、オプション `set hidden3d front` を
 使用してください。これは、hidden3d 処理の全ての要素を、pm3d 曲面を含む
 残りの他の描画要素の後に強制的に描画するものです。

 関数値は格子孤立線の交点で評価されます。見ることの出来る線分を求めると
 きは個々の関数値、あるいはデータ点の間はそのアルゴリズムによって線形補
 間されます。これは、`hidden3d` で描画する場合と `nohidden3d` で描画す
 る場合で関数の見かけが異なることを意味します。なぜならば、後者の場合関
 数値は各標本点で評価されるからです。この違いに関する議論については、
 以下参照: `set samples`, `set isosamples`。

 曲面の隠される部分を消去するのに使われるアルゴリズムは、このコマンドで
 制御されるいくつかの追加オプションを持っています。`defaults` を指定す
 ればそれらはすべて、以下で述べるようなデフォルトの値に設定されます。
 `defaults` が指定されなかった場合には、明示的に指定されたオプションの
 みが影響を受け、それ以外のものは以前の値が引き継がれます。よって、それ
 らのオプションの値をいちいち修正することなく、単に `set {no}hidden3d`
 のみで隠線処理をオン/オフできることになります。

 最初のオプション `offset` は '裏側' の線を描画する線の線種に影響を与え
 ます。通常は曲面の表裏を区別するために、裏側の線種は、表側の線種より一
 つ大きい番号の線種が使われます。`offset <offset>` によって、その追加す
 る値を、デフォルトの 1 とは異なる増分値に変更できます。`nooffset` オプ
 ションは `offset 0` を意味し、これは表裏で同じ線種を使うことになります。

 次のオプションは `trianglepattern <bitpattern>` です。<bitpattern> は
 0 から 7 までの数字で、ビットパターンと解釈されます。各曲面は三角形に
 分割されますが、このビットパターンの各ビットはそれらの三角形の各辺の表
 示を決定します。ビット 0 は格子の水平辺、ビット 1 は格子の垂直辺、ビッ
 ト 2 は、元々の格子が 2 つの三角形に分割されるときの対角辺です。デフォ
 ルトのビットパターンは 3 で、これは全ての水平辺と垂直辺を表示し、対角
 辺は表示しないことを意味します。対角辺も表示する場合は 7 を指定します。

 オプション `undefined <level>` は、定義されていない (欠けているデータ
 または未定義の関数値) か、または与えられた x,y,z の範囲を超えているデ
 ータ点に適用させるアルゴリズムを指示します。そのような点は、それでも
 表示されてしまうか、または入力データから取り除かれます。取り除かれて
 しまう点に接する全ての曲面要素は同様に取り除かれ、よって曲面に穴が生
 じます。<level> = 3 の場合、これは `noundefined` と同じで、どんな点も
 捨てられません。これは他の場所であらゆる種類の問題を引き起こし得るので
 使わないべきです。<level> = 2 では未定義の点は捨てられますが、範囲を超
 えた点は捨てられません。<level> = 1 では、これがデフォルトですが、範囲
 を超えた点も捨てられます。

 `noaltdiagonal` を指定すると、`undefined` が有効のとき (すなわち <level>
 が 3 でない場合) に起こる以下の場合のデフォルトでの取扱いを変更できま
 す。入力曲面の各格子状の部分は一方の対角線によって 2 つの三角形に分割
 されます。通常はそれらの対角線の全てが格子に対して同じ方向を向いていま
 す。もし、ある格子の 4 つの角のうち一つが `undefined` 処理によりとり除
 かれていて、その角が通常の方向の対角線に乗っている場合は、その両方の三
 角形が取り除かれてしまいます。しかし、もしデフォルトの設定である
 `altdiagonal` が有効になっている場合、その格子については他方向の対角線
 が代わりに選択され、曲面の穴の大きさが最小になるようにします。

 `bentover` オプションは今度は `trianglepattern` とともに起こる別のこと
 を制御します。かなりしわくちゃの曲面では、下の ASCII 文字絵に書いたよ
 うに、曲面の 1 つの格子が 2 つに分けられた三角形の表と裏の反対側が見え
 てしまう場合 (すなわち、元の四角形が折り曲げられている ('bent over')
 場合) があります:

                                                               C----B
          元の 4 角形:     A--B      表示される 4 角形:        |\   |
       ("set view 0,0")    | /|    ("set view 75,75" perhaps)  | \  |
                           |/ |                                |  \ |
                           C--D                                |   \|
                                                               A    D

 曲面の格子の対角辺が <bitpattern> の 2 bit によって見えるようにはなっ
 てはいない場合、上の対角辺 CB はどこにも書かれないことになり、それが結
 果の表示を理解しにくいものにします。デフォルトで定義される `bentover`
 オプションは、このような場合それを表示するようにします。もしそうしたく
 ないなら、`nobentover` を選択してください。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/hidden.html">
 隠線処理のデモ (hidden.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/singulr.html">
 複雑な隠線のデモ (singulr.dem).
^ </a>
3 historysize
?commands set historysize
?set historysize
?unset historysize
?historysize
 (非推奨)
 `set historysize N` は、`set history size N` と同じです。
 `unset historysize` は、`set history size -1` と同じです。
3 コマンド履歴 (history)
?commands set history
?set history
 書式:
    set history {size <N>} {quiet|numbers} {full|trim} {default}

 gnuplot の終了時にヒストリファイルに保存する行数を、history size の値
 に制限します。`set history size -1` とすると、ヒストリファイルに書き出
 す行数の制限がなくなります。

 デフォルトでは、コマンド `history` は各コマンドの前に行番号を出力しま
 す。`history quiet` は、今回の実行に対してのみ番号を省略しますが、
 `set history quiet` は、今後のすべての `history` の番号を省略します。

 オプション `trim` は、現在のコマンドに対する前の同じものを削除すること
 で、コマンド履歴内の重複する行の数を減らします。gnuplot のバージョン 5
 以前では、これがデフォルトの挙動でした。

 デフォルトの設定: `set history size 500 numbers trim`
3 孤立線サンプル数 (isosamples)
?commands set isosamples
?commands show isosamples
?set isosamples
?show isosamples
?isosamples
 関数を面として描画する場合の孤立線 (格子) の密度はコマンド `set isosamples`
 で変更できます。

 書式:
       set isosamples <iso_1> {,<iso_2>}
       show isosamples

 各曲面グラフは <iso_1> 個の u-孤立線と <iso_2> 個の v-孤立線を持ちます。
 <iso_1> のみ指定すれば、<iso_2> は <iso_1> と同じ値に設定されます。
 デフォルトでは、u, v それぞれ 10 本の標本化が行われます。標本数をもっと
 多くすればより正確なグラフが作られますが、時間がかかります。これらの
 パラメータは、データファイルの描画には何も影響を与えません。

 孤立線とは、曲面の一つの媒介変数を固定して、もう一つの媒介変数によって
 描かれる曲線のことです。孤立線は、曲面を表示する単純な方法を与えます。
 曲面 s(u,v) の媒介変数 u を固定することで u-孤立線 c(v) = s(u0,v) が
 作られ、媒介変数 v を固定することで v-孤立線 c(u) = s(u,v0) ができます。

 関数の曲面グラフが隠線処理なしで描かれている場合、`set samples` は
 各孤立線上で標本化される点の数を制御します。以下参照: `set samples`,
 `set hidden3d`。等高線描画ルーチンは、関数の点の標本化は各孤立線の交点
 で行われると仮定しているので、関数の曲面と等高線の解像度を変更するとき
 は、`isosamples` と同じように `samples` を変更するのが望ましいでしょう。
3 凡例 (key)
?commands set key
?commands unset key
?commands show key
?set key
?unset key
?show key
?key
?nokey
?legend
 コマンド `set key` は、描画領域内の各グラフに対するタイトルとサンプル
 (線、点、箱) を持つ凡例 (または表題) を有効にします。凡例の機能は、
 `set key off` か `unset key` で無効にできます。凡例の個々の項目につい
 ては、対応する plot コマンドでキーワード `notitle` を使用することで無
 効にできます。凡例のタイトル文字列は、オプション `set key autotitle`
 や、個々の `plot` や `splot` コマンド上の `title` キーワードで制御でき
 ます。詳細は以下参照: `plot title`。

 書式:
       set key {on|off} {default}
             {{inside | outside} | {lmargin | rmargin | tmargin | bmargin}
               | {at <position>}}
             {left | right | center} {top | bottom | center}
             {vertical | horizontal} {Left | Right}
             {{no}opaque}
             {{no}reverse} {{no}invert}
             {samplen <sample_length>} {spacing <vertical_spacing>}
             {width <width_increment>} {height <height_increment>}
             {{no}autotitle {columnheader}}
             {title "<text>"} {{no}enhanced}
             {font "<face>,<size>"} {textcolor <colorspec>}
             {{no}box {linestyle <style> | linetype <type> | linewidth <width>}}
             {maxcols {<max no. of columns> | auto}}
             {maxrows {<max no. of rows> | auto}}
       unset key
       show key

 キー内の各要素は `vertical` (縦) または `horizontal` (横) に従って重ね
 られます。`vertical` の場合、凡例は可能ならば 2,3 個の縦の列を使います。
 すなわち、各要素は垂直スペースがなくなるまでは 1 つの列に整列されます
 が、そこから新しい列が開始されます。垂直スペースは、`maxrows` を使って
 制限できます。`horizontal` の場合は、凡例は横の行をできるだけ少なく使
 おうとします。水平方向のスペースは `maxcols` により制限できます。

 デフォルトでは、凡例はグラフ領域の内側の右上の角に置かれます。キーワー
 ド `left`, `right`, `top`, `bottom`, `center`, `inside`, `outside`,
 `lmargin`, `rmargin`, `tmargin`, `bmargin` (, `above`, `over`, `below`,
 `under`) は、グラフ領域の他の場所への自動的な配置のために使用します。
 凡例の描画をどこに置くかをより詳しく指示するための `at <position>` も
 あります。この場合、キーワード `left`, `right`, `top`, `bottom`,
 `center` が同様の基準点合わせの設定の目的で使われます。
 より詳しくは、以下参照: `key placement`。

 グラフのタイトルの行揃えは `Left`, `Right` (デフォルト) で指示し
 ます。ラベル文字列と曲線のサンプルは左右入れ替えることができます
 (`reverse`) し、 全体を枠で囲むこともできます (`box {...}`)。その枠の
 線は、線種 (`linetype`), 線幅 (`linewidth`)、あるいは定義済のラインス
 タイル (`linestyle`) を指定することもできます。

 デフォルトでは、凡例は一つのグラフと同時に作られます。すなわち、凡例の
 記号とタイトルは、それに対応するグラフと同時に描かれます。それは、新し
 いグラフが時には凡例の上に要素をかぶせて配置しうることを意味します。
 `set key opaque` は、凡例をすべてのグラフの描画が終った後に生成させま
 す。この場合、凡例の領域は背景色で塗りつぶされて凡例の記号とタイトルが
 描かれます。よって、凡例自身はいくつかの描画要素を覆い隠してしまい得る
 ことになります。`set key noopaque` でデフォルトに復帰できます。

 デフォルトでは、最初の描画のラベルが凡例の一番上に現われ、それに続くラ
 ベルがその下に並んで行きます。オプション `invert` は、最初のラベルを凡
 例の一番下に置き、それに続くラベルをその上に並べて行きます。このオプシ
 ョンは、凡例のラベルの縦の並びの順番を、積み上げ形式のヒストグラム
 (`histograms`) の箱の順番に合わせるときに便利でしょう。

 <height_increment> は、凡例の箱の高さに加えたり減らしたりする高さ (何
 文字分か) を表す数値です。これは主に、凡例の回りに箱を描く場合で、凡例
 の並びの回りの境界線をより大きくしたい場合のものです。

 `plot` や `splot` で描画される全ての曲線は、デフォルトのオプション
 `autotitles` に従ってタイトルがつけられます。タイトルの自動生成は、
 `noautotaitle` で抑制できますがその場合、`(s)plot ... title ...` で明
 示的に指定されたタイトルのみが描かれることになります。

=columnheader
 コマンド `set key autotitle columnheader` は、各入力データの先頭行の各
 列のエントリをテキスト文字列と解釈し、対応する描画グラフのタイトルとし
 て使用します。描画される量が、複数の列データの関数である場合は、
 gnuplot はどの列をタイトルの描画に使えばいいのかわかりませんので、その
 ような場合、plot コマンド上で、例えば以下のように明示的にタイトルの列
 を指定する必要があります。

       plot "datafile" using (($2+$3)/$4) title columnhead(3) with lines

 全体に渡るタイトルを凡例の上につけることもできます (`title "<text>"`)。
 単一引用符 (') と二重引用符 (") の違いについては、以下も参照: `syntax`。
 凡例のタイトルの行揃えは、グラフのタイトルの行揃えと同じものが使われま
 す。

 `set key` のデフォルトは、`on`,  `right`, `top`, `vertical`, `Right`,
 `noreverse`, `noinvert`, `samplen 4`, `spacing 1.25`, `title ""`,
 `nobox` です。凡例の枠の線種はデフォルトではグラフ描画の外枠と同じもの
 が使われます。`set key default` とするとデフォルトの設定に戻ります。

 凡例は、1 行に 1 曲線分ずつの数行のまとまりとして書かれます。各行の右
 側には (`reverse` を使っていれば左側には) その曲線と同じ種類の直線のサ
 ンプルが引かれ、他の側には `plot` コマンドから得られる文字列 (title)
 が置かれます。これらの行は、架空の直線が凡例の左側と右側を分けるかのよ
 うに垂直に整列されます。コマンド `set key` で指定する座標はこの架空の
 線分の上の端の座標です。`plot` では直線の位置を指定するために x と y
 だけが使われ、`splot` では、x, y, z の値全てを使い、グラフを 2 次元面
 へ投影するのと同じ方法を使って、架空の直線の 2 次元画面での位置を生成
 します。

 TeX や、整形情報が文字列に埋め込まれる出力を使う場合は、`gnuplot` は凡
 例の位置合わせのための文字列の幅を正しく評価することしかできません。よ
 って凡例を左に置く場合は `set key left Left reverse` という組合せを使
 うのがいいでしょう。

 `splot` で等高線を書く場合、デフォルトでは凡例に等高線のラベルも表示し
 ます。その表示は `set cntrlabel format` で調整できます。

 例:

 以下はデフォルトの位置に凡例を表示します:
       set key default

 以下は凡例を表示しなくします:
       unset key

 以下はデフォルトの (第一の) 座標系での (2,3.5,2) の位置に凡例を表示
 します:
       set key at 2,3.5,2

 以下は凡例をグラフの下に表示します:
       set key below

 以下は凡例を左下角に表示し、テキストは左に行揃えで、タイトルをつけ、
 線種 3 の外枠を書きます:
       set key left bottom Left title 'Legend' box 3
4 凡例の配置 (key placement)
?commands set key placement
?set key placement
?key placement
 配置の仕組みを理解ための最も重要な概念は、グラフ領域、すなわち内か外か
 ということと、グラフ領域の境界との間の余白 (margin) を考えることです。
 グラフ領域に沿って、キーワード `left/center/right` (l/c/r) と
 `top/center/bottom` (t/c/b) は、凡例 (key) をその領域の内側のどこに置
 くかを制御します。

 モード `inside` では、凡例はキーワード `left` (l), `right` (r), `top`
 (t), `bottom` (b), `center` (c) によって以下の図のように描画領域の境界
 に向かって出力されます:

      t/l   t/c   t/r

      c/l    c    c/r

      b/l   b/c   b/r


 モード `outside` でも上と同様に自動的に配置されますが、グラフ領域の境
 界に対して、というよりもむしろ見た目に対して、というべきでしょう。すな
 わち、グラフの境界は、グラフ領域の外の凡例の場所を作るために、内側に移
 動することになります。しかし、これは他のラベルの邪魔をしますし、もしか
 したら出力デバイスによってはエラーを引き起こすかもしれません。凡例の出
 力に合わせてどの描画境界が移動するかは、上に述べた凡例の位置、および重
 ね上げの方向に依存します。4 方向の中心揃えのオプション (`center`) に関
 しては、どの境界が動くのかに関するあいまいさはありませんが、角への出力
 のオプションについては、重ね上げ方向が `vertical` の場合は左または右の
 境界が、`horizontal` の場合は上または下の境界が、それぞれ内側に適切に
 移動します。

 余白 (margin) の書き方は、重ね上げの方向にかかわない自動的な配置を可能
 にしています。`lmargin` (lm), `rmargin` (rm), `tmargin` (tm),
 `bmargin` (bm) のうちの一つを、矛盾しない 1 方向のキーワードと組み合わ
 せて使用した場合、以下の図に示した場所に凡例が配置されます:

           l/tm  c/tm  r/tm

      t/lm                  t/rm

      c/lm                  c/rm

      b/lm                  b/rm

           l/bm  c/bm  r/bm


 キーワード `above` と `over` は `tmargin` と同じ意味です。以前のバージ
 ョンとの互換性のために、`above` と `over` は l/c/r や重ね上げ方向のキ
 ーワードなしで使用すると、`center` で `horizontal` を使います。キーワ
 ード `below` と `under` は `bmargin` と同じ意味です。互換性のために、
 `below` と `under` は l/c/r や重ね上げ方向のキーワードなしで使用すると
 `center` で `horizontal` を使います。さらに、`outside` も互換性のため
 に t/b/c や重ね上げ方向のキーワードがなければ、`top`, `right`,
 `vertical` (つまり上の t/rm と同じ) を使用します。

 凡例の位置 (<position>) は、以前のバージョンと同様単に x,y,z を指定し
 てもいいですが、その最初のサンプル行の座標の座表系を選択するための 5
 つのキーワード (`first`, `second`, `graph`, `screen`, `character`) を
 頭につけることもできます。詳細は、以下参照: `coordinates`。<position>
 が与えられた場合の `left`, `right`, `top`, `bottom`, `center` の効果は、
 label コマンドで配置される文字列の場合と同じように基準位置の位置合わせ
 に使用されます。すなわち、`left` は凡例が <position> の右に置かれて左
 合わせで出力されます。他の場合も同様です。
4 凡例のサンプル (key samples)
?commands set key samples
?set key samples
?key samples
 デフォルトでは、グラフ上の各描画は凡例 (key) 内にそれぞれに対応するエ
 ントリを生成します。このエントリには、描画タイトルと、その描画で使われ
 るのと同じ色、同じ塗りつぶし属性による線/点/箱 のサンプルが入ります。
 font と textcolor 属性は、凡例内に現われる個々の描画タイトルの見た目を
 制御します。textcolor を "variable" にセットすると、凡例の各エントリの
 文字列は、描画グラフの線や塗りつぶし色と同じ色になります。これは、以前
 のある時期の gnuplot のデフォルトの挙動でした。

 グラフ曲線のサンプルの線分の長さは `samplen` で指定できます。その長さ
 は目盛りの長さと、<sample_length>*(文字幅) の和として計算されます。
 `sapmlen` は、グラフ上の点のサンプルの位置にも (もしサンプル線分自身が
 書かれなくても) 影響を与えています。それは、点の記号はサンプル線分の中
 央に書かれるためです。

 行間の垂直スペースは、`spacing` で指定できます。その幅は、点のサイズ
 (pointsize) と垂直な目盛りのサイズと <vertical_spacing> の積になります。
 この垂直スペースは、文字の高さよりも小さくはならないことが保証されてい
 ます。

 <width_increment> は、文字列の長さに加えたり減らしたりする幅 (何文字分
 か) を表す数値です。これは、凡例に外枠を書き、文字列に制御文字を使う場
 合にだけ有用でしょう。`gnuplot` は外枠の幅を計算するときは、ラベル文字
 列の文字数を単純に数えるだけなので、それを修正するのに使えます。
3 ラベル (label)
?commands set label
?commands unset label
?commands show label
?set label
?unset label
?show label
?label
?nolabel
 `set label` コマンドを使うことによって任意の見出し (label) をグラフ中
 に表示することができます。

 書式:
       set label {<tag>} {"<label text>"} {at <position>}
                 {left | center | right}
                 {norotate | rotate {by <degrees>}}
                 {font "<name>{,<size>}"}
                 {noenhanced}
                 {front | back}
                 {textcolor <colorspec>}
                 {point <pointstyle> | nopoint}
                 {offset <offset>}
                 {boxed}
                 {hypertext}
       unset label {<tag>}
       show label

 位置 (<position>) は x,y か x,y,z のどちらかで指定し、座標系を選択する
 にはその座標の前に `first`, `second`, `graph`, `screen`, `character`
 をつけます。詳細は、以下参照: `coordinates`。

 タグ (<tag>) は見出しを識別するための整数値です。タグを指定しなかった
 場合未使用のもので最も小さい値が自動的に割り当てられます。現在の見出し
 を変更するときはそのタグと変更したい項目を指定して `set label` コマン
 ドを使います。

 <label text> は文字列定数でも構いませんし、文字列変数、または文字列の
 値を持つ式でも構いません。以下参照: `strings`, `sprintf`, `gprintf`。

 デフォルトでは、指定した点 x,y,z に見出しの文章の左端が来るように配置
 されます。x,y,z を見出しのどこに揃えるかを変更するには変数
 <justification> を指定します。これには、`left`, `right`, `center` の
 いずれかが指定でき、それぞれ文章の左、右、真中が指定した点に来るよう
 に配置さるようになります。描画範囲の外にはみ出るような指定も許されま
 すが、座標軸の見出しや他の文字列と重なる場合があります。

 箱内に入れるラベルをサポートする出力形式もあります。以下参照:
 `set style textbox`。注意: 今のところ、箱内のラベルは、回転しない文字
 列に制限されています。

 `rotate` を指定するとラベルは縦書きになります (もちろん出力ドライバが
 対応していれば、ですが)。`rotate by <degrees>` が与えられた場合は、そ
 れに適合している出力ドライバは指定された角度で文字列を書こうとしますが
 そうでない出力形式では、垂直な文字列として扱われます。

 フォントとそのサイズは、出力形式がフォントの設定をサポートしていれば
 `font "<name>{,<size>}"` で明示的に選択できます。そうでない出力形式で
 は、デフォルトのフォントが使われます。

 通常は、現在の出力形式がサポートしていれば、ラベル文字列の全ての文字列
 に拡張文字列処理モード (enhanced text mode) が使用されます。
 `noenhanced` を使用することで、特定のラベルを拡張文字列処理から外すこ
 とができます。これは、ラベルが例えばアンダースコア (_) を含んでいる場
 合などに有用です。以下参照: `enhanced text`。

 `front` が与えられると、見出しはデータのグラフの上に書かれます。`back`
 が与えられると (デフォルト)、見出しはグラフの下に書かれます。`front`
 を使うことで、密なデータによって見出しが隠されてしまうことを避けること
 が出来ます。

 `textcolor <colorspec>` は見出し文字列の色を変更します。<colorspec> は
 線種、rgb 色、またはパレットへの割当のいずれかが指定できます。
 以下参照: `colorspec`, `palette`。`textcolor` は、`tc` と省略可能です。
    `tc default` は、文字色をデフォルトにします。
    `tc lt <n>` は、文字色を線種 <n> (line type)と同じものにします。
    `tc ls <n>` は、文字色を line style <n> と同じものにします。
    `tc palette z` は、見出しの z の位置に対応したパレット色になります。
    `tc palette cb <val>` は、色見本 (colorbar) の <val> の色になります。
    `tc palette fraction <val>` (0<=val<=1) は、[0:1] から `palette` の
        灰色階調/カラーへの写像に対応した色になります。
    `tc rgb "#RRGGBB"`, `tc rgb "0xRRGGBB"` は、任意の 24-bit RGB 色を
        設定します。
    `tc rgb 0xRRGGBB` も同じです (16 進定数値には引用符は不要)。

 <pointstyle> がキーワード `lt`, `pt`, `ps` とともに与えられると (以下
 参照: `style`)、与えられたスタイルと、与えられた線種の色で見出し位置に
 点 (point) が描画され、見出し文字列は少し移動されます。このオプション
 は `mouse` 拡張された出力形式でのラベルの配置に、デフォルトで使用され
 ています。見出し文字列近くの点の描画機能を off (これがデフォルト) にす
 るには、`nopoint` を使用してください。

 その移動は、デフォルトでは、<pointstyle> が与えられれば `pointsize` の
 単位で 1,1 で、<pointstyle> が与えられていなければ 0,0 です。移動は、
 追加の `offset <offset>` でも制御できます。ここで、<offset> は x,y か
 または x,y,z の形式ですが、それに座標系を選択して、その前に `first`,
 `second`, `graph`, `screen`, `character` のいずれかをつけることもでき
 ます。詳細は、以下参照: `coordinates`。

 もし一つ (あるいはそれ以上の) 軸が時間軸である場合、座標は `timefmt`
 の書式にしたがって引用符で囲まれた文字列で与える必要があります。以下参
 照: `set xdata`, `set timefmt`。

 `set label` に関して有効なオプションは、描画スタイル `labels` でも有効
 です。以下参照: `labels`。

4 examples
?label examples
?set label examples
 例:

 (1,2) の位置に "y=x" と書く場合:
       set label "y=x" at 1,2

 Symbol フォントのサイズ 24 の "シグマ" (Σ) をグラフの真中に書く場合:
       set label "S" at graph 0.5,0.5 center font "Symbol,24"

 見出し "y=x^2" の右端が (2,3,4) に来るようにし、タグ番号として 3 を使う
 場合:
       set label 3 "y=x^2" at 2,3,4 right

 その見出しを中央揃えにする場合:
       set label 3 center

 タグ番号 2 の見出しを削除する場合:
       unset label 2

 全ての見出しを削除する場合:
       unset label

 全ての見出しをタグ番号順に表示する場合:
       show label

 x 軸が時間軸であるグラフに見出しを設定する例:
       set timefmt "%d/%m/%y,%H:%M"
       set label "Harvest" at "25/8/93",1

 データと、新たに当てはめられたパラメータによる当てはめ関数を描画したい
 場合、`fit` の後でかつ `plot` の前に以下を実行します:
       set label sprintf("a = %3.5g",par_a) at 30,15
       bfit = gprintf("b = %s*10^%S",par_b)
       set label bfit at 30,20

 当てはめられるパラメータのついた関数の定義式を表示したい場合:
       f(x)=a+b*x
       fit f(x) 'datafile' via a,b
       set label GPFUN_f at graph .05,.95
       set label sprintf("a = %g", a) at graph .05,.90
       set label sprintf("b = %g", b) at graph .05,.85

 見出し文字列を小さい点から少しだけ移動する場合:
       set label 'origin' at 0,0 point lt 1 pt 2 ps 3 offset 1,-1

 pm3d を使った 3 次元のカラー曲面上のある点の位置に、その z の値 (この
 場合 5.5) に対応した色を見出し文字列につける場合:
       set label 'text' at 0,0,5.5 tc palette z
4 ハイパーテキスト (hypertext)
?hypertext
?label hypertext
?set label hypertext
 出力形式の中には (wxt, qt, svg, canvas, win) グラフ上の特定の位置やキ
 ャンバス内のその他の部分にハイパーテキストを貼り付けることができるもの
 があります。マウスをその場所に持っていくと、文字列を含む箱がポップアッ
 プされますが、ハイパーテキストをサポートしない出力形式では、それは何も
 表示しません。ハイパーテキストを貼り付けるには、そのラベルの `point`
 属性を有効にする必要があります。
 例:
       set label at 0,0 "Plot origin" hypertext point pt 1
       plot 'data' using 1:2:0 with labels hypertext point pt 7 \
            title 'mouse over point to see its order in data set'

3 線種 (linetype)
?commands set linetype
?commands show linetype
?set linetype
?show linetype
?linetype
 コマンド `set linetype` は各種描画に使用される基本的な線種 (linetype)
 を再定義することを可能にします。このコマンドのオプションは、
 "set style line" のものと全く同じです。ラインスタイルと違うところは、
 `set linetype` による再定義は永続的なことで、これは `reset` の影響を受
 けません。

 例えば、線種の 1 と 2 はデフォルトでは赤と緑です。それを以下のように再
 定義します:

       set linetype 1 lw 2 lc rgb "blue" pointtype 6
       set linetype 2 lw 2 lc rgb "forest-green" pointtype 8

 すると lt 1 を使用しているすべてのものが、細い赤線 (lt 1 の以前のデフ
 ォルト) か太い青線になります。この性質は、lt 1 に基づいて作られた一時
 的なラインスタイルの定義のようなものも含んでいます。

 `注意`: このコマンドは gnuplot バージョン 4.6 で新たに導入されたもので、
 以前のあいまいなコマンド "set style increment user" に置き換わるもので
 す。古いコマンドは現在は非推奨です。

 この仕組みは、gnuplot で使用する線種列に対する個人的な好みを設定するの
 にも使えます。それを行うには、実行時初期化ファイル ~/.gnuplot に、例え
 ば以下のようなそれ用のコマンド列を追加することをお勧めします:

       if ((GPVAL_VERSION < 4.5) \
       ||  (!strstrt(GPVAL_COMPILE_OPTIONS,"+USER_LINETYPES"))) \
           exit
       set linetype 1 lc rgb "dark-violet" lw 2 pt 0
       set linetype 2 lc rgb "sea-green"   lw 2 pt 7
       set linetype 3 lc rgb "cyan"        lw 2 pt 6 pi -1
       set linetype 4 lc rgb "dark-red"    lw 2 pt 5 pi -1
       set linetype 5 lc rgb "blue"        lw 2 pt 8
       set linetype 6 lc rgb "dark-orange" lw 2 pt 3
       set linetype 7 lc rgb "black"       lw 2 pt 11
       set linetype 8 lc rgb "goldenrod"   lw 2
       set linetype cycle 8

 こうすると、あなたが gnuplot を実行する度に線種はこれらの値に初期化さ
 れます。線種はあなたが好む数だけ初期化できます。再定義しない場合は、そ
 れはデフォルトの属性を持ち続けます。例えば線種 3 を再定義から外せば、
 それは青で pt 3, lw 1 となります。なお、サンプルスクリプトの最初の 2,3
 の行は、古いバージョンの gnuplot ではスキップさせるための保険です。

 同様のスクリプトファイルで、テーマベースの色選択の定義を行ったり、特定
 の描画タイプ、あるいは特定の出力形式用に色をカスタマイズしたりすること
 も可能です。

=cycle
 コマンド `set linetype cycle 8` は、大きな番号の線種に対しては色や線幅
 に関するこれらの定義を再利用することを gnuplot に伝えます。すなわち、
 線種 (linetype) 9-16, 17-24 等に対しては、これと同じ色、幅の列を使用し
 ます。ただし、点の属性 (pointtype, pointsize, pointinterval) は、この
 コマンドの影響は受けません。`unset linetype cycle` はこの機能を無効に
 します。大きな線種番号の線の属性を明示的に定義した場合は、それは小さい
 番号の線種の属性の再利用よりも優先されます。
3 第 2 軸との対応 (link)
?commands set link
?set link
?link
 書式:
       set link {x2 | y2} {via <expression1> inverse <expression2>}
       unset link

 コマンド `set link` は、x 軸と x2 軸、または y 軸と y2 軸の間の対応を
 設定します。<expression1> は、第 1 軸の座標を第 2 軸に写像する数式です
 が、<expression2> は第 2 軸の座標を第 1 軸に写像する数式です。

 例:

       set link x

 これは、このコマンドの最も単純な形式で、x2 軸を範囲 (range) も伸縮
 (scale) も方向も x 軸と全く同じにします。`set xrange` や `set auto x`
 などのコマンドは、この場合 x 軸にも x2 軸にも作用します。`set x2range`
 などのコマンドは、このリンクが有効な間は無視されます。

       set link x2 via x**2 inverse sqrt(x)
       plot "sqrt_data" using 1:2 axes x2y1, "linear_data" using 1:2 axes x1y1

 このコマンドは、x 軸と x2 軸の、順方向と逆方向の対応を設定しています。
 順方向の対応は、x2 軸の刻みラベルと、マウスの x2 座標を生成するのに使
 い、逆方向の対応は、x2 軸系で指定された座標を描画するのに使います。こ
 の対応は、非負の x 座標にのみ有効であることに注意してください。y2 軸に
 対応させた場合、<expression1> と <expression2> には仮変数として y を使
 う必要があります。
3 lmargin
?commands set lmargin
?set lmargin
?lmargin
 コマンド `set lmargin` は左の余白のサイズをセットします。詳細は、以下
 参照: `set margin`。
3 読み込み検索パス (loadpath)
?commands set loadpath
?commands show loadpath
?set loadpath
?show loadpath
?loadpath
 `loadpath` の設定は、`call`, `load`, `plot`, `splot` コマンドのデータ
 ファイル、コマンドファイルの検索パスを追加定義します。ファイルが現在の
 ディレクトリに見つからなかった場合、`loadpath` のディレクトリが検索さ
 れます。

 書式:
       set loadpath {"pathlist1" {"pathlist2"...}}
       show loadpath

 パス名は単一のディレクトリ名、または複数のパス名のリストとして入力しま
 す。複数のパスからなるパスリストは OS 固有のパス区切り、例えば Unix で
 はコロン (':'), MS-DOS, Windows, OS/2 ではセミコロン (';') 等で区切り
 ます。`show loadpath`, `save`, `save set` コマンドは、OS 固有のパス区
 切りをスペース (' ') で置き換えます。

 環境変数 GNUPLOT_LIB が設定されている場合、その内容は `loadpath` に追
 加されますが、`show loadpath` は、`set loadpath` と GNUPLOT_LIB の値を
 別々に表示しますし、`save`, `save set` コマンドは、GNUPLOT_LIB の値の
 方は無視します。
3 ロケール (locale)
?commands set locale
?set locale
?locale
 `locale` の設定は `{x,y,z}{d,m}tics` が書く日付の言語を決定します。

 書式:
       set locale {"<locale>"}

 <locale> にはインストールされたシステムで使うことの出来る任意の言語を
 指定できます。可能なオプションについてはシステムのドキュメントを参照し
 てください。コマンド `set locale ""` は、環境変数 LC_TIME, LC_ALL, ま
 たは LANG からロカールの値を決定しようとします。

 小数点に関する locale を変更したい場合は、以下参照: `set decimalsign`。
 文字エンコードを現在のロカールのものに変更したい場合は、以下参照:
 `set encoding`。
3 対数軸 (logscale)
?commands set logscale
?commands unset logscale
?commands show logscale
?set logscale
?unset logscale
?show logscale
?set log
?logscale
?nologscale
 書式:
       set logscale <axes> {<base>}
       unset logscale <axes>
       show logscale

 ここで、<axes> (軸) は、`x`, `x2`, `y`, `y2`, `z`, `cb`, `r` の任意の
 順序の組み合せが可能です。<base> は、対数目盛りの底です (デフォルトの
 底は 10)。軸を指定しなかった場合は、`r` 以外のすべての軸が対象となりま
 す。コマンド `unset logscale` は、すべての軸の対数目盛りを解除します。
 対数軸に対してつけられる目盛りの刻みは、等間隔ではないことに注意してく
 ださい。以下参照: `set xtics`。

 例:

 x, z 両軸について対数目盛りを設定する:
        set logscale xz

 y 軸について底 2 とする対数目盛りを設定する:
        set logscale y 2

 pm3d plot 用に z と色の軸に対数目盛りを設定する:
        set logscale zcb

 z 軸の対数目盛りを解除する:
        unset logscale z
3 マクロ (macros)
?commands set macros
?commands show macros
?set macros
?show macros
 これによりコマンドラインのマクロ置換機能を有効にすると、コマンドライン
 内の @<stringvariablename> の形式の部分文字列は、文字列変数
 <stringvariablename> に含まれるテキスト文字列に置き換えられます。以下
 参照: `substitution`。

 書式:
      set macros

3 3 次元座標系 (mapping)
?commands set mapping
?commands show mapping
?set mapping
?show mapping
?mapping
 データが `splot` に球面座標や円柱座標で与えられた場合、`set mapping`
 コマンドは `gnuplot` にそれをどのように扱うかを指定するのに使われます。

 書式:
       set mapping {cartesian | spherical | cylindrical}

 デフォルトではカーテシアン座標 (通常の x,y,z 座標) が使われます。

 球面座標では、データは 2 つか 3 つの列 (またはその個数の `using` エン
 トリ) として与えられます。最初の 2 つは、`set angles` で設定された単位
 での方位角 (theta) と仰角 (phi) (すなわち "経度" と "緯度") とみなされ
 ます。半径 r は、もし 3 列目のデータがあればそれが使われ、もしなければ
 1 に設定されます。各変数の x,y,z との対応は以下の通りです:

       x = r * cos(theta) * cos(phi)
       y = r * sin(theta) * cos(phi)
       z = r * sin(phi)

 これは、"極座標系" というより、むしろ "地学上の座標系" (緯度、経度) に
 相当することに注意してください (すなわち、phi は z 軸となす角、という
 より赤道から計った仰角、になります)。

 円柱座標では、データはやはり 2 つか 3 つの列で与えられ、最初の 2 つは
 theta (`set angle` で指定された単位の) と z と見なされます。半径 r は
 球面座標の場合と同様、3 列目のデータがあればそれが、なければ 1 と設定
 されます。各変数の x,y,z との対応は以下の通りです:

       x = r * cos(theta)
       y = r * sin(theta)
       z = z

 `mapping` の効果は、`splot` コマンド上の `using` によるフィルタで実現
 することも可能ですが、多くのデータファイルが処理される場合は `mapping`
 の方が便利でしょう。しかし、`mapping` を使っていても、もしファイルのデ
 ータの順番が適切でなかったら結局 `using` が必要になってしまいます。

 `mapping` は `plot` では何もしません。
^ 以下も参照
^ <a href="http://www.gnuplot.info/demo/world.html">
 world.dem: mapping のデモ。
^ </a>
3 周囲の余白 (margin)
?commands set margins
?commands show margins
?set margin
?set margins
?show margins
?margins
 `margin` (周囲の余白) とは、描画領域の境界からキャンバスの一番外側まで
 の間隔のことです。この余白の大きさは自動的にとられますが、コマンド
 `set margin` で変更することもできます。`show margin` は現在の設定を表
 示します。描画領域の境界から内側の描画要素までの間隔を変更したい場合は
 以下参照: `set offsets`。

 書式:
       set lmargin {{at screen} <margin>}
       set rmargin {{at screen} <margin>}
       set tmargin {{at screen} <margin>}
       set bmargin {{at screen} <margin>}
       set margins <left>, <right>, <top>, <bottom>
       show margin

 <margin> のデフォルトの単位には、適切と思われる、文字の高さと幅が使わ
 れます。正の値は余白の絶対的な大きさを定義し、負の値 (または無指定) は
 `gnuplot` によって自動計算される値を使うことになります。3 次元描画では
 左の余白 (lmargin) のみが文字の大きさを単位として設定できます。

 キーワード `at screen` は、その余白の指定が全体の描画領域に対する割合
 であることを意味します。これは、多重描画 (multiplot) モードでの 2D, 3D
 グラフの角を正確に揃えるのに使えます。この配置は現在の `set origin` や
 や `set size` の値を無視するようになっていて、それは多重描画内のグラフ
 の配置の別の方法として使われることを意図しています。

 描画の余白は通常目盛り、目盛りの見出し、軸の見出し、描画のタイトル、
 日付、そして境界の外にある場合の凡例 (key) のサイズ等を元に計算されま
 す。しかし、目盛りの刻みが境界でなく軸の方についている場合 (例えば
 `set xtics axis` によって)、目盛りの刻み自身とその見出しは余白の計算に
 は含まれませんし、余白に書かれる他の文字列の位置の計算にも含まれません。
 これは、軸と境界が非常に近い場合、軸の見出しが他の文字列を上書きする可
 能性を示唆します。
3 マウス (mouse)
?commands set mouse
?commands unset mouse
?set mouse
?unset mouse
?mousing
?mouse
?nomouse
 コマンド `set mouse` は、現在の対話型出力形式に対してマウス機能を有効
 にします。対話型モードでは通常デフォルトでこれは有効になっていますが、
 コマンドがファイルから読み込まれる場合はデフォルトでは無効になっていま
 す。

 マウスモードは 2 種類用意されています。2 次元モードは、`plot` コマンド
 と `splot` の 2 次元射影 (すなわち、z の回転角が 0, 90, 180, 270, 360
 度の `set view`、および `set view map`) で動作します。このモードでは、
 マウス位置が追跡され、マウスボタンや矢印キーを使って拡大したり視点移動
 したりできます。グラフに対応する凡例のタイトルや別なウィジェットアイコ
 ンなどをクリックすることで、個々のグラフの描画をオン/オフに切り替える
 ことをサポートする出力形式もあります。

 `splot` による 3 次元グラフに対しては、グラフの視方向 (view) と縮尺の
 変更が、それぞれマウスボタン 1 と 2 (によるドラッグ) で行えます。ボタ
 ン 2 の垂直方向のドラッグを shift キーと同時に行うと、z 軸の一番下の位
 置 (`xyplane`) を上下します。これらのボタンにさらに <ctrl> キーを押す
 と、座標軸は表示されますが、データの表示は消えます。これは大きなデータ
 に対して有用でしょう。

 マウスは多重描画 (multiplot) モード内では無効ですが、`unset multiplot`
 で多重描画が完結すれば、マウス機能は ON になります。ただし、その作用は
 multiplot 内の最後の描画 (replot で描画されるようなもの) に対してのみ
 です。

 書式:
       set mouse {doubleclick <ms>} {nodoubleclick}
                 {{no}zoomcoordinates}
                 {zoomfactors <xmultiplier>, <ymultiplier>}
                 {noruler | ruler {at x,y}}
                 {polardistance{deg|tan} | nopolardistance}
                 {format <string>}
                 {mouseformat <int>/<string>}
                 {{no}labels {"labeloptions"}}
                 {{no}zoomjump} {{no}verbose}
       unset mouse

 オプション `noruler` と `ruler` は、定規 (ruler) 機能を off, on にしま
 す。`ruler` には座標を与えて原点を設定することもできます。`ruler` が
 on の間、ruler の原点からマウスまでのユーザ単位での距離が連続的に表示
 されます。デフォルトでは、ruler のトグルスイッチは 'r' にキー割り当て
 されています。

 オプション `polardistance` は、マウスカーソルから定規 (ruler) までの距
 離を極座標でも表示 (距離、および角度または傾き) するかどうかを決定しま
 す。これはデフォルトのキー割り当て '5' に対応します。

=labels
 ボタン 2 の gnuplot の永続的なラベルを定義するには、オプション
 `labels` を使用します。デフォルトは `nolabels` で、ボタン 2 は単に一時
 的なラベルをマウス位置に描画します。ラベルは現在の `mouseformat` の設
 定に従って書かれます。`labeloptions` 文字列は、コマンド `set label` コ
 マンドに渡されます。そのデフォルトは "point pointstyle 1" で、これはラ
 ベル位置に小さいプラス (`+`) を描画します。一時的なラベルは、その次の
 `replot`、またはマウスズーム操作では現れません。永続的なラベルは、ラベ
 ルの点の上で Ctrl キーを押してボタン 2 をクリックすることで消すことが
 できます。実際のラベルの位置にどれ位近くでクリックしなければいけないか
 の閾値も `pointsize` で決定されます。

 オプション `verbose` が ON の場合、実行時の報告コマンドが表示されます。
 このオプションはドライバウィンドウ上で `6` を打つことで ON/OFF がスイ
 ッチできます。デフォルトでは `verbose` は OFF になっています。

 ドライバウィンドウ上で 'h' を打つと、マウスとキー割当の短い説明が表示
 されます。これは、ユーザ定義のキー割当、すなわち `bind` コマンドによる
 `hotkeys` (以下参照: `bind`) も表示されます。ユーザ定義の `hotkeys` は
 デフォルトのキー割当を無効にします。
 以下も参照: `bind`, `label`。
4 doubleclick
?set mouse doubleclick
?mouse doubleclick
 ダブルクリックの解像度はミリ秒 (ms) 単位で与えます。これは、ボタン 1
 用のもので、現在のマウス位置をクリップボード (`clipboard`) にコピーす
 るのに使います。デフォルトの値は 300 ms です。これを 0 ms に設定すると
 シングルクリックでそのコピーを行うようになります。
4 mouseformat
?set mouse format
?set mouse mouseformat
?mouse format
?mouseformat
 コマンド `set mouse format` は、sprintf() に対する書式文字列の指定で、
 マウスカーソルの [x,y] 座標を描画ウィンドウとクリップボードにどのよう
 に表示するかを決定します。デフォルトは "% #g" です。

 `set mouse mouseformat` は、ボタン 1 とボタン 2 の作用時 (座標をクリッ
 プボードへコピーし、マウス位置に一時的に注釈をつける) の文字列の書式用
 に使われます。引数が整数の場合、以下の表にある書式オプションの一つを選
 択します。引数が文字列の場合は、書式オプション 6 の sprintf() の書式文
 字列として使われますので、2 つの実数の指定子を含む必要があります。例:
      `set mouse mouseformat "mouse x,y = %5.2g, %10.3f"`.
 この文字列をまたオフにするには、`set mouse mouseformat ""` とします。

 以下の書式が利用可能です:

  0   デフォルト (1 と同じ)
  1   軸の座標                            1.23, 2.45
  2   グラフ座標 (0 から 1 まで)         /0.00, 1.00/
  3   x = timefmt     y = 軸座標         [(`set timefmt` の設定), 2.45]
  4   x = 日付        y = 軸座標         [31. 12. 1999, 2.45]
  5   x = 時刻        y = 軸座標         [23:59, 2.45]
  6   x = 日付/時刻   y = 軸座標         [31. 12. 1999 23:59, 2.45]
  7   `set mouse mouseformat` による書式、例: "mouse x,y = 1.23,     2.450"
4 マウススクロール (scrolling)
?set mouse scrolling
?mouse scrolling
?mouse wheel
?scrolling
?mousewheel
 2 次元グラフと 3 次元グラフの両方で、X と Y 軸の伸縮はマウスホイールを
 使うことで調整できます。<wheel-up> はスクロールアップし (YMIN と YMAX
 の両方を Y の範囲の 10 パーセントずつ増加させ、Y2MIN と Y2MAX にも同様
 のことを行います)、<wheel-down> はスクロールダウンします。
 <shift-wheel-up> は左スクロールし (XMIN と XMAX の両方、そして X2MIN
 と X2MAX の両方を減少)、<shift-wheel-down> は右スクロールします。
 <control-wheel-up> はグラフの中心方向にズームインし、
 <control-wheel-down> はズームアウトします。<shift-control-wheel-up> は
 X と X2 軸のみに沿ってズームインし、<shift-control-wheel-down> は X と
 X2 軸に沿ってのみズームアウトします。
4 X11 でのマウス (X11 mouse)
?mouse x11_mouse
?x11_mouse
?x11 mouse
 x11 の出力形式のオプション `set term x11 <n>` を使って複数の X11 描画
 ウィンドウが開いている場合、マウスコマンドとホットキーの機能をちゃんと
 使えるのは現在の描画ウィンドウのみです。しかし、他のウィンドウも左下に
 マウスの座標を表示位はしてくれるでしょう。
4 zoom
?mouse zoom
?zoom
 拡大 (zoom) は、通常は左マウスボタンを押すことで行われ、拡大範囲の線引
 きはマウスのドラッグで行いますが、これとは異なるマウスボタンを要求する
 実行環境もあるかもしれません。元のグラフは、グラフウィンドウ上でホット
 キー 'u' をタイプすることで復元できます。ホットキー 'p' と 'n' は、拡
 大操作の履歴を後方と前方にたどります。

 オプション `zoomcoordinates` は、拡大の際に、拡大の枠の端にその座標を
 書くかどうかを決定し、デフォルトでは ON になっています。

 オプション `zoomjump` が ON の場合、ボタン 3 による拡大範囲の選択を開
 始すると、マウスポインタは自動的に少しだけずれた位置に移動します。これ
 は、ごく小さい (または空でさえある) 拡大範囲を選択してしまうことを避け
 るのに便利でしょう。デフォルトでは `zoomjump` は OFF です。

3 多重描画モード (multiplot)
?commands set multiplot
?commands unset multiplot
?set multiplot
?unset multiplot
?multiplot
?nomultiplot
 コマンド `set multiplot` は `gnuplot` を多重描画モードにします。これ
 は複数の描画を同じページ、ウィンドウ、スクリーンに表示するものです。

 書式:
       set multiplot
           { title <page title> {font <fontspec>} {enhanced|noenhanced} }
           { layout <rows>,<cols>
             {rowsfirst|columnsfirst} {downwards|upwards}
             {scale <xscale>{,<yscale>}} {offset <xoff>{,<yoff>}}
             {margins <left>,<right>,<bottom>,<top>}
             {spacing <xspacing>{,<yspacing>}}
           }
       set multiplot {next|previous}
       unset multiplot

 出力形式 (terminal) によっては、コマンド `unset multiplot` が与えられ
 るまで何の描画も表示されないことがあります。この場合このコマンドにより
 ページ全体の描画が行なわれ、gnuplot は標準の単一描画モードになります。
 それ以外の出力形式では、各 `plot` コマンドがそれぞれ表示を更新します。

 コマンド `clear` は、次の描画に使う長方形領域を消すのに使えます。典型
 的には、グラフを "挿入" するような場合に必要です。

 定義済の見出しやベクトルは、各描画において、毎回現在のサイズと原点に従
 って書かれます (それらが `screen` 座表系で定義されていない場合)。それ
 以外の全ての `set` で定義されるものも各描画すべてに適用されます。もし
 1 度の描画にだけ現われて欲しいものを作りたいなら、それが例えば日付
 (timestamp) だとしたら、`set multiplot` と `unset multiplot` で囲まれ
 たブロック内の `plot` (または `splot`, `replot`) 命令の一つを
 `set time` と `unset time` ではさんでください。

 multiplot のタイトルは、個々の描画タイトルがあったとしても、それとは別
 のもので、ページの上部にそのためのキャンバス全体の幅にわたるスペースが
 確保されます。

 layout が指定されていない場合、あるいはより良い位置合わせをしたい場合
 は、コマンド `set origin` と `set size` 各描画で正しい位置に設定する必
 要があります。詳細は、以下参照: `set origin`, `set size`。

 例:
       set multiplot
       set size 0.4,0.4
       set origin 0.1,0.1
       plot sin(x)
       set size 0.2,0.2
       set origin 0.5,0.5
       plot cos(x)
       unset multiplot

 これは、cos(x) のグラフを、sin(x) の上に積み重ねて表示します。

 `set size` と `set origin` は全体の描画領域を参照し、それは各描画で利
 用されます。以下も参照: `set term size`。描画境界を一列に揃えたいなら
 ば、`set margin` コマンドで、境界の外の余白サイズを同じサイズに揃える
 ことが出来ます。その使用に関しては、以下参照: `set margin`。余白サイズ
 は文字サイズ単位の絶対的な数値単位を使用することに注意してください。よ
 って残ったスペースに描かれるグラフは表示するデバイスの表示サイズに依存
 します。例えば、プリンタとディスプレイの表示は多分違ったものになるでし
 ょう。

 オプション `layout` により、各描画の前にそれぞれ与えていた `set size`
 や `set origin` コマンドなしに、単純な複数グラフの描画を作成できます。
 それらの設定は自動的に行なわれ、いつでもその設定を変更できます。
 `layout` では表示は <rows> 行と <cols> 列の格子に分割され、各格子は、
 その後に続く対応する名前のオプションによって行 (rowsfirst)、あるいは列
 (columnsfirst) が先に埋められて行きます。描画グラフの積み上げは下方向
 (`downwards`) に、または上方向 (`upwards`) に伸びるようにできます。デ
 フォルトは `rowsfirst` で `downwards` です。
 コマンド `set multiplot next` と `set multiplot previous` は、レイアウ
 トオプションを使用している場合のみに関係します。`next` は、格子内の次
 の位置をスキップし、空白を残します。`prev` は、直前に描画した位置の直
 前の格子位置に戻ります。

 各描画は `scale` で伸縮を、`offset` で位置の平行移動を行なうことができ
 ます。scale や offset の y の値が省略された場合は、x の値がそれに使用
 されます。`unset multiplot` により自動配置機能はオフになり、そして
 `set size` と `set origin` の値は `set multiplot layout` の前の状態に
 復帰されます。

 例:
       set size 1,1
       set origin 0,0
       set multiplot layout 3,2 columnsfirst scale 1.1,0.9
       [ ここには 6 つまでの描画コマンド ]
       unset multiplot

 上の例では 6 つの描画が 2 列の中に上から下へ、左から右へと埋められて行
 きます。各描画は水平サイズが 1.1/2、垂直サイズが 0.9/3 となります。

 他にも、個々のグラフに対する明示的なマージンを、オプション `margins`,
 `spacing` で設定できます。`margins` は、格子配置の複数グラフ全体の外側
 に対するマージンを、全体の描画領域に対する割合で設定します。これは、グ
 ラフのうちいくつかのものだけにラベルがあるけれど、すべてのグラフのサイ
 ズを等しいものにしたい場合にとても役に立ちます。

 例:
       set multiplot layout 2,2 columnsfirst margins 0.1,0.9,0.1,0.9 spacing 0.1
       set ylabel 'ylabel'
       plot sin(x)
       set xlabel 'xlabel'
       plot cos(x)
       unset ylabel
       unset xlabel
       plot sin(2*x)
       set xlabel 'xlabel'
       plot cos(2*x)
       unset multiplot

 以下も参照
^ <a href="http://www.gnuplot.info/demo/multiplt.html">
 multiplot のデモ (multiplt.dem)
^ </a>
3 mx2tics
?commands set mx2tics
?commands unset mx2tics
?commands show mx2tics
?set mx2tics
?unset mx2tics
?show mx2tics
?mx2tics
?nomx2tics
 x2 (上) 軸の小目盛り刻みの印は `set mx2tics` で制御されます。以下参照:
 `set mxtics`。
3 小目盛り刻み (mxtics)
?commands set mxtics
?commands unset mxtics
?commands show mxtics
?set mxtics
?unset mxtics
?show mxtics
?mxtics
?nomxtics
 x 軸の小目盛り刻みの印は `set mxtics` で制御されます。`unset mxtics`
 によってそれを表示させなくすることが出来ます。同様の制御コマンドが各軸
 毎に用意されています。

 書式:
       set mxtics {<freq> | default}
       unset mxtics
       show mxtics

 これらの書式は `mytics`, `mztics`, `mx2tics`, `my2tics`, `mrtics`,
 `mcbtics` に対しても同じです。

 <freq> は大目盛り間の、小目盛りによって分割される区間の数 (小目盛りの
 数ではありません) です。通常の線形軸に対してはデフォルトの値は 2 か 5
 で、これは大目盛りによって変化します。よって大目盛り間に 1 つ、または
 4 つの小目盛りが入ることになります。`default` を指定することによって小
 目盛りの数はデフォルトの値に戻ります。

 軸が対数軸である場合、分割区間の数はデフォルトでは有意な数にセットされ
 ます (10 個の長さを元にして)。<freq> が与えられていればそちらが優先さ
 れます。しかし、対数軸では通常の小目盛り (例えば 1 から 10 までの 2, 3,
 ..., 8, 9 の刻み) は、9 つの部分区間しかありませんが、<freq> の設定は
 10 とすることでそうなります。

 小目盛りを任意の位置に設定するには、("<label>" <pos> <level>, ...) の
 形式を `set {x|x2|y|y2|z}tics` で使用してください。ただし、<label> は
 空 ("") で、<level> を 1 にします。

 コマンド `set m{x|x2|y|y2|z}tics` は、大目盛りが一様の間隔の場合にのみ
 働きます。もし全ての大目盛りが `set {x|x2|y|y2|z}tics` によって手動で
 配置された場合は、この小目盛りのコマンドは無視されます。自動的な大目盛
 りの配置と手動の小目盛りの配置は、`set {x|x2|y|y2|z}tics` と
 `set {x|x2|y|y2|z}tics add` とを使うことで共存できます。

 例:
       set xtics 0, 5, 10
       set xtics add (7.5)
       set mxtics 5
 この場合、大目盛りは 0,5,7.5,10、小目盛りは 1,2,3,4,6,7,8,9 の場所
       set logscale y
       set ytics format ""
       set ytics 1e-6, 10, 1
       set ytics add ("1" 1, ".1" 0.1, ".01" 0.01, "10^-3" 0.001, \
                      "10^-4" 0.0001)
       set mytics 10
 この場合、大目盛りは指定された書式で、小目盛りは対数的に配置

 デフォルトでは小目盛りの表示は、線形軸ではオフで、対数軸ではオンになっ
 ています。その設定は、大目盛りに対する `axis|border` と `{no}mirror`
 の指定を継承します。これらに関する情報については、以下参照:
 `set xtics`。
3 my2tics
?commands set my2tics
?commands unset my2tics
?commands show my2tics
?set my2tics
?unset my2tics
?show my2tics
?my2tics
?nomy2tics
 y2 (右) 軸の小目盛り刻みの印は `set my2tics` で制御されます。以下参照:
 `set mxtics`。
3 mytics
?commands set mytics
?commands unset mytics
?commands show mytics
?set mytics
?unset mytics
?show mytics
?mytics
?nomytics
 y 軸の小目盛り刻みの印は `set mytics` で制御されます。以下参照:
 `set mxtics`。
3 mztics
?commands set mztics
?commands unset mztics
?commands show mztics
?set mztics
?unset mztics
?show mztics
?mztics
?nomztics
 z 軸の小目盛り刻みの印は `set mztics` で制御されます。以下参照:
 `set mxtics`。
3 図形オブジェクト (object)
?object
?commands set object
?commands show object
?set object
?show object
 コマンド `set object` は、その後の 2 次元描画すべてに表われる単一のオ
 ブジェクトを定義します。オブジェクトはいくつでも定義できます。オブジェ
 クトの型は、現在は `rectangle` (長方形)、`circle` (円)、`ellipse`
 (楕円) をサポートしています。長方形は、コマンド `set style rectangle`
 によって設定されたスタイルの属性の組 (塗り潰し、色、境界) をデフォルト
 として受け継ぎますが、個々のオジェクトを別々のスタイル属性で描画するこ
 とももちろん可能です。円と楕円は、`set style fill` による塗り潰しスタ
 イルを受け継ぎます。

 書式:
     set object <index>
         <object-type> <object-properties>
         {front|back|behind} {clip|noclip}
         {fc|fillcolor <colorspec>} {fs <fillstyle>}
         {default} {lw|linewidth <width>} {dt|dashtype <dashtype>}
     unset object <index>

 <object-type> は、`rectangle`, `ellipse`, `circle`, `polygon` のいずれ
 かです。個々のオブジェクトの型は、その型に特有の性質もいくつか持ってい
 ます。

 `front` を指定すると、オブジェクトはすべての描画要素の前 (上) に描画さ
 れますが、`front` と指定されたラベルよりは後ろ (下) になります。`back`
 を指定すると、すべての描画要素、すべてのラベルの後ろに配置されます。
 `behind` は、軸や `back` の長方形を含むすべてのものの後ろに配置されま
 す。よって、
     set object rectangle from screen 0,0 to screen 1,1 behind
 は、グラフやページ全体の背景に色をつけるのに利用できます。

 デフォルトでは、オブジェクトは、少なくとも 1 つの頂点がスクリーン座標
 で与えられていない限り、グラフ境界でクリッピングされます。`noclip` と
 設定すると、グラフ境界でのクリッピングは無効になりますが、スクリーンサ
 イズに対するクリッピングは行われます。

 オブジェクトの塗り潰しの色は <colorspec> で指定します。`fillcolor` は
 `fc` と省略できます。塗り潰しスタイルは <fillstyle> で指定します。詳細
 は、以下参照: `colorspec`, `fillstyle`。キーワード `default` を指定す
 ると、これらの属性は描画が実際に行われるときのデフォルトの設定を受け継
 ぎます。以下参照: `set style rectangle`。
4 長方形 (rectangle)
?rectangle
?commands set object rectangle
?commands show object rectangle
?set object rectangle
?show object rectangle
 書式:
     set object <index> rectangle
         {from <position> {to|rto} <position> |
          center <position> size <w>,<h> |
          at <position> size <w>,<h>}

 長方形の位置は、対角に向かい合う 2 つの頂点 (左下と右上) の位置、ある
 いは中心点の位置と横幅 (<w>) と縦幅 (<h>) で指定できます。いずれの場合
 も点の位置は、軸の座標 (`first`, `second`)、グラフ領域内の相対座標
 (`graph`)、スクリーン座標 (`screen`) のいずれかを使用できます
 (以下参照: `coordinates`)。オプション `at` と `center` は同じ意味です。

 例:
     # 座標軸で囲まれた領域全体の背景を水色に
     set object 1 rect from graph 0, graph 0 to graph 1, graph 1 back
     set object 1 rect fc rgb "cyan" fillstyle solid 1.0

     # 左下角が 0,0, 右上角が 2,3 の赤い四角を一つ置く
     set object 2 rect from 0,0 to 2,3 fc lt 1

     # 青い境界の空 (塗り潰さない) 長方形を置く
     set object 3 rect from 0,0 to 2,3 fs empty border rgb "blue"

     # 頂点は移動しないまま、塗り潰しと色をデフォルトに変更
     set object 2 rect default

 スクリーン座標で長方形の角を指定すると、それは現在のグラフ領域の端を越
 えることも可能ですが、その他の場合は長方形はグラフ内に収まるようにクリ
 ッピングされます。

4 楕円 (ellipse)
?ellipse
?commands set object ellipse
?commands show object ellipse
?set object ellipse
?show object ellipse
 書式:
     set object <index> ellipse {at|center} <position> size <w>,<h>
         {angle <orientation>} {units xy|xx|yy}
         {<other-object-properties>}

 楕円の位置は、中心を指定し、その後ろに幅と高さ (主軸と副軸) を指定しま
 す。キーワード `at` と `center` は同じ意味です。中心の位置の指定には、
 軸の座標 (`first`, `second`)、グラフ領域内の相対座標 (`graph`)、スクリ
 ーン座標 (`screen`) のいずれかを使用できます (以下参照: `coordinates`)。
 主軸と副軸の長さは、軸の座標で与えなければいけません。楕円の向き
 (orientation) は、水平軸と楕円の主軸との間の角度で指定します。角度を与
 えなければ、デフォルトの楕円の向きが代わりに使われます (以下参照:
 `set style ellipse`)。キーワード `units` は、楕円の軸の縮尺の制御に使
 用します。`units xy` は、主軸は x 軸の単位で、副軸は y 軸の単位で計算
 しますが、`units xx` は両軸とも x 軸の単位で縮尺し、`units yy` は両軸
 とも y 軸の単位になります。
 デフォルトは `xy` ですが、`set style ellipse units` の設定でいつでも変
 更できます。

 注意: x 軸と y 軸の縮尺が等しくない場合 (そして `units xy` の場合)、回
 転後の主軸と副軸の比は正しくはなりません。

 `set object ellipse size <2r>,<2r>` と `set object circle <r>` とは、
 一般には同じことにはならないことに注意してください。circle の半径は常
 に x 軸の単位で計られ、よって x 軸と y 軸の縮尺が違ったり、描画のアス
 ペクト比が 1 でなくても、常に円が生成されます。`units` が `xy` に設定
 されていれば、'set object ellipse' では、最初の <2r> は x 軸の単位で、
 後ろの <2r> は y 軸の単位で計られますが、これは x 軸と y 軸の縮尺が同
 じで、かつ描画のアスペクト比が 1 である場合のみ円を生成することを意味
 します。しかし、`units` を `xx` や `yy` にセットすれば、コマンド
 `set object` で指定した直径は同じ単位で計算されるので、楕円は正しいア
 スペクト比を持ち、描画をリサイズしてもそのアスペクト比は保持されます。

4 円 (circle)
?circle
?commands set object circle
?commands show object circle
?set object circle
?show object circle
 書式:
     set object <index> circle {at|center} <position> size <radius>
         {arc [<begin>:<end>]}
         {<other-object-properties>}

 円の位置は、中心を指定し、その後ろに半径を指定します。キーワード `at`
 と `center` は同じ意味です。その位置と半径には、x 軸の座標、グラフ領域
 内の相対座標 (`graph`)、スクリーン座標 (`screen`) のいずれかを使用でき
 ます (以下参照: `coordinates`)。そのいずれの場合でも、半径は軸、グラフ、
 スクリーンの水平方向の縮尺に対して計られ、水平方向と垂直方向の縮尺にず
 れがあっても、結果が常に正しく円になるように直されます。円をグラフの座
 標で描きたい (つまり水平軸と垂直軸のスケールが違う場合にはそれが楕円と
 して表示されるようにしたい) 場合は、代わりに `set object ellipse` を使
 ってください。

 デフォルトでは、完全な円が描画されます。オプションの `arc` に開始角と
 終了角を度を単位として指定すると円弧を描画します。円弧は、常に反時計回
 りに描かれます。

 以下も参照: `set object ellipse`。

4 多角形 (polygon)
?polygon
?commands set object polygon
?commands show object polygon
?set object polygon
?show object polygon
 書式:
     set object <index> polygon
         from <position> to <position> ... {to <position>}
 または
         from <position> rto <position> ... {rto <position>}

 多角形の位置は、頂点の位置の列を与えることで指定できます。それらは、軸
 の座標 (`first`, `second`)、グラフ領域内の相対座標 (`graph`)、スクリー
 ン座標 (`screen`) のいずれかを使用できます。相対的な座標 (rto) を指定
 する場合は、その座標系は前の頂点と同じ座標系でなければいけません。以下
 参照: `coordinates`。

 例:
     set object 1 polygon from 0,0 to 1,1 to 2,0
     set object 1 fc rgb "cyan" fillstyle solid 1.0 border lt -1

3 グラフ位置の調整 (offsets)
?commands set offsets
?commands unset offsets
?commands show offsets
?set offsets
?unset offsets
?show offsets
?offsets
?nooffsets
 オフセットは、自動縮尺されたグラフの中のデータの周りに空の境界を置く仕
 組みを提供します。オフセットは、x1,y1 軸と 2 次元の `plot` コマンドの
 みで意味を持ちます。

 書式:
       set offsets <left>, <right>, <top>, <bottom>
       unset offsets
       show offsets

 各オフセットは定数、または数式が使え、それらのデフォルトの値は 0 です。
 デフォルトでは、左右のオフセットは x1 軸と同じ単位で指定し、上下のオフ
 セットは y1 軸と同じ単位で指定しますが、キーワード "graph" を用いるこ
 とで軸の全範囲に対する割合としてオフセットを指定することもできます。正
 のオフセットの値は、軸の範囲を指定された方向へ伸ばします。例えば正の下
 方向のオフセットは y の最小値をより小さな値にします。許されている範囲
 での負のオフセットは、自動縮尺、あるいはクリッピングとの思いもよらぬ結
 果を生む可能性があります。自動縮尺機能から軸の範囲の調節を守りたい場合
 は、"set auto fix" も指定するといいでしょう。

 例:
       set auto fix
       set offsets graph 0.05, 0, 2, 2
       plot sin(x)

 この sin(x) のグラフの y の範囲は [-3:3] になります。それは、関数の
 y の範囲は [-1:1] に自動縮尺されますが、垂直方向のオフセットがそれぞ
 れ 2 であるためです。x の範囲は [-11:10] になりますが、これはデフォ
 ルトが [-10:10] でその全範囲が左に 0.05 の割合だけ伸ばされるためです。
3 グラフ位置の指定 (origin)
?commands set origin
?commands show origin
?set origin
?show origin
?origin
 コマンド `set origin` はスクリーン上で曲面描画の原点を指定 (すなわち、
 グラフとその余白) するのに使用します。その座標系はスクリーン座標系
 (`screen`) で与えます。この座標系に関する情報については、以下参照:
 `coordinates`。

 書式:
       set origin <x-origin>,<y-origin>
3 出力先指定 (output)
?commands set output
?commands show output
?set output
?show output
?output
?output file
 デフォルトでは、グラフは標準出力に表示されます。コマンド `set output` は
 その出力を指定されたファイルやデバイスにリダイレクトします。

 書式:
       set output {"<filename>"}
       show output

 ファイル名は引用符で囲まなければなりません。ファイル名が省略された場合
 は、直前の `set output` で開かれたファイルがクローズされ、新たな出力が
 標準出力 (STDOUT) に送られます。(もし、`set output "STDOUT"` とすると
 出力は "STDOUT" という名前のファイルに送られるかもしれません ! ["かも
 しれない" というのは、例えば `x11` や `wxt` などの terminal (出力形式)
 では `set output` が無視されるからです。])

 `set terminal` と `set output` の両方を指定する場合、`set terminal` を
 先に指定する方が安全です。それは、ある種の terminal では、OS が必要と
 するフラグをセットすることがあるからです。例えば、バイナリファイルに対
 して別々の open コマンドを必要とするような OS などがそれに該当します。

 パイプをサポートする環境では、パイプ出力も有用です。例えば以下の通りで
 す:

       set output "|lpr -Plaser filename"
       set term png; set output "|display png:-"

 MS-DOS では、`set output "PRN"` とすると標準のプリンタに出力されます。
 VMS では出力は任意のスプール可能なデバイスに送ることが出来ます。
3 媒介変数モード (parametric)
?commands set parametric
?commands unset parametric
?commands show parametric
?set parametric
?unset parametric
?show parametric
?parametric
?noparametric
 `set parametric` コマンドは `plot` および `splot` の意味を通常の関数描
 画から媒介変数表示 (parametric) 関数描画に変更します。`unset parametric`
 を使えば元の描画モードに戻ります。

 書式:
       set parametric
       unset parametric
       show parametric

 2 次元グラフにおいては、媒介変数表示関数はひとつの媒介変数に対する 2
 つの関数で定められます。例としては plot sin(t),cos(t) とすることによっ
 て円が描けます (アスペクト比が正しく設定されていれば。以下参照:
 `set size`)。`gnuplot` は、両方の関数が媒介変数による `plot` のために
 与えられていなければエラーメッセージを出します。

 3 次元グラフにおいては面は x = f(u,v), y = g(u,v), z = h(u,v) で定め
 られます。よって 3 つの関数を組で指定する必要があります。例としては、
 `cos(u)*cos(v),cos(u)*sin(v),sin(u)` とすることによって球面が描けます。
 `gnuplot` は、3 つ全部の関数が媒介変数による `splot` のために与えられ
 ていなければエラーメッセージを出します。

 これによって表現できる関数群は、単純な f(x) 型の関数群の内包することに
 なります。なぜならば、2 つ (3 つ) の関数は x, y (, z) の値を独立に計算
 する記述ができるからです。実際、t,f(t) のグラフは、一番目の関数のよう
 な恒等関数を用いて x の値が計算される場合に f(x) によって生成されるグ
 ラフと等価です。同様に、3 次元での u,v,f(u,v) の描画は、f(x,y) と等価
 です。

 媒介変数表示関数は、x の関数、y の関数 (、z の関数)の順に指定し、それ
 らは共通の媒介変数およびその変域で定義されることに留意して下さい。

 さらに、`set parametric` の指定は、新しい変数変域を使用することを暗に
 宣言します。通常の f(x) や f(x,y) が xrange、yrange (、zrange) を使用
 するのに対して、媒介変数モードではそれに加えて、trange, urange, vrange
 を使用します。これらの変域は `set trange`, `set urange`, `set vrange`
 によって直接指定することも、`plot` や `splot` で指定することもできます。
 現時点では、これらの媒介変数のデフォルトの変域は [-5:5] となっています。
 将来的にはこれらのデフォルト値をもっと有意なものに変更する予定です。
3 平行描画軸設定 (paxis)
?commands set paxis
?set paxis
?show paxis
 書式:
       set paxis <axisno> {range <range-options> | tics <tic-options>}
       show paxis <axisno> {range | tics}
 コマンド `set paxis` は、平行座標描画の p1, p2, ... 軸の一つに作用する
 こと以外は、`set xrange` や `set xtics` と同じです。これらのコマンドへ
 の通常のオプションは、この描画スタイルには意味のないものもありますが、
 一応すべてを受けつけます。以下参照: `set xrange`, `set xtics`。
3 plot
?commands show plot
?show plot
 コマンド `show plot` は現在の描画コマンド、すなわち `replot` コマンド
 で再現される、直前に行われた `plot` や `splot` コマンドを表示します。

 さらにコマンド`show plot add2history` は、この現在の描画コマンドを
 `history` に書き出します。これは、`replot` を使って直前の描画コマンド
 に曲線を追加した場合、そしてコマンド行全体をすぐに編集したい場合に便利
 です。
3 pm3d
?commands set pm3d
?commands show pm3d
?set pm3d
?show pm3d
?pm3d
 pm3d は `splot` の一つのスタイルで、パレットに割り付けられた 3 次元、
 4 次元データを、カラー/灰色の色地図/曲面として描画します。これはあるア
 ルゴリズムを用いていて、これはデータが格子状であっても、データ走査毎に
 点の数が違っているような非格子状のデータであっても、前処理することなく
 描画できます。

 書式 (オプションは任意の順で与えることができます):
       set pm3d
       set pm3d {
                  { at <position> }
                  { interpolate <steps/points in scan, between scans> }
                  { scansautomatic | scansforward | scansbackward | depthorder }
                  { flush { begin | center | end } }
                  { ftriangles | noftriangles }
                  { clip1in | clip4in }
                  { corners2color
                    { mean|geomean|harmean|rms|median|min|max|c1|c2|c3|c4 }
                  }
                  { hidden3d {<linestyle>} | nohidden3d }
                  { implicit | explicit }
                  { map }
                }
       show pm3d
       unset pm3d

 splot コマンドで `with pm3d` を指定した場合、またはデータや関数描画ス
 タイル (`style`) が大域的に pm3d にセットされている場合、あるいは、
 pm3d モードが `set pm3d implicit` となっている場合は、pm3d のカラー曲
 面が描画されます。後の 2 つの場合は、plot コマンドで指定したスタイルで
 生成される網目に p3md 曲面を追加する形で描画します。例えば、
       splot 'fred.dat' with lines, 'lola.dat' with lines
 は、各データ集合毎に折れ線による網目と pm3d 曲面の両方を描画します。
 オプション `explicit` が ON (または `implicit` が OFF) の場合は、属性
 `with pm3d` が指定された描画のみが pm3d 曲面として描画されます。例えば
       splot 'fred.dat' with lines, 'lola.dat' with pm3d
 は、'freq.dat' は折れ線で (線のみで)、'lola.dat' は pm3d 曲面で描画さ
 れます。

 gnuplot の起動時はそのモードは `explicit` になっています。歴史的、そし
 て互換性のために、コマンド `set pm3d;` (すなわちオプションを指定しない
 場合) と `set pm3d at X ...` (すなわち `at` が最初のオプションの場合)
 はモードを `implicit` に変更します。コマンド `set pm3d;` は、その他の
 オプションをそれらのデフォルトの状態に設定します。

 デフォルトのデータ/関数の描画スタイルを `pm3d` にしたい場合は、例えば
       set style data pm3d
 とします。この場合、オプション `implicit` と `explicit` は効力を持ちま
 せん。

 いくつかの描画においては、それらはコマンドラインで与えられた順に描画さ
 れることに注意してください。これは特に、以前の描画を上書きしてそれでそ
 の一部を隠してしまう可能性があるような曲面の塗りつぶしの際に関心を持た
 れるでしょう。

 p3md の色付けは、3 つの異なる位置 `top`, `bottom`, `surface` のいずれ
 か、またはすべてに行えます。以下参照: `pm3d position`。以下のコマンド
 は、異なった高さで 3 つの色付きの曲面を描きます:
       set border 4095
       set pm3d at s
       splot 10*x with pm3d at b, x*x-y*y, x*x+y*y with pm3d at t

 以下も参照: `set palette`, `set cbrange`, `set colorbox`。そしてもちろ
 んデモファイル `demo/pm3d.dem` も参考になるでしょう。
4 pm3d のアルゴリズム (algorithm)
?pm3d algorithm

 まず、地図/曲面がどのように描かれるのかについて記述します。入力データ
 は、関数を評価して得られるかまたは `splot data file` から得られます。
 曲面は、走査 (孤立線) の繰り返しで構成されます。pm3d アルゴリズムでは、
 最初の走査で検出された隣り合う 2 点と、次の走査で検出された他の 2 点の
 間の領域が、これら 4 点の z の値 (または追加された 'color' 用の列の値、
 以下参照: `using`) に従って灰色で (または カラーで) 塗られます。デフォ
 ルトでは 4 つの角の値の平均値が使われますが、それはオプション
 `corners2color` で変更できます。それなりの曲面を描くためには、隣り合う
 2 点の走査が交差してはいけなくて、近接点走査毎の点の数が違いすぎてはい
 けません。もちろん、最も良いのは走査の点の数が同じことです。他には何も
 必要ではありません (例えばデータは格子状である必要もない)。他にもこの
 pm3d アルゴリズムは、入力された (計測された、あるいは計算された) 領域
 の外には何も描かない、という長所があります。

 曲面の色づけは、以下のような入力データに関して行われます:

 1. 関数、または 1 つか 3 つのデータ列からなるデータの splot: 上に述べ
 た四角形の 4 つの角の z 座標の平均値 (または `corners2color`) から、灰
 色の範囲 [0:1] を与える `zrange` または `cbrange` の範囲
 [min_color_z,max_color_z] への対応により、灰色/カラーの値が得られます。
 この値は、直接灰色の色地図用の灰色の値として使うことができます。正規化
 された灰色の値をカラーに対応させることもできます。完全な説明は、以下参
 照: `set palette`。

 2. 2 つか 4 つのデータ列からなるデータの splot: 灰色/カラーの値は、z
 の値の代わりに最後の列の座標を使って得られますので、色と z 座標が独立
 なものになります。これは 4 次元データの描画に使うことができます。

 他の注意:

 1. 物理学者の間では、gnuplot の文書やソースに現われる 'iso_curve' (孤
 立線) という言葉よりも、上で言及した '走査 (scan)' という言葉の方が使
 われています。1 度の走査と他の走査の記録により色地図を評価する、という
 のはそういう意味です。

 2. 'gray' や 'color' の値 (scale) は、滑らかに変化するカラーパレットへ
 の、連続な変数の線形写像です。その写像の様子は描画グラフの隣に長方形で
 表示されます。この文書ではそれを "カラーボックス (colorbox)" と呼び、
 その変数をカラーボックス軸の変数と呼びます。以下参照: `set colorbox`,
 `set cbrange`。

4 pm3d の位置 (position)
?pm3d position
 色の曲面は底面か天井 (この場合は灰色/カラーの平面地図) か曲面上の点の
 z 座標 (灰色/カラー曲面) に描くことができます。その選択は、オプション
 `at` に、`b`, `t`, `s` の 6 つまでの組合せの文字列をつけて指定すること
 で行えます。例えば `at b` は底面のみに描画しますし、`at st` は最初に曲
 面に描いて次に天井面に色地図を描きますし、`at bstbst` は ... 真面目な
 話、こんなものは使いません。

 塗られた四角形は、次から次へと描画されて行きます。曲面を描画する場合
 (`at s`)、後の四角形が前のものに重なり (上書きし) ます (gnuplot は塗ら
 れた多角形の網の重なりの相互作用を計算するような仮想現実ツールではあり
 ません)。 最初に走査されるデータを最初に描くか最後に描くかを切替えるス
 イッチオプション `scansforward` と `scansbackward` を試してみてくださ
 い。デフォルトは `scansautomatic` で、これは gnuplot 自身に走査の順を
 推測させます。一方で、オプション `depthorder` は四角形の順序を完全に再
 構成します。塗りつぶしは深さ順に並び変えされた後で行われ、これによりか
 なり複雑な曲面でも視覚的なものにすることができます。詳細は、以下参照:
 `pm3d depthorder`。
4 走査の順番 (scanorder)
?pm3d scanorder
?pm3d depthorder
?pm3d flush
?pm3d ftriangles
?depthorder
=flush
=scansforward
=scansbackward
=scansautomatic
=depthorder
=ftriangles
 デフォルトでは、pm3d の塗り潰し曲面を構成する四角形は、それらが曲面の
 格子点に沿って出会う順番に塗り潰されます。この順番は、オプション
 `scansautomatic`|`scansforward`|`scansbackward` で制御できます。これら
 の走査 (scan) オプションは、一般には隠面処理とは両立しません。

 2 回の連続する走査で点の数が同じでなかった場合、四角形の点の取り始めを、
 両方の走査の最初から (`flush begin`) にするか、最後から (`flush end`)
 にするか、真中から (`flush center`) にするかを決定しなければいけません。
 `flush (center|end)` は `scansautomatic` とは両立せず、よって
 `flush center` または `flush end` を指定して `scansautomatic` が設定さ
 れた場合、それは無言で `scansforward` に変更されます。

 2 回の連続する走査で点の数が同じでなかった場合、個々の走査で点が足りな
 い場合に、走査の最後に色三角形を描くかどうかをオプション `ftriangles`
 は指示します。これは滑らかな色地図の境界を描くのに使われます。

 gnuplot は、曲面の塗り潰しにおいては、本当の隠面処理は行いませんが、た
 いていは遠い方から近い方へ順に四角形要素を塗り潰すことで十分なできあが
 りになります。このモードは、以下のオプションを使うことで選択できます:
       set pm3d depthorder hidden3d
 オプション `depthorder` は塗り潰し四角形への指示で、オプション
 `hidden3d` は同様に境界線 (もし描くなら) への指示です。大域的なオプシ
 ョンである `set hidden3d` は、pm3d 曲面には影響しないことに注意してく
 ださい。

4 クリッピング (clipping)
?pm3d clipping
 四角形の x,y 座標に関するクリッピングは 2 つの方法で行われます。
 `clip1in`: 各四角形の全ての 4 点が定義されていなければならず、少なくと
 もそのうちの 1 点が x, y の範囲におさまっていなければなりません。
 `clip4in`: 各四角形の全ての 4 点が x, y の範囲におさまっていなければな
 りません。

4 色の割り当て
?pm3d color_assignment
 `3 列のデータ (x,y,z) の場合`:

 色づけの設定はカラーボックスの描画と同様に `set palette` で決定されま
 す。一つの描画では一つのパレットのみが存在し得ます。いくつもの曲面を異
 なるパレットで描画するには、`origin` と `size` を固定して `mutiplot`
 を使うことで行えます。出力ドライバが利用できる色を使い尽くしてしまう場
 合には `set palette maxcolors` を使うことを忘れずに。

 描画される各 pm3d 四角形には一つの灰色/カラー値が対応します (それは色
 勾配ではなく無地の色です)。その値は、`corners2color <option>` に従って
 4 つの角の z 座標から計算されます。
 `4 列のデータ (x,y,z,color) の場合`:

 4 列目にデータを与えた場合、それを通常は別にパレットに割り当てる灰色階
 調値とみなします。個々の四角形の彩色は上と同様に行いますが、色の値は z
 の値とは切り離されます。別の彩色オプションにより、4 列目のデータに RGB
 色を与えることもできます。以下参照: `rgbcolor variable`。この場合、描
 画コマンドは以下のようにする必要があります:

       splot ... using 1:2:3:4 with pm3d lc rgb variable

 与えられた節点に対して、その周りの 4 つの節点の平均化された (x,y) 座標
 から角を得て四角形を作って、その四角形を節点の色で塗る、といったような
 他の描画アルゴリズムが将来実装されるかもしれません。
 これは、イメージの描画 (2 次元の格子) に対しては `image` と `rgbimage`
 スタイルによって既に行なわれています。

 z の値の範囲と曲面の色の値の範囲は、z と cb に関する `set log` 同様、
 `set zrange` と `set cbrange` によって独立に調整し得ることに注意して
 ください。色地図は cb 軸のみで調節されます。以下も参照: `set view map`,
 `set colorbox`。
4 corners2color
?pm3d corners2color
?corners2color
=mean
=geomean
=harmean
=median
=min
=max
=rms
 pm3d 曲面の各四角形の色は、その 4 つの頂点の色の値に基づいて割り当てら
 れます。<option> は 'mean' (デフォルト)、'geomean', 'harmean', 'rms',
 'median' で、曲面のカラーの平滑化に幾つかの種類を与え、'min','max' は
 それぞれ最小値、最大値を選択します。これらは鋭敏な、あるいは急激なピー
 ク値を持つようなピクセルイメージや色地図を作るときには必要ありません。
 そのような場合には、むしろオプション 'c1', 'c2', 'c3', 'c4' を使って、
 四角形の色の割当にただ一つの角の z 座標を使うようにすればいいでしょう。
 どの角が 'c1' に対応するのかを知るためには何回か実験してみる必要がある
 でしょう。その向きは描画の方向に依存しています。
 pm3d アルゴリズムは、カラー曲面を入力データ点の範囲の外には描かないの
 で、オプション 'c<j>' は、格子の 2 つのへりに沿ったピクセルが、どの四
 角形の色にも寄与しない、という結果をもたらします。例えば、pm3d アルゴ
 リズムを 4x4 のデータ点の格子に適用するスクリプト `demo/pm3d.dem` (是
 非見てください) では、(4-1)x(4-1)=9 色しかない長方形が生成されます。
4 border
?set pm3d hidden3d
?pm3d hidden3d
?set pm3d border
?pm3d border
 オプション `set pm3d border {line-properties}` は、各四角形の境界線を、
 四角形が描画されてあるように描画します。通常これは、擬似的な隠線処理を
 行うために、オプション `depthorder` とともに使用します。pm3d グラフで
 は、大域的なオプション `set hidden3d` は何の効果も生まないことに注意し
 てください。デフォルトの線の属性 (色、幅) を、キーワード border の後ろ
 にオプションとして後ろにつけます。そのデフォルト値は、その後の splot
 コマンドで変更できます。

 推奨する使用例:

       set pm3d at s depthorder border lw 0.2 lt black
       unset hidden3d
       unset surf
       splot x*x+y*y linecolor rgb "blue"   # こうしないと黒

 注: 非推奨のオプション `set pm3d hidden3d N` もまだ使えますが、これは
 `set pm3d border ls N` と同じです。

4 interpolate
?set pm3d interpolate
?pm3d interpolate
 オプション `interpolate m,n` は、より細かな網目を作るために格子点間を
 補間します。データ描画に対しては、これは色の曲面を滑らかにし、その曲面
 の尖りを補正します。関数描画に対しては、この補間はほとんど意味はありま
 せんから、関数描画の場合は普通 `samples` や `isosamples` を使って標本
 数を増加させるのがいいでしょう。

 正の m, n に対しては各四角形、または三角形は、それぞれの方向に m 回、
 n 回補間されます。負の m, n では補間の頻度は、少なくとも |m|, |n| 点が
 描画されるように選択されます。これは特別な格子関数と見なすことができま
 す。

 注意: `interpolate 0,0` は、自動的に最適な補間曲面点数を選択します。

 注意: corners2color で幾何平均 (geomean) のような非線形評価が設定され
 ていたとしても、現在の色の補間は常に線形補間で行われます。
4 非推奨なオプション
?set pm3d deprecated_options
?pm3d deprecated_options
?set pm3d map
?pm3d map
?map
 このコマンドにはオプション {transparent|solid} も使われていました。現
 在は、同じ効果をそれぞれ `set grid {front|layerdefault}` によって得る
 ことができます。

 旧式のコマンド `set pm3d map` は以下の一連のものと同値です:
 `set pm3d at b; set view map scale 1.0; set style data pm3d;
 set style func pm3d;`
3 パレット (palette)
?commands set palette
?commands show palette
?set palette
?show palette
?palette
 パレットは、`pm3d` で、カラー等高線や多角形、カラーヒストグラム、色勾
 配の背景、その他実装されている、あるいは実装されるものの塗りつぶしで使
 われる、色の記憶場所です。ここではそれは滑らかで "連続的な" カラーや灰
 色階調のパレットを意味しますが、それを単にパレットと呼ぶことにします。

 カラーパレットは、多角形の色の塗りつぶしと滑らかな色のパレットをサポー
 トした出力形式を必要とし、それは現在、`pm3d` で一覧表示される出力形式
 で使用可能です。色の値の範囲は、`set cbrange` と `set log cb` で独立に
 調整可能です。カラーパレット全体は `colorbox` 中に表示されます。

 書式:
       set palette
       set palette {
                  { gray | color }
                  { gamma <gamma> }
                  {   rgbformulae <r>,<g>,<b>
                    | defined { ( <gray1> <color1> {, <grayN> <colorN>}... ) }
                    | file '<filename>' {datafile-modifiers}
                    | functions <R>,<G>,<B>
                  }
                  { cubehelix {start <val>} {cycles <val>} {saturation <val>} }
                  { model { RGB | HSV | CMY | YIQ | XYZ } }
                  { positive | negative }
                  { nops_allcF | ps_allcF }
                  { maxcolors <maxcolors> }
                }
       show palette
       show palette palette <n> {{float | int}}
       show palette gradient
       show palette fit2rgbformulae
       show palette rgbformulae
       show colornames

 `set palette` は (すなわちオプションなしでは) デフォルトの値を設定しま
 す。それ以外の場合、オプションは任意の順に与えることができます。
 `show palette` は、現在のパレットの属性を表示します。

 `show palette gradient` は、パレットの勾配 (gradient) の定義が (それが
 適切であれば) 表示されます。`show palette rgbformulae` は、定義済で利
 用できる、灰色値からカラーへの変換公式が表示されます。
 `show colornames` は、認識できる色名を表示します。

 `show palette palette <n>` は、<n> 個の離散的な色を持つパレットの、現
 在のパレットの設定によって計算される RGB の値の組とパレットの表を、画
 面、または `set print` で指定されたファイルに書き出します。デフォルト
 の広い表は、追加のオプション float または int によって、3 列の [0..1]
 の実数値だけにするか [0..255] の整数値だけにするかをそれぞれ指定できま
 す。この方法で gnuplot のカラーパレットを、Octave のような他の画像アプ
 リケーションに渡すことができます。この他にも、コマンド `test palette`
 で、現在のパレットの R,G,B 成分の対応状態 (profile) を描画しその値をデ
 ータブロック $PALETTE に残させることもできます。

 以下のオプションは、色付けの属性を決定します。

 このパレットを使用する図は、`gray` か `color` になります。例えば、
 `pm3d` カラー曲面では、範囲 [min_z,max_z] が灰色の範囲 [0:1] に対応し
 ていて、微小曲面四角形の 4 つの角の z 座標の平均値をこの範囲の中に対応
 させることで各微小部分の灰色の値 (gray) が得られます。この値は、灰色階
 調の色地図での灰色の値として直接使うことができますし、カラーの色地図で
 は、その灰色の値から (R,G,B) への変換、すなわち [0:1] から
 ([0:1],[0:1],[0:1]) への写像が使われます。

 基本的に、2 種類の異なる写像方式が利用可能です: 1 つは灰色からカラーへ
 の解析的な公式、もう一つは離散的な対応表の補間によるものです。
 `palette rgbformulae` と `palette functions` が解析的な公式用で、
 `palette defined` と `palette file` が補間表用です。`palette rgbformulae`
 は postscript 出力のサイズを小さくすることができます。

 コマンド `show palette fit2rgbformulae` は、現在の `set palette` に最
 も良く対応する `set palette rgbformulae` を見つけ出します。当然、それ
 は rgbformulae パレット以外に対しても意味を持ちます。このコマンドは主
 に、パレットの rgbformulae 定義が gnuplot と同じ物を使っている外部プロ
 グラム、例えば zimg などにとって有用です (
^ <a href="http://zimg.sourceforge.net">
           http://zimg.sourceforge.net
^ </a>
 )。

 `set palette gray` は、灰色階調のみのパレットにし、
 `set palette rgbformulae`, `set palette defined`, `set palette file`,
 `set palette functions` はカラーパレットにします。灰色パレットから直前
 のカラーパレットへ、`set palette color` で簡単に復帰できます。

 `set palette gamma <gamma>` による自動的なガンマ補正は、灰色のパレット
 (`set palette gray`) と、`cubehelix` カラーパレット形式に行われます。
 gamma = 1 の場合は、線形の光度勾配を生成します。以下参照:
 `test palette`。

 出力形式の多くは、有限個の色数しかサポートしていません (例えば gif で
 は 256 個)。デフォルトの gnuplot の線種色を割り当てた後の残りの有効な
 色領域は、デフォルトでは pm3d 用に保存されます。よって、複数のパレット
 を使用するような multiplot は、最初のパレットがすべての有効な色の配置
 として使用されてるので、失敗してしまうでしょう。このような制限は、十分
 小さい値 N で `set palette maxcolors <N>` を使うことで緩和できます。こ
 のオプションは、N 個の離散的な色を、連続的なパレットから等間隔なサンプ
 リングで選択します。不等間隔な N 個の離散色を使いたい場合は、一つの連
 続的なパレットの代わりに `set palette defined` を使用してください。

 RGB 色空間が作業を行うのに常にもっとも有用な色空間であるとは限らない、
 という理由で、色空間は `model` を使うことで、`RGB`, `HSV`, `CMY`,
 `YIQ`, `XYZ` のいずれかに変更できます。RGB 以外の色空間では
 `set palette defined` の表で色名を使うと、それはおかしな色になります。
 全ての説明は RGB 色空間用に書いてありますが、それぞれの色空間で、例え
 ば `R` は `H`, `C`, `Y`, `X` のことを意味することに注意してください
 (`G`, `B` も同様)。

 全ての色空間で、全ての値は [0,1] に制限されています。

 RGB は赤、緑、青を、CMY は水色 (Cyan)、紫 (Magenta)、黄 (Yellow) を、
 HSV は色相 (Hue)、彩度 (Saturation)、明度 (Value) をそれぞれ意味します。
 YIQ は 全米商業カラーテレビ放送協会 (the U.S. Commercial Color
 Television Broadcasting) の使ったカラーモデルで、RGB 記録方式を元にし
 ていますが、白黒テレビに対する後方互換性を持っています。XYZ は CIE
 ('Commission Internationale de l'Eclairage'; 国際照明委員会) が定義し
 た色モデルの 3 つの原刺激値です。
 色モデルのより詳しい情報については以下を参照してください:
^ <a href="http://en.wikipedia.org/wiki/Color_space">
           http://en.wikipedia.org/wiki/Color_space
^ </a>

4 rgbformulae
?commands set palette rgbformulae
?set palette rgbformulae
?palette rgbformulae
?rgbformulae
=colors
 `rgbformulae` 用には 3 つの適切な割り当て関数が選ばれる必要があります。
 この選択は `rgbformulae <r>,<g>,<b>` を通して行われます。使うことがで
 きる割り当て関数の一覧は `show palette rgbformulae` で見ることができま
 す。デフォルトは `7,5,15` で、他の例としては `3,11,6`, `21,23,3`,
 `3,23,21` などがあります。`3,-11,-6` のような負の値は、逆のカラーを意
 味します (すなわち、1-gray をその関数に代入します)。
C 下記の以下参照: オプション `positive`, `negative`)。

 RGB の色空間では、いくつかの良い割り当て公式があります:
    7,5,15   ... 伝統的 pm3d (黒-青-赤-黄)
    3,11,6   ... 緑-赤-紫
    23,28,3  ... 海 (緑-青-白); 他の組み合わせも試してみてください
    21,22,23 ... 温度色 (黒-赤-黄-白)
    30,31,32 ... 白黒のカラー表示化 (黒-青-紫-黄-白)
    33,13,10 ... 虹 (青-緑-黄-赤)
    34,35,36 ... AFM 温度色 (黒-赤-黄-白)

 HSV 色空間でのフルカラーパレット:
    3,2,2    ... 赤-黄-緑-水色-青-紫-赤

 `rgbformulae` という名前で呼ばれていても、例の通り、それらの関数は実際
 には <H>,<S>,<V> または <X>,<Y>,<Z>, ... といった色の成分を決定するか
 もしれないということに注意してください。

 図の色を反転させるには `positive` や `negative` を使ってください。
^ <a name="positive"></a>
^ <a name="negative"></a>

 他の色体系に対する最も良い rgbformulae の集合は、以下のコマンドで見つ
 けることができることを覚えておいてください。
    show palette fit2rgbformulae
4 defined
?commands set palette defined
?set palette defined
?palette defined
=colors
 灰色から RGB への対応は `palette defined` を使うことで手動で設定できま
 す: 色勾配 (gradient) は RGB の値を与えるために定義され使用されます。
 勾配は、[0,1] の灰色値から [0,1]x[0,1]x[0,1] の RGB 空間への、区分的に
 線形な写像です。その線形補間に使われる灰色値と RGB 値の組を指定する必
 要があります:

 書式:
       set palette  defined { ( <gray1> <color1> {, <grayN> <colorN>}... ) }

 <grayX> は [0,1] に割り当てられるべき灰色値で、<colorX> はそれに対応す
 る RGB 色です。カラー値は 3 種類の方法で指定することができます:

      <color> :=  { <r> <g> <b> | '<color-name>' | '#rrggbb' }

 赤、緑、青に対応する空白で区切られた 3 つの値 (それぞれ [0,1] 内)、引
 用符でくくられた色名、または引用符でくくられた X 形式の指定方式、のい
 ずれかです。勾配の定義では、これらの 3 種の型を自由に組み合わせること
 ができますが、色空間として RGB でないものが選択された場合色名 "red" は
 少し違ったものになるでしょう。使用できる色名は `show colornames` でそ
 の一覧を見ることができます。

 <r> と書いても、HSV 色空間ではそれは <H> 成分を、CIE-XYZ 空間では <X>
 を、といったように選択されたカラーモデルに依存して意味が違うことに注意
 してください。

 <gray> の値は実数の昇順に並べる必要があります。その列の値は自動的に
 [0,1] に変換されます。

 カッコつきの勾配の定義なしで `set palette defined` とした場合、RGB 色
 空間にし、あらかじめ設定されたフルスペクトル色勾配を使用します。勾配を
 表示するには `show palette gradient` を使用してください。

 例:

 灰色のパレット (役に立たないが教訓的な) を生成するには:
       set palette model RGB
       set palette defined ( 0 "black", 1 "white" )

 青黄赤のパレット (全てが等価の) を生成するには:
       set palette defined ( 0 "blue", 1 "yellow", 2 "red" )
       set palette defined ( 0 0 0 1, 1 1 1 0, 2 1 0 0 )
       set palette defined ( 0 "#0000ff", 1 "#ffff00", 2 "#ff0000" )

 虹のようなパレットを生成するには:
       set palette defined ( 0 "blue", 3 "green", 6 "yellow", 10 "red" )

 HSV 色空間でのフルカラースペクトル:
       set palette model HSV
       set palette defined ( 0 0 1 1, 1 1 1 1 )
       set palette defined ( 0 0 1 0, 1 0 1 1, 6 0.8333 1 1, 7 0.8333 0 1)

 MATLAB で使われるデフォルトパレットの近似:
       set pal defined (1 '#00008f', 8 '#0000ff', 24 '#00ffff', \
                        40 '#ffff00', 56 '#ff0000', 64 '#800000')

 等間隔な少しの色だけのパレットを生成するには:
       set palette model RGB maxcolors 4
       set palette defined ( 0 "yellow", 1 "red" )

 '交通信号' (滑らかではなく gray = 1/3, 2/3 で跳びを持つ):
       set palette model RGB
       set palette defined (0 "dark-green", 1 "green", \
                            1 "yellow",     2 "dark-yellow", \
                            2 "red",        3 "dark-red" )

4 functions
?commands set palette functions
?set palette functions
?palette functions
 色の割り当ての R(gray), G(gray), B(gray) の 3 つの関数を与えるには
 `set palette functions <Rexpr>, <Gexpr>, <Bexpr>` を使ってください。
 それらの 3 つの関数の変数は、[0,1] の値を取る変数 `gray` であり、その
 値も [0,1] の中に取る必要があります。
 <Rexpr> は、HSV 色空間が選択されている場合は、H の値を表す式でなければ
 いけないことに注意してください (他の式、または他の色空間でも同様です)。

 例:

 フルカラーパレットを生成するには:
       set palette model HSV functions gray, 1, 1

 黒から金色への良いパレット:
       set palette model XYZ functions gray**0.35, gray**0.5, gray**0.8

 ガンマ補正の白黒のパレット:
       gamma = 2.2
       color(gray) = gray**(1./gamma)
       set palette model RGB functions color(gray), color(gray), color(gray)

4 cubehelix
?commands set palette cubehelix
?set palette cubehelix
?cubehelix
 オプション "cubehelix" はあるパレット族を定義しますが、これは、灰色階
 調値が 0 から 1 に増加するのに伴ない、正味の光度が単調に増加するのと同
 時に、色相 (hue) が標準色相環に従って変化します。
       D A Green (2011) http://arxiv.org/abs/1108.5083
 `start` は、色相環に沿った開始点をラジアン単位で決定します。
 `cycles` は、パレットの範囲を渡って色相環を何回回るかを決定します。
 `saturation` (彩度) が大きいと、よりあざやかな色になります。1 より大き
 い彩度は、個々の RGB 成分をクリッピングすることになり、光度は単調では
 なくなってしまいます。`set palette gamma` もパレットに影響を与えます。
 デフォルト値は以下の通りです。
       set palette cubehelix start 0.5 cycles -1.5 saturation 1
       set palette gamma 1.5

4 file
?commands set palette file
?set palette file
?palette file
 `set palette file` は基本的に `set palette defined (<gradient>)` と同
 じで、この <gradient> がデータファイルから読み込まれます。4 列 (gray,
 R,G,B) かまたは 3 列 (R,G,B) のデータが `using` データファイル修飾子に
 よって選択される必要があります。3 列の場合、行番号が gray の値として使
 われますが、その gray の範囲は自動的に [0,1] にスケール変換されます。
 ファイルは通常のデータファイルとして読まれるので、全てのデータファイル
 修飾子が使えます。
 例えば HSV 色空間が選択されている場合には、`R` は実際には `H` を指すと
 いうことに注意してください。

 例によって、<filename> が `'-'` の場合は、データがインライン形式で引き
 続いて与えられ、一つの `e` のみの行でそれが終了することを意味します。

 勾配 (gradient) を表示するには `show palette gradient` を使用してくだ
 さい。

 例:

 RGB のパレットを [0,255] の範囲で読み込む:
       set palette file 'some-palette' using ($1/255):($2/255):($3/255)

 等距離の虹色 (青-緑-黄-赤) パレット:
       set palette model RGB file "-"
       0 0 1
       0 1 0
       1 1 0
       1 0 0
       e

 バイナリパレットファイルも同様にサポートされています。以下参照:
 `binary general`。R,G,B の double のデータの 64 個の 3 つ組をファイル
 palette.bin に出力し、それを読み込む例:
       set palette file "palette.bin" binary record=64 using 1:2:3


4 ガンマ補正 (gamma correction)
?commands set palette gamma-correction
?set palette gamma-correction
?palette gamma-correction
?gamma-correction
 灰色の配色に対するガンマ補正は `set palatte gamma <gamma>` で ON にで
 きます。<gamma> のデフォルトは 1.5 で、これは多くの出力形式に適切な値
 です。

 ガンマ補正は、cubehelix カラーパレット形式には適用されますが、他の色形
 式には適用されません。しかし、明示的な色関数にガンマ補正を実装するのは
 難しくありません。

 例:
       set palette model RGB
       set palette functions gray**0.64, gray**0.67, gray**0.70

 補間された勾配を使ってガンマ補正を行うには、適当なカラーに中間の値を指
 定します。

       set palette defined ( 0 0 0 0, 1 1 1 1 )

 の代わりに例えば以下を指定してください:

       set palette defined ( 0 0 0 0, 0.5 .73 .73 .73, 1 1 1 1 )

 または、線形補間が "ガンマ補正" の補間に十分良く適合するまでより良い中
 間の点を探してください。

4 postscript
?commands set palette postscript
?set palette postscript
 postscript ファイルのサイズを小さくする目的で、灰色の輝度値、そして全
 てではないいくつかの計算された RGB の輝度値がそのファイル中に書かれま
 す。成分関数は postscript 言語で直接コード化され、pm3d の描画の直前に
 ヘッダとしておかれます。/g や /cF の定義を参照してください。通常その定
 義をその中に書くことは、3 つの式のみが使われる場合に意味を持ちます。し
 かし、multiplot やその他の理由で postscript ファイル中のその変換関数を
 直接手で編集したいと思うかも知れません。これがデフォルトのオプション
 `nops_allcF` です。オプション `ps_allcF` を使うと、全ての公式の定義が
 postscript ファイル中に書かれます。一つのグラフ中で、異なる曲面に異な
 るパレットを持たせたいという目的で postscript ファイルを編集したい場合
 に、このオプションに関心を持つでしょう。その機能は、`origin` と `size`
 を固定して `multiplot` を使うことで実現できるでしょう。

 pm3d 曲面を PostScript ファイルへ書いている場合、gnuplot に付属する
 awk スクリプト `pm3dCompress.awk` を使うことで、そのファイルサイズを
 50% まで小さくできるかもしれません。データが四角形の格子状になっている
 場合は、スクリプト `pm3dConvertToImage.awk` を使うことでより大きな圧縮
 率が得られる可能性があります。
 使用法:
     awk -f pm3dCompress.awk thefile.ps >smallerfile.ps
     awk -f pm3dConvertToImage.awk thefile.ps >smallerfile.ps

3 pointinterval の箱サイズ (pointintervalbox)
?commands set pointintervalbox
?set pointintervalbox
?pointintervalbox
 線種の属性 `pointinterval` は描画スタイル `linespoints` で使われます。
 pointinterval を負の値、例えば -N とすると、点の記号は N 番目毎に書き、
 そして各点の記号の後ろの箱 (実際には円) の部分を背景色で塗りつぶして消
 します。コマンド `set pointintervalbox` はその消す領域の大きさ (半径)
 を制御します。これはデフォルトの半径 (= pointsize) に対する倍率です。
3 点サイズ (pointsize)
?commands set pointsize
?commands show pointsize
?set pointsize
?show pointsize
?pointsize
 コマンド `set pointsize` は描画で使われる点の大きさを変更します。

 書式:
       set pointsize <multiplier>
       show pointsize

 デフォルトは 1.0 倍です。画像データ出力では、大きいポイントサイズの方
 が見やすいでしょう。

 一つの描画に対するポイントサイズは `plot` コマンドの上でも変更できます。
 詳細は、以下参照: `plot with`。

 ポイントサイズの設定は、必ずしも全ての出力形式でサポートされているわけ
 ではないことに注意してください。
3 極座標モード (polar)
?commands set polar
?commands unset polar
?commands show polar
?set polar
?unset polar
?show polar
?polar
?nopolar
 コマンド `set polar` はグラフの描画方法を xy 直交座標系から極座標系に
 変更します。

 書式:
       set polar
       unset polar
       show polar

 極座標モードでは、仮変数 (t) は角度を表します。t のデフォルトの範囲は
 [0:2*pi] ですが、単位として度が選択されていれば [0:360] となります
 (以下参照: `set angles`)。

 コマンド `unset polar` は描画方法をデフォルトの xy 直交座標系に戻しま
 す。

 `set polar` コマンドは `splot` ではサポートされていません。`splot` に
 対する同様の機能に関しては、以下参照: `set mapping`。

 極座標モードでは t の数式の意味は r=f(t) となり、t は回転角となります。
 trange は関数の定義域 (角度) を制御し、rrange, xrange, yrange はそれぞ
 れグラフの x,y 方向の範囲を制御することになります。これらの範囲と
 rrange は自動的に設定されるか、または明示的に設定できます。詳細に関し
 ては、以下参照: `set rrange`, `set xrange`。

 例:
       set polar
       plot t*sin(t)
       set trange [-2*pi:2*pi]
       set rrange [0:3]
       plot t*sin(t)

 最初の `plot` はデフォルトの角度の範囲の 0 から 2*pi を使います。動径
 方向とグラフのサイズは自動的に伸縮されます。2 番目の `plot` は角度の定
 義域を拡張し、グラフのサイズを原点から 3 の幅に制限します。これは x,y
 のそれぞれの方向を [-3:3] に制限することになります。

 `set size square` とすると `gnuplot` はアスペクト比 (縦横の比) を 1 に
 するので円が (楕円でなく) 円に見えるようになります。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/polar.html">
 極座標のデモ (polar.dem)
^ </a>
 および
^ <a href="http://www.gnuplot.info/demo/poldat.html">
 極座標データの描画 (poldat.dem)。
^ </a>
3 print コマンドの出力先 (print)
?commands set print
?commands show print
?set print
?show print
 コマンド `set print` は `print` コマンドの出力をファイルにリダイレクト
 します。

 書式:
       set print
       set print "-"
       set print "<filename>" [append]
       set print "|<shell_command>"
       set print $datablock [append]

 "<filename>" がない場合は出力は <STDERR> になります。"-" という
 <filename> は <STDOUT> を意味します。`append` フラグはファイルを追加
 (append) モードで開くことを意味します。パイプをサポートするプラットホ
 ーム上では、<filename> が "|" で始まっていたら、<shell_command> へのパ
 イプが開かれます。

 コマンド `print` の対象は名前付きデータブロックでも構いません。データ
 ブロック名は '$' で始まります。以下参照: `inline data`。
3 PostScript 定義ファイルパス (psdir)
?commands set psdir
?commands show psdir
?set psdir
?show psdir
?psdir
 コマンド `set psdir <directory>` は、postscript 出力形式が prologue.ps
 や文字エンコード用のファイルを探すのに使用する検索パスを制御します。こ
 の仕組みは、別にローカルにカスタマイズした prolog ファイル群と切り替え
 るのに使えます。検索の順番は以下のようになっています。
       1) `set psdir` を指定した場合はそのディレクトリ
       2) 環境変数 GNUPLOT_PS_DIR で指定したディレクトリ
       3) 組み込まれたヘッダー、またはデフォルトのシステムディレクトリ
       4) `set loadpath` で指定したディレクトリ
3 極座標の動径軸 (raxis)
?commands set raxis
?raxis
 コマンド `set raxis` と `unset raxis` は、動径軸を格子線と x 軸から分
 離して描画するかどうかを切り替えます。現在の rrange の最小値が 0 でな
 い (そして自動縮尺でない) 場合、グラフと軸が原点に達しないことを示す白
 丸が極座標グラフの中心に描かれます。軸の線は、グラフの境界と同じ線種で
 描画されます。以下参照: `polar`, `rrange`, `rtics`, `set grid`。
3 rmargin
?commands set rmargin
?set rmargin
?rmargin
 コマンド `set rmargin` は右の余白のサイズをセットします。
 詳細は、以下参照: `set margin`。
3 rrange
?commands set rrange
?commands show rrange
?set rrange
?show rrange
?rrange
 コマンド `set rrange` は極座標モードのグラフの動径方向の範囲を設定しま
 す。これは xrange と yrange の両方も設定してしまいます。両者は、
 [-(rmax-rmin) : +(rmax-rmin)] になります。しかし、これの後で xrange や
 yrange を変更しても (例えば拡大するために)、それは rrange を変更しない
 ので、データ点は rrange に関してクリッピングされたままとなります。rmin
 に関する自動縮尺は常に rmin = 0 となります。
 注意: rmin を負の値を設定すると、予期せぬ結果を生む可能性があります。
3 rtics
?commands set rtics
?commands show rtics
?set rtics
?show rtics
?rtics
 コマンド `set rtics` は、動径軸に沿って目盛りを配置します。これは、極
 座標モードでのみ表示されます。目盛りとその見出しは原点の右側に描かれま
 す。キーワード `mirror` は、それらを原点の左側にも描きます。その他のキ
 ーワードに関する話については以下参照: `polar`, `set xtics`,
 `set mxtics`。
3 サンプル数 (samples)
?commands set samples
?commands show samples
?set samples
?show samples
?samples
 関数、またはデータの補間に関するデフォルトのサンプリング数は、コマンド
 `set samples` で変更できます。個々のグラフの描画範囲 (sampling range)
 の変更は、以下参照: `plot sampling`。

 書式:
       set samples <samples_1> {,<samples_2>}
       show samples

 デフォルトではサンプル数は 100 点と設定されています。この値を増やすと
 より正確な描画が出来ますが遅くなります。このパラメータはデータファイル
 の描画には何の影響も与えませんが、補間/近似のオプションが使われている
 場合はその限りではありません。2 次元描画については `plot smooth` を、
 3 次元描画に関しては、以下参照: `set dgrid3d`。

 2 次元のグラフ描画が行なわれるときは <samples_1> の値のみが関係します。

 隠線処理なしで曲面描画が行なわれるときは、samples の値は孤立線毎に評価
 されるサンプル数の指定になります。各 v-孤立線は <samples_1> 個のサンプ
 ル点を持ち、u-孤立線は <samples_2> 個のサンプル数を持ちます。<samples_1>
 のみ指定すると、<samples_2> の値は <samples_1> と同じ値に設定されます。
 以下も参照: `set isosamples`。
3 グラフ領域サイズ (size)
?commands set size
?commands show size
?set size
?show size
?size
?aspect ratio
?set size square
?set size ratio
?ratio
?square
 書式:
       set size {{no}square | ratio <r> | noratio} {<xscale>,<yscale>}
       show size

 <xscale> と <yscale> は描画全体の拡大の倍率で、描画全体とはグラフとラ
 ベルと余白の部分を含みます。

 重要な注意:
       gnuplot の以前の版では、`set size` の値を、出力する描画領域
       (キャンバス) のサイズを制御するのにも使っていた出力形式もありま
       したが、すべての出力形式がそうだったわけではありませんでした。
       現在は、ほとんどの出力形式が以下のルールに従います:

 `set term <terminal_type> size <XX>, <YY>` は、出力ファイルのサイズ、
 または "キャンバス" のサイズを制御します。サイズパラメータの有効な値に
 ついては、個々の出力形式のヘルプを参照してください。デフォルトでは、グ
 ラフはそのキャンバス全体に描画されます。

 `set size <XX>, <YY>` は、描画自体をキャンバスのサイズに対して相対的に
 伸縮させます。1 より小さい伸縮値を指定すると、グラフはキャンバス全体を
 埋めず、1 より大きい伸縮値を指定すると、グラフの一部分のみがキャンバス
 全体に合うように描画されます。1 より大きい伸縮値を指定すると、ある出力
 形式では問題が起こるかもしれないことに注意してください。

 `ratio` は、指定した <xscale>, <yscale> の描画範囲内で、グラフのアスペ
 クト比 (縦横比) を <r> にします (<r> は x 方向の長さに対する y 方向の
 長さの比)。

 <r> の値を負にするとその意味は違って来ます。<r>=-1 のとき、x 軸、y 軸
 の双方の単位 (つまり 1) の目盛りの長さが同一になるよう設定されます。こ
 れは `set view equal xy` と同じです。以下参照: `set view equal`。
 <r>=-2 のとき、y 軸の単位目盛りの長さは x 軸の単位目盛りの長さの 2 倍
 に設定されます。<r> が負の値に関して以下同様です。

 `gnuplot` が指定されたアスペクト比のグラフをちゃんと書けるかは選択され
 る出力形式に依存します。グラフの領域は出力の指定された部分にちゃんと収
 まり、アスペクト比が <r> であるような最大の長方形となります (もちろん
 適当な余白も残しますが)。
=square

 `set size square` は `set size ratio 1` と同じ意味です。

 `noratio` と `nosquare` はいずれもグラフをその出力形式 (terminal) での
 デフォルトのアスペクト比に戻しますが、<xscale> と <yscale> はそのデフ
 ォルトの値 (1.0) には戻しません。

 `ratio` と `square` は 3 次元描画では意味を持ちませんが、`set view map`
 を使用した 3 次元描画の 2 次元射影には影響を与えます。 以下も参照:
 `set view equal`。これは、3 次元の x 軸と y 軸を強制的に同じスケールに
 します。

 例:

 グラフが現在のキャンバスを埋めるような大きさに設定します:
       set size 1,1

 グラフを通常の半分の大きさで正方形にします:
       set size square 0.5,0.5

 グラフの高さを横幅の 2 倍にします:
       set size ratio 2

3 描画スタイル設定 (style)
?set style
?show style
?unset style
 デフォルトの描画スタイルは、`set style data` と `set style function`
 で設定できます。関数やデータのデフォルトの描画スタイルを個々に変更す
 る方法については、以下参照: `plot with`。スタイルの一覧全体は、以下参
 照: `plotting styles`。

 書式:
       set style function <style>
       set style data <style>
       show style function
       show style data

 指定できる描画要素のデフォルトスタイルも設定できます。

 書式:
       set style arrow <n> <arrowstyle>
       set style boxplot <boxplot style options>
       set style circle radius <size> {clip|noclip}
       set style ellipse size <size> units {xy|xx|yy} {clip|noclip}
       set style fill <fillstyle>
       set style histogram <histogram style options>
       set style line <n> <linestyle>
       set style rectangle <object options> <linestyle> <fillstyle>
       set style textbox {opaque|transparent} {{no}border}

4 矢印スタイル設定 (set style arrow)
?commands set style arrow
?commands unset style arrow
?commands show style arrow
?set style arrow
?unset style arrow
?show style arrow
?arrowstyle
 各出力形式は矢や点の形のデフォルトの集合を持っていて、それはコマンド
 `test` で参照できます。`set style arrow` は矢の形、幅、点の形、サイズ
 を定義し、それらを後で使うときにいちいち同じ情報を繰り返して指定しなく
 てもインデックスで参照できるようにします。

 書式:
       set style arrow <index> default
       set style arrow <index> {nohead | head | heads}
                               {size <length>,<angle>{,<backangle>} {fixed}}
                               {filled | empty | nofilled | noborder}
                               {front | back}
                               { {linestyle | ls <line_style>}
                                 | {linetype | lt <line_type>}
                                   {linewidth | lw <line_width} }
       unset style arrow
       show style arrow

 <index> は整数で、それで矢のスタイル (arrowstyle) を特定します。

 `default` を指定すると、全ての arrow スタイルパラメータはそのデフォル
 トの値になります。

 <index> の arrowstyle が既に存在する場合、他の全ては保存されたまま、与
 えられたパラメータのみが変更されます。<index> が存在しなければ、指定さ
 れなかった値はデフォルトの値になります。

 `nohead` を指定することで、矢先のない矢、すなわち線分を書くこともでき
 ます。これは描画の上に線分を描く別な方法を与えます。デフォルトでは 1
 つの矢先がついています。`heads` の指定で線分の両端に矢先が描かれます。

 矢先の大きさは `size <length>,<angle>` または
 `size <length>,<angle>,<backangle>` で制御できます。`<length>` は矢先
 の各枝の長さで、`<angle>` は矢先の枝と矢軸がなす角度 (単位は度) です。
 `<length>` の単位は x 軸と同じですが、それは `<length>` の前に `first`,
 `second`, `graph`, `screen`, `character` をつけることで変更できます。
 詳細は、以下参照: `coordinates`。

 デフォルトでは、とても短い矢の矢先は小さくしますが、これは、`size` コ
 マンドの後ろに `fixed` を使うことで無効にできます。

 `<backangle>` は、矢先の後ろの部分の矢軸との切り角 (`<angle>` と同じ方
 向、単位は度) になりますが、スタイルが `nofilled` の場合はこれを無視し
 ます。

 `filled` を指定すると、矢先の回りの線 (境界線) を描き、矢先を塗りつぶ
 します。`noborder` を指定すると、矢先は塗りつぶしますが、境界線は描き
 ません。この場合、矢先の先端がベクトルの終点ピッタリの場所に置かれ、そ
 の矢先は全体として少し小さくなります。点線で矢を描く場合は、点線の境界
 線は汚いので、常に `noborder` を使うべきです。矢先の塗りつぶしは、すべ
 ての出力形式がサポートしているとは限りません。

 線種はユーザの定義したラインスタイルのリストから選ぶこともできますし
 (以下参照: `set style line`)、用意されている `<line_type>` の値 (デフ
 ォルトのラインスタイルのリストの番号) そして `<linewidth>` (デフォルト
 の幅の倍数) を使ってここで定義することもできます。

 しかし、ユーザー定義済のラインスタイルが選択された場合、その属性 (線種、
 幅) は、単に他の `set style arrow` コマンドで適当な番号や `lt`, `lw`
 などを指定しても、変更はできないことに注意して下さい。

 `front` を指定すると、矢はグラフのデータの上に描かれます。`back` が指
 定された場合 (デフォルト) は矢はグラフのデータの下に描かれます。`front`
 を使えば、密集したデータで矢が見えなくなることを防ぐことができます。

 例:

 矢先がなく、倍の幅が矢を描くには:
       set style arrow 1 nohead lw 2
       set arrow arrowstyle 1

 その他の例については、以下参照: `set arrow`。

4 boxplot スタイル指定 (boxplot)
?commands set style boxplot
?commands unset style boxplot
?commands show style boxplot
?set style boxplot
?unset style boxplot
?show style boxplot
 コマンド `set style boxplot` により、描画スタイル `boxplot` で生成する
 描画のレイアウトを変更できます。

 書式:
       set style boxplot {range <r> | fraction <f>}
                         {{no}outliers} {pointtype <p>}
                         {candlesticks | financebars}
                         {separation <x>}
                         {labels off | auto | x | x2}
                         {sorted | unsorted}

 boxplot の箱は、常にデータ点の第一四分位から第三四分位の値の範囲にかか
 っています。箱から延長される箱ひげの限界は、2 つの異なる方法で制御でき
 ます。デフォルトでは、箱ひげは、その箱のそれぞれの端から、四分位範囲の
 1.5 倍 (すなわち、その箱の厳密な垂直方向の高さ) に等しい範囲にまで延長
 されます。箱ひげそれぞれは、データ集合のある点に属する y の値で終了す
 るように、メジアンに向かって切り捨てられます。四分位範囲の丁度 1.5 倍
 の値の点がない場合もありますから、箱ひげはその名目上の範囲よりも短くな
 る場合もあります。このデフォルトは以下に対応します。
       set style boxplot range 1.5

 もう一つの方法として、箱ひげがかかる点の総数の割合 (fraction) を指定す
 ることができます。この場合、その範囲はメジアン値から、データ集合の指定
 した分を囲い込むまで、対称に延長されます。このときも、個々の箱ひげはデ
 ータ集合内の点の端までに制限されます。データ集合の 95% の点をはるには
 以下のようにします。
       set style boxplot fraction 0.95

 箱ひげの範囲の外にある任意の点は、outliers と見なされます。デフォルト
 ではそれらはひとつひとつ円 (pointtype 7) で描かれますが、オプション
 `nooutliers` はこれを無効にします。

 デフォルトでは boxplot は candlesticks と似たスタイルで描画しますが、
 financebars と似たスタイルで描画するためのオプションもあります。

 boxplot の using 指定が 4 列目を持つ場合、その列の値はある因子変数の離
 散的なレベル値であると見なします。この場合、その因子変数のレベルの数と
 同じだけの複数の boxplot が描かれます。それらの boxplot の隣り合うもの
 同士の距離はデフォルトでは 1.0 (x 軸の単位で) ですが、この間隔はオプシ
 ョン `separation` で変更できます。

 オプション `labels` は、これらの boxplot (それぞれデータ集合のある部分
 に対応する) のどこに、どのようにラベルをつけるかを決定します。デフォル
 トでは因子の値を水平軸 (x か x2 のいずれか plot で使われている方) の目
 盛ラベルに出力します。これはオプションの `labels auto` に対応します。
 オプション `labels x`, `labels x2` によって、強制的に x 軸、x2 軸にそ
 れぞれ出力させることもできますし、`labels off` でオフにすることもでき
 ます。

 デフォルトでは、因子変数の異なるレベルに対応する boxplot は整列化はせ
 ず、データファイルにそのレベルが現れる順番に描画します。この挙動はオプ
 ションの `unsorted` に対応しますが、オプション `sorted` を使用すると、
 まずレベルを辞書順にソートし、その順に boxplot を描画します。

 オプション `separation`, `labels`, `sorted`, `unsorted` は、plot に 4
 列目の指定を与えた場合のみ効力を持ちます。

 以下参照: `boxplot`, `candlesticks`, `financebars`。

4 データ描画スタイル指定 (set style data)
?commands set style data
?commands show style data
?set style data
?show style data
?data style
 コマンド `set style data` はデータ描画に対するデフォルトの描画スタイル
 を変更します。

 書式:
       set style data <plotting-style>
       show style data

 選択項目については、以下参照: `plotting styles`。項目を指定しなかった
 場合、その一覧が表示されます。`show style data` は現在のデフォルトのデ
 ータ描画スタイルを表示します。
4 塗り潰しスタイル指定 (set style fill)
?commands set style fill
?commands show style fill
?set style fill
?show style fill
?fillstyle
 コマンド `set style fill` は、boxes, histograms, candlesticks,
 filledcurves での描画における描画要素のデフォルトのスタイルの設定に使
 われます。このデフォルトは、個々の描画に塗り潰しスタイル (fillstyle)
 を指定することで上書きできます。以下参照: `set style rectangle`。

 書式:
       set style fill {empty
                       | {transparent} solid {<density>}
                       | {transparent} pattern {<n>}}
                      {border {lt} {lc <colorspec>} | noborder}

 デフォルトの塗りつぶしスタイル (fillstyle) は `empty` です。

 オプション `solid` は、出力形式がサポートしている場合、その色でのベタ
 塗りを行います。パラメータ <density> は塗りつぶし色の強さを表していて
 <density> が 0.0 なら箱は空、<density> が 1.0 なら箱はその内部は現在の
 線種と完全に同じ色で塗られます。出力形式によっては、この強さを連続的に
 変化させられるものもありますが、その他のものは、部分的な塗りつぶしの幾
 つかのレベルを実装しているに過ぎません。パラメータ <density> が与えら
 れなかった場合はデフォルトの 1 になります。

 オプション `pattern` は、出力ドライバによって与えられるパターンでの塗
 りつぶしを行います。利用できる塗りつぶしパターンの種類と数は出力ドライ
 バに依存します。塗りつぶしの boxes スタイルで複数のデータ集合を描画す
 る場合そのパターンは、複数の曲線の描画における線種の周期と同様、有効な
 パターンを、パターン <n> から始めて周期的に利用します。

 オプション `empty` は、箱を塗りつぶしませんが、これがデフォルトです。

 デフォルトの `border` は、現在の線の種類の実線で箱の境界を描きます。
 `border <colorspec>` で境界の色を変更することができます。`noborder` は
 境界の線が描かれないようにします。
5 透明化 (set style fill transparent)
?commands set style fill transparent
?set style fill transparent
?fillstyle transparent
?transparent
 いくつかの出力形式は、塗りつぶし領域の `transparent` (透明化) 属性をサ
 ポートしています。transparent solid の領域塗りつぶしでは、`density`
 (密度) パラメータはアルファ値として使用されます。つまり、密度 0 は完全
 な透明を、密度 1 は完全な不透明を意味します。transparent pattern の塗
 りつぶしでは、パターンの背景が完全な透明か完全な不透明のいずれかです。

@start table - 透明化のドライバのサポート
       出力形式   solid pattern    pm3d
       --------------------------------
       gif           no     yes      no
       jpeg         yes      no     yes
       pdf          yes     yes     yes
       png    TrueColor   index     yes
       post          no     yes      no
       svg          yes      no     yes
       win          yes     yes     yes
       wxt          yes     yes     yes
       x11           no     yes      no
#\begin{tabular}{|cccl|} \hline
#出力形式   &   solid & pattern &    pm3d \\ \hline
#gif        &      no &     yes &      no \\
#jpeg       &     yes &      no &     yes \\
#pdf        &     yes &     yes &     yes \\
#png        &TrueColor&   index &     yes \\
#post       &      no &     yes &      no \\
#svg        &     yes &      no &     yes \\
#win        &     yes &     yes &     yes \\
#wxt        &     yes &     yes &     yes \\
#x11        &      no &     yes &      no \\
%c l .
%出力形式@solid@pattern@pm3d
%_
%gif@no@yes@no
%jpeg@yes@no@yes
%pdf@yes@yes@yes
%png@TrueColor@index@yes
%post@no@yes@no
%svg@yes@yes@yes
%win@yes@yes@yes
%wxt@yes@yes@yes
%x11@no@yes@no
%_
@end table

^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="center">
^  <col align="center">
^  <col align="center">
^</colgroup>
^<thead>
^<tr>    <th>出力形式</th>    <th>solid</th>    <th>pattern</th>    <th>pm3d</th></tr>
^</thead>
^<tbody>
^<tr>    <td>gif</td>    <td>no</td>    <td>yes</td>    <td>no</td></tr>
^<tr>    <td>jpeg</td>    <td>yes</td>    <td>no</td>    <td>yes</td></tr>
^<tr>    <td>pdf</td>    <td>yes</td>    <td>yes</td>    <td>yes</td></tr>
^<tr>    <td>png</td>    <td>TrueColor</td>    <td>index</td>    <td>yes</td></tr>
^<tr>    <td>post</td>    <td>no</td>    <td>yes</td>    <td>no</td></tr>
^<tr>    <td>svg</td>    <td>yes</td>    <td>yes</td>    <td>yes</td></tr>
^<tr>    <td>win</td>    <td>yes</td>    <td>yes</td>    <td>yes</td></tr>
^<tr>    <td>wxt</td>    <td>yes</td>    <td>yes</td>    <td>yes</td></tr>
^<tr>    <td>x11</td>    <td>no</td>    <td>yes</td>    <td>no</td></tr>
^</tbody>
^</table>

 透明な塗りつぶし領域を含むグラフを見たり作ったりするのには、別な制限が
 ありうることに注意してください。例えば、png 出力形式では、"truecolor"
 オプションが指定されている場合にのみ透明化の塗り潰しが利用できます。
 PDF ファイルには透明化領域が正しく記述されていても、PDF の表示ソフトに
 よってはそれを正しく表示できないこともありえます。実際に PostScript プ
 リンタでは問題はないのに、Ghostscript/gv ではパターン塗りつぶし領域を
 正しく表示できません。
4 関数描画スタイル指定 (set style function)
?commands set style function
?commands show style function
?set style function
?show style function
 コマンド `set style function` は関数描画に対するデフォルトの描画スタイ
 ル (lines, points, filledcurves など) を変更します。以下参照:
 `plotting styles`。

 書式:
       set style function <plotting-style>
       show style function
4 set style increment
?commands set style increment
?commands show style increment
?set style increment
?show style increment
 `注意`: このコマンドは非推奨です。代わりに新しいコマンド `set linetype`
 を使用してください。これは、代用のための一時的な適当な線種を検索するの
 ではなく、線種自体を再定義します。以下参照: `set linetype`。

 書式:
       set style increment {default|userstyles}
       show style increment

 デフォルトでは、同じグラフ上の次の描画は、現在の出力形式でデフォルトで
 定義されている線種の次のもので行われます。
 しかし、`set style increment user` を選択すると、デフォルトの線種では
 なく、ユーザ定義ラインスタイル番号のものを使用させることができます。

 例:

       set style line 1 lw 2 lc rgb "gold"
       set style line 2 lw 2 lc rgb "purple"
       set style line 4 lw 1 lc rgb "sea-green"
       set style increment user

       plot f1(x), f2(x), f3(x), f4(x)

 これは、関数 f1, f2, f4 は新たにユーザ定義されたラインスタイルで描画さ
 れます。ユーザ定義ラインスタイルが見つからない場合は、代わりにそれに対
 応するデフォルトの線種が利用されます。例えば、上の例では、f3(x) はデフ
 ォルトの線種 3 で描画されます。

4 線スタイル指定 (set style line)
?commands set style line
?commands unset style line
?commands show style line
?set style line
?unset style line
?show style line
?linestyle
?linewidth
=linewidth
=interval
=linespoints
=pointinterval
 出力装置にはおのおのデフォルトの線種と点種の集合があり、それらはコマン
 ド `test` で見ることができます。`set style line` は線種と線幅、点種と
 点の大きさを、個々の呼び出しで、それらの情報を全部指定する代わりに、単
 なる番号で参照できるようにあらかじめ定義するものです。

 書式:
       set style line <index> default
       set style line <index> {{linetype  | lt} <line_type> | <colorspec>}
                              {{linecolor | lc} <colorspec>}
                              {{linewidth | lw} <line_width>}
                              {{pointtype | pt} <point_type>}
                              {{pointsize | ps} <point_size>}
                              {{pointinterval | pi} <interval>}
                              {palette}
       unset style line
       show style line

 `default` は、全てのラインスタイルパラメータをそれと同じ index を持つ
 線種 (linetype) に設定します。

 <index> の linestyle が既に存在する場合、他の全ては保存されたまま、与
 えられたパラメータのみが変更されます。<index> が存在しなければ、指定さ
 れなかった値はデフォルトの値になります。

 このようにつくられるラインスタイルは、デフォルトの型 (線種, 点種) を
 別なものに置き換えることはしないので、ラインスタイル、デフォルトの型、
 どちらも使えます。ラインスタイルは一時的なもので、コマンド `reset` を
 実行すればいつでもそれらは消え去ります。線種自体を再定義したい場合は、
 以下参照: `set linetype`。

 線種と点種は、その index 値をデフォルトとします。その index 値に対する
 実際の記号の形は、出力形式によって異なり得ます。

 線幅と点の大きさは、現在の出力形式のデフォルトの幅、大きさに対する乗数
 です (しかし、ここでの <point_size> は、コマンド `set pointsize` で与
 えられる乗数には影響を受けないことに注意してください)。

 `pointinterval` は、スタイル `linespoints` でグラフ中に描かれる点の間
 隔を制御します。デフォルトは 0 です (すべての点が描画される)。例えば、
 `set style line N pi 3` は、点種が N、点の大きさと線幅は現在の出力形式
 のデフォルトで、`with linespoints` での描画では点は 3 番目毎に描画され
 るようなラインスタイルを定義します。その間隔を負の値にすると、それは間
 隔は正の値の場合と同じですが、点の記号の下になる線を書かないようにしま
 す (出力形式によっては)。

 全ての出力装置が `linewidth` や `pointsize` をサポートしているわけでは
 ありません。もしサポートされていない場合はそれらのオプションは無視され
 ます。

 出力形式に依存しない色を `linecolor <colorspec>` か `linetype <colorspec>`
 (省略形は `lc`, `lt`) のいずれかを使って割り当てることができます。この
 場合、色は RGB の 3 つ組で与えるか、gnuplot の持つパレットの色名、現在
 のパレットに対する小数指定、または cbrange への現在のパレットの対応に
 対する定数値、のいずれかで与えます。以下参照: `colors`, `colorspec`,
 `set palette`, `colornames`, `cbrange`。

 `set style line <n> linetype <lt>` は、出力形式に依存した点線/破線のパ
 ターンと色の両方をセットします。`set style line <n> linecolor <colorspec>`
 や `set style line <n> linetype <colorspec>` は、現在の点線/破線のパタ
 ーンを変更せずに新しい線色を設定します。

 3 次元モード(`splot` コマンド) では、"linetype palette z" の省略形とし
 て特別にキーワード `palette` を使うことも許されています。その色の値は、
 splot の z 座標 (高さ) に対応し、曲線、あるいは曲面に沿って滑らかに変
 化します。

 例:
 以下では、番号 1, 2, 3 に対するデフォルトの線種をそれぞれ赤、緑、青とし、
 デフォルトの点の形をそれぞれ正方形、十字、三角形であるとします。このとき
 以下のコマンド

       set style line 1 lt 2 lw 2 pt 3 ps 0.5

 は、新しいラインスタイルとして、緑でデフォルトの 2 倍の幅の線、および
 三角形で半分の幅の点を定義します。また、以下のコマンド

       set style function lines
       plot f(x) lt 3, g(x) ls 1

 は、f(x) はデフォルトの青線で、g(x) はユーザの定義した緑の線で描画しま
 す。同様に、コマンド

       set style function linespoints
       plot p(x) lt 1 pt 3, q(x) ls 1

 は、p(x) を赤い線で結ばれたデフォルトの三角形で、q(x) は緑の線で結ばれ
 た小さい三角形で描画します。

       splot sin(sqrt(x*x+y*y))/sqrt(x*x+y*y) w l pal

 は、`palette` に従って滑らかな色を使って曲面を描画します。これはそれを
 サポートした出力形式でしかちゃんとは動作しないことに注意してください。
 以下も参照: `set palette`, `set pm3d`。

       set style line 10 linetype 1 linecolor rgb "cyan"

 は、RGB カラーをサポートするすべての出力形式で、ラインスタイル 10 に実
 線の水色を割り当てます。

4 円スタイル指定 (set style circle)
?commands set style circle
?commands unset style circle
?commands show style circle
?set style circle
?unset style circle
?show style circle

 書式:
       set style circle {radius {graph|screen} <R>}
                        {{no}wedge}
                        {clip|noclip}

 このコマンドは、描画スタイル "with circles" で使われるデフォルトの半径
 を設定します。これは、データ描画で 2 列のデータ (x,y) しか与えなかった
 場合、あるいは関数描画のときに適用されます。デフォルトは、以下のように
 なっています: "set style circle radius graph 0.02"。`nowedge` は、扇形
 の円弧部分から中心に向かう 2 本の半径を描かないようにしますが、デフォ
 ルトは `wedge` です。このパラメータは完全な円に対しては何もしません。
 `clip` は円を描画境界でクリッピングしますが、`noclip` はこれを無効にし
 ます。デフォルトは `clip` です。

4 長方形スタイル指定 (set style rectangle)
?commands set style rectangle
?commands unset style rectangle
?commands show style rectangle
?set style rectangle
?unset style rectangle
?show style rectangle

 コマンド `set object` で定義された長方形には別々のスタイルを設定できま
 す。しかし、個別のスタイル指定をしなければ、そのオブジェクトはコマンド
 `set style rectangle` によるデフォルトを受け継ぎます。

 書式:
     set style rectangle {front|back} {lw|linewidth <lw>}
                         {fillcolor <colorspec>} {fs <fillstyle>}

 以下参照: `colorspec`, `fillstyle`。`fillcolor` は `fc` と省略できます。

 例:
     set style rectangle back fc rgb "white" fs solid 1.0 border lt -1
     set style rectangle fc linsestyle 3 fs pattern 2 noborder

 デフォルトの設定は、背景色での塗り潰しで、境界は黒になっています。

4 楕円スタイル指定 (set style ellipse)
?commands set style ellipse
?commands show style ellipse
?set style ellipse
?unset style ellipse
?show style ellipse

 書式:
       set style ellipse {units xx|xy|yy}
                         {size {graph|screen} <a>, {{graph|screen} <b>}}
                         {angle <angle>}
                         {clip|noclip}

 このコマンドは、楕円の直径を同じ単位で計算するかどうかを制御します。
 デフォルトは `xy` で、これは楕円の主軸 (第 1 軸) の直径は x (または x2)
 軸と同じ単位で計算し、副軸 (第 2 軸) の直径は y (または y2) 軸の単位で
 計算します。このモードでは、楕円の両軸の比は、描画軸のアスペクト比に依
 存します。`xx` か `yy` に設定すれば、すべての楕円の両軸は同じ単位で計
 算されます。これは、描画される楕円の両軸の比は、回転しても正しいままで
 すが、水平方向か垂直方向の一方の縮尺の変更により正しくなくなることを意
 味します。

 これは、object として定義された楕円、コマンド `plot` によって描画され
 る楕円の両方に影響を与える全体的な設定ですが、`units` の値は、描画毎、
 オブジェクト毎に設定を再定義できます。

 楕円のデフォルトのサイズも、キーワード `size` で設定できます。デフォル
 トのサイズは、2 列のみのデータ、または関数の plot 命令で適用されます。
 2 つの値は、楕円の (2 つの主軸、2 つの副軸に向かい合う) 主軸直径と副軸
 直径として使用されます。

 デフォルトは、"set style ellipse size graph 0.05,0.03" です。

 最後になりますが、デフォルトの向きをキーワード `angle` で設定もできま
 す。向きは、楕円の主軸とグラフの x 軸の方向となす角で、単位は度で与え
 る必要があります。

 `clip` は楕円を描画境界でクリッピングしますが、`noclip` はこれを無効に
 します。デフォルトは `clip` です。

 楕円の object の定義に関しては以下も参照: `set object ellipse`。2 次元
 の描画スタイルに関しては以下参照: `ellipses`。
4 文字列ボックススタイル指定 (set style textbox)
?commands set style textbox
?commands show style textbox
?set style textbox
?unset style textbox
?show style textbox
?textbox

 書式: set style textbox {opaque|transparent}{{no}border}

 このコマンドは、属性 `boxed` による label の表示を制御します。箱付き文
 字列をサポートしない出力形式はこのスタイルを無視します。
3 曲面描画 (surface)
?commands set surface
?commands unset surface
?commands show surface
?set surface
?unset surface
?show surface
?surface
?nosurface
 コマンド `set surface` は 3 次元描画 (`splot`) にのみ関係します。

 書式:
       set surface {implicit|explicit}
       unset surface
       show surface

 `unset surface` により `splot` は、関数やデータファイルの点に対するど
 んな点や線も描かなくなります。これは主に、等高線を作る曲面を描く代わり
 に等高線のみを描く場合に有用です。その場合でも `set contour` の設定に
 よりますが、曲面上に等高線が描かれます。他のものは通常のままで、ある一
 つの関数やデータファイルの曲面のみをオフにするには、`splot` コマンド上
 でキーワード `nosurface` を指定してください。等高線を格子の土台に表示
 したい場合は `unset surface; set contour base` という組が便利でしょう。
 以下も参照: `set contour`。

 3 次元データの組が網目 (格子線) と認識されると、gnuplot はデフォルトで
 は格子曲面を要求しているものとして、暗黙に `with lines` の描画スタイル
 を用います。以下参照: `grid_data`。コマンド `set surface explicit` は
 この機能を抑制し、入力ファイルの分離されたデータブロックで記述される孤
 立線のみを描画します。この場合でも、splot で明示的に `with surface` と
 すれば格子曲面が描画されます。
3 テーブルデータ出力 (table)
?commands set table
?set table
?table
 `table` モードが有効な場合、`plot` と `splot` コマンドは、現在の出力形
 式に対する実際の描画を生成する替わりに X Y {Z} R の値の複数列からなる
 表形式のテキスト出力を行ないます。文字 R は、次の 3 種類のうちの一つで
 す: その点が有効な範囲内にある場合は "i"、範囲外の場合は "o"、未定義値
 (undefined) の場合は "u" です。データの書式は、軸の刻みの書式
 (以下参照: `set format`) によって決まり、列は一つの空白で区切られます。
 これは、等高線を生成し、それを再利用のために保存したいときに便利です。
 この方法は、補間されたデータを保存するのにも使うことができます (以下参
 照: `set samples`, `set dgrid3d`)。

 書式:
       set table {"outfile" | $datablock}
       plot <whatever>
       unset table

 表形式の出力は、指定したファイルに書き出しますが、指定がない場合は現在
 の `set output` が指定するものに出力します。他に、表形式出力を名前付き
 データブロックにリダイレクトすることもできます。データブロック名は '$'
 で始まります。以下も参照: `inline data`。現在の出力形式の標準的な描画
 に戻すには、`unset table` を明示的に行なう必要があります。

 入力データのスタイル依存の処理 (平滑化、誤差線、2 軸範囲のチェック等)
 を避けるため、あるいは表出力する列を増やすには、通常の描画スタイルの代
 わりに "table" キーワードを使うことができます。例:

      set table
      plot <file> using 1:2:3:4:5:6:7:8:9:10 with table
3 出力形式 (terminal)
?commands set terminal
?commands show terminal
?set terminal
?set term
?show terminal
?show term
?set terminal push
?set term push
?terminal push
?term push
?push
?set terminal pop
?set term pop
?terminal pop
?term pop
?pop
 `gnuplot` は数多くのグラフィック形式をサポートしています。コマンド
 `set terminal` を使って `gnuplot` の出力の対象となる形式の種類を選んで
 ください。出力先をファイル、または出力装置にリダイレクトするには
 `set output` を使ってください。

 書式:
       set terminal {<terminal-type> | push | pop}
       show terminal

 <terminal-type> が省略されると `gnuplot` は利用可能な出力形式の一覧を
 表示します。<terminal-type> の指定には短縮形が使えます。

 `set terminal` と `set output` の両方を使う場合、`set terminal` を最初
 にする方が安全です。それは、OS によっては、それが必要とするフラグをセ
 ットする出力形式があるからです。

 いくつかの出力形式はたくさんの追加オプションを持ちます。
 各 `<term>` に対し、直前の `set term <term> <options>` で使用されたオ
 プションは記憶され、その後の `set term <term>` がそれをリセットするこ
 とはありません。これは例えば印刷時に有用です。幾つかの異なる出力形式を
 切替える場合、前のオプションを繰り返し唱える必要はありません。

 コマンド `set term push` は、現在の出力形式とその設定を `set term pop`
 によって復帰するまで記憶しています。これは `save term`, `load term` と
 ほぼ同等ですが、ファイルシステムへのアクセスは行わず、よって例えばこれ
 は、印刷後にプラットホームに依存しない形で出力形式を復帰する目的に使え
 ます。gnuplot の起動後、デフォルト、または `startup` ファイルに書かれ
 た出力形式が自動的に記憶 (push) されます。よって、明示的に出力形式を記
 憶させることなく、任意のプラットホーム上でデフォルトの出力形式を
 `set term pop` によって復帰させる、という動作を期待したスクリプトを可
 搬性を失わずに書くことが出来ます。

 詳細は、以下参照: `complete list of terminals`。

3 出力形式へのオプション (termoption)
?commands set termoption
?set termoption
?termoption
 コマンド `set termoption` は、現在使用している出力形式の振舞いを、新た
 な `set terminal` コマンドの発行なしに変更することを可能にします。この
 コマンド一つに対して一つのオプションのみが変更できます。そしてこの方法
 で変更できるオプションはそう多くはありません。現在使用可能なオプション
 は以下のもののみです。

      set termoption {no}enhanced
      set termoption font "<fontname>{,<fontsize>}"
      set termoption fontscale <scale>
      set termoption {solid|dashed}
      set termoption {linewidth <lw>}{lw <lw>}

3 全軸目盛り制御 (tics)
?commands set tics
?commands unset tics
?commands show tics
?set tics
?unset tics
?show tics
?tics
 コマンド `set tics` を使えば、全ての軸の見出しのつく目盛りの制御を一度
 に行うことができます。

 目盛りは `unset tics` で消え、`set tics` で目盛りがつきます (デフォル
 ト)。個々の軸の目盛りは、これとは別のコマンド `set xtics`, `set ztics`
 などを使って制御できます。

 書式:
       set tics {axis | border} {{no}mirror}
                {in | out} {front | back}
                {{no}rotate {by <ang>}} {offset <offset> | nooffset}
                {left | right | center | autojustify}
                {format "formatstring"} {font "name{,<size>}"} {{no}enhanced}
                { textcolor <colorspec> }
       set tics scale {default | <major> {,<minor>}}
       unset tics
       show tics

 オプションは、個々の軸 (x, y, z, x2, y2, cb) にも適用できます。例:
       set xtics rotate by -90
       unset cbtics

 tics の `front` または `back` の設定は、2D 描画 (splot は不可) にのみ
 すべての軸に 1 度適用されます。これは、目盛りと描画要素が重なった場合
 に目盛りを描画要素の前面に出すか、奥に置くかを制御します。

 `axis` と `border` は `gnuplot` に目盛り (目盛りの刻み自身とその見出し)
 を、それぞれ軸につけるのか、境界につけるのかを指示します。軸が境界にと
 ても近い場合、`axis` を使用すると境界が表示されていれば (以下参照:
 `set border`) 目盛りの見出し文字を境界の外に出してしまうでしょう。この
 場合自動的なレイアウトアルゴリズムによる余白設定は大抵よくないものとな
 ってしまいます。

 `mirror` は `gnuplot` に反対側の境界の同じ位置に、見出しのない目盛りを
 出力するよう指示します。`nomirror` は、あなたが想像している通りのこと
 を行ないます。

 `in` と `out` は目盛りの刻みを内側に描くか外側に描くかを切り変えます。

 `set tics scale` は、目盛りの刻みの大きさを制御します。最初の <major>
 の値には、自動的に生成され、またユーザも指定できる大目盛り (レベル 0)
 を指定し、2 つ目の <minor> の値には、自動的に生成され、またユーザも指
 定できる小目盛り (レベル 1) を指定します。<major> のデフォルトは 1.0
 で、<minor> のデフォルトは <major>/2 です。さらに値を追加すれば、レベ
 ル 2, 3, ... の目盛りの大きさになります。`set tics scale default` でデ
 フォルトの目盛りの大きさに復帰します。

 `rotate` は、文字列を 90 度回転させて出力させようとします。これは、文
 字列の回転をサポートしている出力ドライバ (terminal) では実行されます。
 `norotate` はこれをキャンセルします。`rotate by <ang>` は角度 <ang> の
 回転を行ないますが、これはいくつかの出力形式 (terminal) でサポートされ
 ています。

 x と y 軸の大目盛りのデフォルトは `border mirror norotate` で、x2, y2
 軸は `border nomirror norotate` がデフォルトです。z 軸のデフォルトは
 `nomirror` です。

 <offset> は x,y かまたは x,y,z の形式ですが、それに座標系を選択して、
 その前に `first`, `second`, `graph`, `screen`, `character` のいずれか
 をつけることもできます。<offset> は、目盛りの見出し文字列のデフォルト
 の位置からのずらし位置で、そのデフォルトの単位系は `character` です。
 詳細は、以下参照: `coordinates`。`nooffset` は offset を OFF にします。

 デフォルトでは見出しラベルは、美しい結果を生むように、軸と回転角に依存
 した位置に自動的に位置合わせされます。それが気にいらなければ、明示的に
 `left`, `right`, `center` のキーワードにより位置合わせを変更できます。
 `autojustify` でデフォルトの挙動に復帰します。

 オプションなしの `set tics` は、目盛りの刻みを内側にしますが、その他の
 全てのオプションは直前の値を保持します。

 大目盛り (ラベルのつく) の他の制御に関しては、以下参照: `set xtics`。
 小目盛りの制御に関しては、以下参照: `set mxtics`。これらのコマンドは、
 各軸の独立な制御を提供します。
3 ticslevel
?commands set ticslevel
?commands show ticslevel
?set ticslevel
?show ticslevel
?ticslevel
 現在は推奨されていません。以下参照: `set xyplane`。
3 ticscale
?commands set ticscale
?commands show ticscale
?set ticscale
?show ticscale
?ticscale
 コマンド `set ticscale` は現在は推奨されていません。代わりに
 `set tics scale` を使ってください。
3 タイムスタンプ (timestamp)
?commands set timestamp
?commands unset timestamp
?commands show timestamp
?set timestamp
?unset timestamp
?show timestamp
?timestamp
?notimestamp
 コマンド `set timestamp` は描画の日付と時刻を左の余白に表示します。

 書式:
       set timestamp {"<format>"} {top|bottom} {{no}rotate}
                     {offset <xoff>{,<yoff>}} {font "<fontspec>"}
                     {textcolor <colorspec>}
       unset timestamp
       show timestamp

 書式文字列 (format) を使って、書かれる日付と時刻の書式を選択することが
 できます。デフォルトは asctime() が使用する "%a %b %d %H:%M:%S %Y" で
 す (曜日、月名、日、時、分、秒、4 桁の西暦)。`top` と `bottom` を使っ
 て日付を左の余白の上に配置するか、下に配置するかを選択できます (デフォ
 ルトは下)。`rotate` は、もし出力形式がサポートしていればですが、日付を
 垂直方向の文字列にします。定数 <xoff>、<yoff> はずれ (offset) を意味し、
 これによってより適切な位置合わせが行えます。<font> は日付が書かれるフ
 ォントを指定します。

 `timestamp` の代わりに省略名 `time` を使っても構いません。

 例:
       set timestamp "%d/%m/%y %H:%M" offset 80,-2 font "Helvetica"

 日付の書式文字列に関する詳しい情報については、以下参照: `set timefmt`。
3 日時データ入力書式 (timefmt)
?commands set timefmt
?commands show timefmt
?set timefmt
?show timefmt
?timefmt
 このコマンドは、データが日時の形式になっている場合に、その時系列データ
 に適用されます。これはコマンド `set *data time` も与えられていないと意
 味がありません。

 書式:
       set timefmt "<format string>"
       show timefmt

 文字列引数 (<format string>) は `gnuplot` に日時データをデータファイル
 からどのように読むかを指示します。有効な書式は以下の通りです:

@start table - まずは対話型テキスト形式
       書式         説明
       %d           何日, 1--31
       %m           何月, 1--12
       %y           何年, 0--99
       %Y           何年, 4-digit
       %j           1 年の何日目, 1--365
       %H           何時, 0--24
       %M           何分, 0--60
       %s           Unix epoch (1970-01-01, 00:00 UTC) からの秒数
       %S           何秒 (出力では 0--60 の整数、入力では実数)
       %b           月名 (英語) の 3 文字省略形
       %B           月名 (英語)
#\begin{tabular}{|cl|} \hline
#\multicolumn{2}{|c|}{時系列データ書式指定子}\\
#\hline \hline
#書式 & 説明 \\ \hline
#\verb@%d@ & 何日, 1--31 \\
#\verb@%m@ & 何月, 1--12 \\
#\verb@%y@ & 何年, 0--99 \\
#\verb@%Y@ & 何年, 4 桁 \\
#\verb@%j@ & 1 年の何日目, 1--365 \\
#\verb@%H@ & 何時, 0--24 \\
#\verb@%M@ & 何分, 0--60 \\
#\verb@%s@ & Unix epoch (1970-01-01, 00:00 UTC) からの秒数\\
#\verb@%S@ & 何秒 (出力では 0--60 の整数、入力では実数)\\
#\verb@%b@ & 月名 (英語) の 3 文字省略形 \\
#\verb@%B@ & 月名 (英語) \\
%c l .
%書式@説明
%_
%%d@何日, 1--31
%%m@何月, 1--12
%%y@何年, 0--99
%%Y@何年, 4 桁
%%j@1 年の何日目, 1--365
%%H@何時, 0--24
%%M@何分, 0--60
%%s@Unix epoch (1970-01-01, 00:00 UTC) からの秒数
%%S@何秒 (出力では 0--60 の整数、入力では実数)
%%b@月名 (英語) の 3 文字省略形
%%B@月名 (英語)
%_
@end table


^<table align="center" border="1" rules="groups" frame="hsides" cellpadding="3">
^<colgroup>
^  <col align="center">
^  <col align="left">
^</colgroup>
^<thead>
^<tr>    <th>書式</th>    <th>説明</th></tr>
^</thead>
^<tbody>
^<tr>    <td><tt>%d</tt></td>    <td>何日, 1&ndash;31</td></tr>
^<tr>    <td><tt>%m</tt></td>    <td>何月, 1&ndash;12</td></tr>
^<tr>    <td><tt>%y</tt></td>    <td>何年, 0&ndash;99</td></tr>
^<tr>    <td><tt>%Y</tt></td>    <td>何年, 4-digit</td></tr>
^<tr>    <td><tt>%j</tt></td>    <td>1 年の何日目, 1&ndash;365</td></tr>
^<tr>    <td><tt>%H</tt></td>    <td>何時, 0&ndash;24</td></tr>
^<tr>    <td><tt>%M</tt></td>    <td>何分, 0&ndash;60</td></tr>
^<tr>    <td><tt>%s</tt></td>    <td>Unix epoch (1970-01-01 00:00 UTC) からの秒数</td></tr>
^<tr>    <td><tt>%S</tt></td>    <td>何秒 (出力では 0&ndash;60 の整数、入力では実数)</td></tr>
^<tr>    <td><tt>%b</tt></td>    <td>月名 (英語) の 3 文字省略形</td></tr>
^<tr>    <td><tt>%B</tt></td>    <td>月名 (英語)</td></tr>
^</tbody>
^</table>

 任意の文字を文字列中で使用できますが、規則に従っている必要があります。
 \t (タブ) は認識されます。バックスラッシュ + 8 進数列 (\nnn) はそれが
 示す文字に変換されます。日時要素の中に分離文字がない場合、%d, %m, %y,
 %H, %M, %S はそれぞれ 2 桁の数字を読み込みます。%S での読み込みで小数
 点がそのフィールドについている場合は、その小数点つきの数を小数の秒指定
 だと解釈します。%Y は 4 桁、%j は 3 桁の数字を読み込みます。%b は 3 文
 字を、%B は必要な分だけの文字を要求します。

 空白 (スペース) の扱いはやや違います。書式文字列中の 1 つの空白は、フ
 ァイル中の 0 個、あるいは 1 つ以上の空白文字列を表します。すなわち、
 "%H %M" は "1220" や "12     20" を "12 20" と同じように読みます。

 データ中の非空白文字の集まりそれぞれは、`using n:n` 指定の一つ一つの列
 とカウントされます。よって `11:11  25/12/76  21.0` は 3 列のデータと認
 識されます。混乱を避けるために、日時データが含まれる場合 `gnuplot` は、
 あなたの `using` 指定が完璧なものであると仮定します。

 日付データが曜日、月の名前を含んでいる場合、書式文字列でそれを排除しな
 ければいけませんが、"%a", "%A", "%b", "%B" でそれらを表示することはで
 きます。`gnuplot` は数値から月や曜日を正しく求めます。これら、及び日時
 データの出力の他のオプションの詳細に関しては、以下参照: `set format`。

 2 桁の西暦を %y で読む場合、69-99 は 2000 年未満、00-68 は 2000 年以後
 と見なします。注意: これは、UNIX98 の仕様に合わせたものですが、この慣
 例はあちこちで違いがあるので、2 桁の西暦値は本質的にあいまいです。

 他の情報については、以下も参照: `set xdata`, `time/date`。

 例:
       set timefmt "%d/%m/%Y\t%H:%M"
 は、`gnuplot` に日付と時間がタブで分離していることを教えます (ただし、
 あなたのデータをよーく見てください。タブだったものがどこかで複数のスペ
 ースに変換されていませんか ? 書式文字列はファイル中に実際にある物と一
 致していなければなりません)。
 以下も参照
^ <a href="http://www.gnuplot.info/demo/timedat.html">
 時系列データ (time data) デモ。
^ </a>
3 グラフタイトル (title)
?commands set title
?commands show title
?set title
?show title
?title
 コマンド `set title` は、描画の上の真中に書かれる描画タイトルを生成し
 ます。`set title` は `set label` の特殊なもの、とみなせます。

 書式:
       set title {"<title-text>"} {offset <offset>} {font "<font>{,<size>}"}
                 {{textcolor | tc} {<colorspec> | default}} {{no}enhanced}
       show title

 <offset> を x,y かまたは x,y,z の形式で指定した場合は、タイトルは与え
 られた値だけ移動されます。それに座標系を選択して、その前に `first`,
 `second`, `graph`, `screen`, `character` のいずれかをつけることもでき
 ます。詳細は、以下参照: `coordinates`。デフォルトでは `character` 座標
 系が使われます。例えば、"`set title offset 0,-1`" はタイトルの y 方向
 の位置のみ変更し、大ざっぱに言って 1 文字分の高さだけタイトルを下に下
 げます。1 文字の大きさは、フォントと出力形式の両方に依存します。

 <font> はタイトルが書かれるフォントを指定するのに使われます。<size> の
 単位は、どの出力形式 (terminal) を使っているかによって変わります。

 `textcolor <colorspec>` は、文字の色を変更します。<colorspec> は、線
 種、rgb 色、またはパレットへの割当のいずれかが指定できます。以下参照:
 `colorspec`, `palette`。

 `noenhanced` は、拡張文字列処理 (enhanced text) モードが有効になってい
 る場合でも、タイトルを拡張文字列処理させないようにします。

 `set title` をパラメータなしで使うとタイトルを消去します。

 バックスラッシュ文字列の作用、及び文字列を囲む単一引用符と二重引用符の
 違いについては、以下参照: `syntax`。
3 tmargin
?commands set tmargin
?set tmargin
?tmargin
 コマンド `set tmargin` は上の余白のサイズをセットします。詳細は、以下
 参照: `set margin`。
3 trange
?commands set trange
?commands show trange
?set trange
?show trange
?trange
 コマンド `set trange` は、媒介変数モード、あるいは極座標モードでの x,y
 の値を計算するのに使われる媒介変数の範囲を設定します。詳細は、以下参照:
 `set xrange`。
3 urange
?commands set urange
?commands show urange
?set urange
?show urange
?urange
 `set urange` と `set vrange` は、`splot` の媒介変数モードで x,y,z の値
 を計算するのに使われる媒介変数の範囲を設定します。詳細は、以下参照:
 `set xrange`。
3 variables
?commands show variables
?show variables all
?show variables
 `show variables` コマンドはユーザ定義変数と内部変数の現在の値の一覧を
 表示します。gnuplot は、GPVAL_, MOUSE_, FIT_, TERM_ で始まる名前を持つ
 変数を内部で定義しています。

 書式:
       show variables      # GPVAL_ で始まるもの以外の変数を表示
       show variables all  # GPVAL_ で始まるものも含め全ての変数を表示
       show variables NAME # NAME で始まる変数のみを表示

3 version
?show version
 コマンド `show version` は現在起動している gnuplot のバージョン、最終
 修正日、著作権者と、FAQ や info-gnuplot メーリングリスト、バグレポート
 先のメールアドレスを表示します。対話的にプログラムが呼ばれているときは
 スクリーン上にその情報を表示します。

 書式:
       show version {long}

 `long` オプションを与えると、さらにオペレーティングシステム、`gnuplot`
 インストール時のコンパイルオプション、ヘルプファイルの置き場所、そして
 (再び) 有用なメールアドレスを表示します。
3 視線方向 (view)
?commands set view
?commands show view
?set view
?set view map
?show view
?view
 コマンド `set view` は `splot` の視線の角度を設定します。これは、グラ
 フ描画の 3 次元座標をどのように 2 次元の画面 (screen) に投影するかを制
 御します。これは、描画されたデータの回転と縮尺の制御を与えてくれますが
 正射影しかサポートしていません。3 次元射影、および 2 次元描画的地図上
 への 2 次元直交射影がサポートされています。

 書式:
       set view <rot_x>{,{<rot_z>}{,{<scale>}{,<scale_z>}}}
       set view map {scale <scale>}
       set view {no}equal {xy|xyz}
       show view

 ここで <rot_x> と <rot_z> は、画面に投影される仮想的な 3 次元座標系の
 回転角 (単位は度) の制御で、最初は (すなわち回転が行なわれる前は)
 画面内の水平軸は x, 画面内の垂直軸は y, 画面自身に垂直な軸が z となっ
 ています。最初は x 軸の周りに <rot_x> だけ回転されます。次に、新しい
 z 軸の周りに <rot_z> だけ回転されます。

 コマンド `set view map` は、グラフを地図のように表示するのに使います。
 これは等高線 (`contour`) のグラフや、pm3d モードによる 2 次元温度分布
 などで `with image` よりもむしろ有用です。後者では、入力データ点のフィ
 ルタ用の `zrange` の設定、および色の範囲の縮尺に関する `cbrange` の設
 定を適切に行うことに注意してください。

 <rot_x> は [0:180] の範囲に制限されていて、デフォルトでは 60 度です。
 <rot_z> は [0:360] の範囲に制限されていて、デフォルトでは 30 度です。
 <scale> は `splot` 全体の伸縮率を制御し、<scale_z> は z 軸の伸縮のみを
 行ないます。伸縮率のデフォルトはどちらも 1.0 です。

 例:
       set view 60, 30, 1, 1
       set view ,,0.5

 最初の例は 4 つの全てをデフォルトの値にしています。2 つめの例は縮小率
 のみを 0.5 に変更しています。
4 equal_axes
?set view equal_axes
?set view equal
?view equal_axes
?view equal
?equal_axes
 コマンド `set view equal xy` は x 軸と y 軸の単位の長さが強制的に等し
 くなるように縮尺を合わせ、グラフがページに丁度合うようにその縮尺を選択
 します。コマンド `set view equal xyz` は、さらに z 軸も x と y 軸に合
 うようにしますが、現在の z 軸の範囲が、描画境界の範囲に合う保証はあり
 ません。デフォルトでは、3 つの軸は独立に有効な領域を埋めるように伸縮さ
 れます。

 以下も参照: `set xyplane`。
3 vrange
?commands set vrange
?commands show vrange
?set vrange
?show vrange
?vrange
 コマンド `set urange` と `set vrange` は、`splot` の媒介変数 (パラメー
 タ) モードで x, y, z の値を計算するのに使われる媒介変数の範囲を設定し
 ます。 詳細は、以下参照: `set xrange`。
3 x2data
?commands set x2data
?commands show x2data
?set x2data
?show x2data
?x2data
 コマンド `set x2data` は x2 (上) 軸のデータを時系列 (日時) 形式に設定
 します。詳細は、以下参照: `set xdata`。
3 x2dtics
?commands set x2dtics
?commands unset x2dtics
?commands show x2dtics
?set x2dtics
?unset x2dtics
?show x2dtics
?x2dtics
?nox2dtics
 コマンド `set x2dtics` は x2 (上) 軸の目盛りを曜日に変更します。詳細は、
 以下参照: `set xdtics`。
3 x2label
?commands set x2label
?commands show x2label
?set x2label
?show x2label
?x2label
 コマンド `set x2label` は x2 (上) 軸の見出しを設定します。詳細は、以下
 参照: `set xlabel`。
3 x2mtics
?commands set x2mtics
?commands unset x2mtics
?commands show x2mtics
?set x2mtics
?unset x2mtics
?show x2mtics
?x2mtics
?nox2mtics
 コマンド `set x2mtics` は、x2 (上) 軸を 1 年の各月に設定します。詳細は、
 以下参照: `set xmtics`。
3 x2range
?commands set x2range
?commands show x2range
?set x2range
?show x2range
?x2range
 コマンド `set x2range` は x2 (上) 軸の表示される水平範囲を設定します。
 コマンドオプションのすべての説明については、以下参照: `set xrange`。こ
 のコマンドは、x2 軸が明示的に x 軸にリンク (link) されている場合は無視
 されます。以下参照: `set link`。
3 x2tics
?commands set x2tics
?commands unset x2tics
?commands show x2tics
?set x2tics
?unset x2tics
?show x2tics
?x2tics
?nox2tics
 コマンド `set x2tics` は x2 (上) 軸の、見出し付けされる大目盛りの制御
 を行ないます。詳細は、以下参照: `set xtics`。
3 x2zeroaxis
?commands set x2zeroaxis
?commands unset x2zeroaxis
?commands show x2zeroaxis
?set x2zeroaxis
?unset x2zeroaxis
?show x2zeroaxis
?x2zeroaxis
?nox2zeroaxis
 コマンド `set x2zeroaxis` は、原点を通る x2 (上) 軸 (y2 = 0) を描きま
 す。詳細は、以下参照: `set zeroaxis`。
3 軸毎のデータ種類指定 (xdata)
?commands set xdata
?commands show xdata
?set xdata
?show xdata
?xdata
 このコマンドは x 軸のデータ形式の解釈を制御します。他の軸それぞれにも
 同様のコマンドが機能します。

 書式:
       set xdata time
       show xdata

 `ydata`, `zdata`, `x2data`, `y2data`, `cbdata` にも同じ書式が当てはま
 ります。

 `time` オプションはデータが秒単位の日時データであることを伝えます。現
 在の gnuplot は時刻をミリ秒の精度保存します。

 オプションなしの場合は、データの解釈方法を通常の形式に戻します。
4 日時データ (time)
?commands set xdata time
?set xdata time
 `set xdata time` は、x 座標がミリ秒精度の日時データであることを意味し
 ます。`set ydata time` のように、他の軸用のこれと同等のコマンドもあり
 ます。

 日時データの解釈は、2 つの別の書式で制御しています。ファイルからの入力
 データは、その軸に対する `timefmt` を使って読み込みます。以下参照:
 `set timefmt`。
 その軸の範囲を示す場合は、この同じ `timefmt` の書式で引用符に囲んで指
 定します。

 例:

      set xdata time
      set timefmt "%d-%b-%Y"
      set xrange ["01-Jan-2013" : "31-Dec-2014"]

 出力、すなわち軸に沿った目盛りのラベルや、マウス操作での座標出力につい
 ては、デフォルトでは、秒での内部時刻から日時を表現する文字列への変換に
 は、関数 'strftime' (unix でそれを調べるには "man strftime" とタイプし
 てください) を使います。`gnuplot` はこれを適当に意味のある書式で表示し
 ようとしますが、`set format x` か `set xtics format` のいずれかを使っ
 てカスタマイズすることもできます。
 特別な時間書式指定子に関しては、以下参照: `time_specifiers`。他の情報
 については、以下も参照: `time/date`。
3 曜日軸目盛り (xdtics)
?commands set xdtics
?commands unset xdtics
?commands show xdtics
?set xdtics
?unset xdtics
?show xdtics
?xdtics
?noxdtics
 コマンド `set xdtics` は x 軸の目盛りの刻みを曜日に変換します (0=Sun,
 6=Sat)。6 を越える場合は 7 による余りが使われます。`unset xdtics` は
 その見出しをデフォルトの形式に戻します。他の軸にも同じことを行なう同
 様のコマンドが用意されています。

 書式:
       set xdtics
       unset xdtics
       show xdtics

 `ydtics`, `zdtics`, `x2dtics`, `y2dtics`, `cbdtics` にも同じ書式が当て
 はまります。

 以下も参照: `set format`。
3 軸ラベル (xlabel)
?commands set xlabel
?commands show xlabel
?set xlabel
?show xlabel
?xlabel
 コマンド `set xlabel` は x 軸の見出しを設定します。他の軸にも見出しを
 設定する同様のコマンドがあります。

 書式:
       set xlabel {"<label>"} {offset <offset>} {font "<font>{,<size>}"}
                  {textcolor <colorspec>} {{no}enhanced}
                  {rotate by <degrees> | rotate parallel | norotate}
       show xlabel

 同じ書式が `x2label`, `ylabel`, `y2label`, `zlabel`, `cblabel` にも適
 用されます。

 <offset> を x,y かまたは x,y,z の形式で指定した場合は、見出しは与えら
 れた値だけ移動されます。それに座標系を選択して、その前に `first`,
 `second`, `graph`, `screen`, `character` のいずれかをつけることもでき
 ます。詳細は、以下参照: `coordinates`。デフォルトでは `character` 座標
 系が使われます。例えば、"`set xlabel offset -1,0`" は見出しの x 方向の
 位置のみ変更し、大ざっぱに言って 1 文字分の幅だけ見出しを左にずらしま
 す。1 文字の大きさは、フォントと出力形式の両方に依存します。

 <font> は見出しが書かれるフォントを指定するのに使われます。フォントの
 <size> (大きさ) の単位は、どんな出力形式を使うかに依存します。

 `noenhanced` は、拡張文字列処理 (enhanced text) モードが有効になってい
 る場合でも、ラベル文字列を拡張文字列処理させないようにします。

 見出しを消去するには、オプションをつけずに実行します。例: "`set y2label`"

 軸の見出しのデフォルトの位置は以下の通りです:

 xlabel: x 軸の見出しはグラフの下の真中

 ylabel: y 軸の見出しはグラフの左の真中で、水平方向に書かれるか垂直方向
 になるかは出力形式依存

 zlabel: z 軸の見出しは軸の表示範囲より上で、見出しの真中が z 軸の真上

 cblabel: 色見本 (color box) の軸の見出しは箱に沿って中央揃えされ、箱の
 向きが水平なら下に、垂直なら右に

 y2label: y2 軸の見出しは y2 軸の右。その位置は、出力形式依存で y 軸と
 同様の規則で決定。

 x2label: x2 軸の見出しはグラフの上で、タイトルよりは下。これは、 改行
 文字を使えば、それによる複数の行からなる描画タイトルで x2 軸の見出しを
 生成することも可能。例:

       set title "This is the title\n\nThis is the x2label"

 これは二重引用符を使うべきであることに注意してください。この場合、もち
 ろん 2 つの行で同じフォントが使われます。

 2 次元描画の場合の x, x2, y, y2 軸のラベルの方向 (回転角) は、
 `rotate by <角度>` を指定することで変更できます。3 次元描画の x, y 軸
 のラベルの方向はデフォルトでは水平方向になっていますが、
 `rotate parallel` を指定することで軸に平行にすることができます。

 もし軸の位置のデフォルトの位置が気に入らないならば、代わりに `set label`
 を使ってください。このコマンドは文字列をどこに配置するかをもっと自由に
 制御できます。

 バックスラッシュ文字列の作用、及び文字列を囲む単一引用符と二重引用符の
 違いに関するより詳しい情報については、以下参照: `syntax`。
3 月軸目盛り (xmtics)
?commands set xmtics
?commands unset xmtics
?commands show xmtics
?set xmtics
?unset xmtics
?show xmtics
?xmtics
?noxmtics
 コマンド `set xmtics` は x 軸の目盛りの見出しを月に変換します。1=Jan
 (1 月)、12=Dec (12 月) となります。12 を越えた数字は、12 で割ったあまりの
 月に変換されます。`unset xmtics` で目盛りはデフォルトの見出しに戻ります。
 他の軸に対しても同じ役割をする同様のコマンドが用意されています。

 書式:
       set xmtics
       unset xmtics
       show xmtics

 `x2mtics`, `ymtics`, `y2mtics`, `zmtics`, `cbmtics` にも同じ書式が適用
 されます。

 以下も参照: コマンド `set format`。
3 軸範囲指定 (xrange)
?commands set xrange
?commands show xrange
?set xrange
?show xrange
?writeback
?restore
?xrange
 コマンド `set xrange` は表示される水平方向の範囲を指定します。他の軸
 にも同様のコマンドが存在しますし、極座標での動径 r, 媒介変数 t, u, v
 にも存在します。

 書式:
       set xrange [{{<min>}:{<max>}}] {{no}reverse} {{no}writeback} {{no}extend}
                  | restore
       show xrange

 ここで <min> と <max> は定数、数式、または '*' で、'*' は自動縮尺機能
 を意味します。日時データの場合、範囲は `set timefmt` の書式に従った文
 字列を引用符で囲む必要があります。<min> や <max> を省略した場合は、現
 在の値を変更しません。自動縮尺機能に関する詳細は下に述べます。以下も参
 照: `noextend`。

 `yrange`, `zrange`, `x2range`, `y2range`, `cbrange`, `rrange`, `trange`,
 `urange`, `vrange` は同じ書式を使用します。

 x と x2 軸、あるいは y と y2 軸の範囲をリンクするオプションについては
 以下参照: `set link`。

 オプション `reverse` は、自動縮尺の軸の方向を逆にします。例えば、デー
 タ値の範囲が 10 から 100 であるとき、これは、set xrange [100:10] とし
 たのと同じように自動縮尺します。`reverse` は、自動縮尺ではない軸に対し
 ては機能しません。注意: この変更は、バージョン 4.7 で導入されました。

 自動縮尺機能: <min> (同様のことが <max> にも適用されます) がアスタリス
 ク "*" の場合は自動縮尺機能がオンになります。その場合のその値に、下限
 <lb>、または上限 <ub>、またはその両方の制限を与えられます。書式は以下
 の通りです。
       { <lb> < } * { < <ub> }
 例えば
       0 < * < 200
 は <lb> = 0, <ub> = 200 となります。そのような設定では、<min> は自動縮
 尺されますが、その最終的な値は 0 から 200 の間になります (記号は '<'
 ですが両端の値も含みます)。下限か上限を指定しない場合は、その '<' も省
 略できます。<ub> が <lb> より小さい場合は、制限はオフになり、完全な自
 動縮尺になります。
 この機能は、自動縮尺だけれども範囲に制限がある測定データの描画や、外れ
 値のクリッピング、またはデータがそれほどの範囲を必要としていなくても最
 小の描画範囲を保証するのに有用でしょう。

 オプション `writeback` は、`set xrange` で占められているバッファの中に
 自動縮尺機能により作られた範囲を保存します。これは、いくつかの関数を同
 時に表示し、しかしその範囲はそのうちのいくつかのものから決定させたい場
 合に便利です。`writeback` の作用は、`plot` の実行中に機能するので、その
 コマンドの前に指定する必要があります。最後に保存した水平方向の範囲は
 `set xrange restore` で復元できます。例を上げます。

       set xrange [-10:10]
       set yrange [] writeback
       plot sin(x)
       set yrange restore
       replot x/2

 この場合、y の範囲 (yrange) は sin(x) の値域として作られた [-1:1] の方
 になり、x/2 の値域 [-5:5] は無視されます。上記のそれぞれのコマンドの後
 に `show yrange` を実行すれば、上で何が行なわれているかを理解する助け
 になるでしょう。

 2 次元描画において、`xrange` と `yrange` は軸の範囲を決定し、`trange`
 は、媒介変数モードの媒介変数の範囲、あるいは極座標モードの角度の範囲を
 決定します。同様に 3 次元媒介変数モードでは、`xrange`, `yrange`, `zrange`
 が軸の範囲を管理し、`urange` と `yrange` が媒介変数の範囲を管理します。

 極座標モードでは、`rrange` は描画される動径の範囲を決定します。<rmin>
 は動径への追加の定数として作用し、一方 <rmax> は動径を切り捨てる (clip)
 ように作用し、<rmax> を越えた動径に対する点は描画されません。`xrange`
 と `yrange` は影響されます。これらの範囲は、グラフが r(t)-rmin のグラ
 フで、目盛りの見出しにはそれぞれ rmin を加えたようなものであるかのよう
 にセットされます。

 全ての範囲は部分的に、または全体的に自動縮尺されますが、データの描画で
 なければ、パラメータ変数の自動縮尺機能は意味がないでしょう。

 範囲は `plot` のコマンドライン上でも指定できます。コマンドライン上で与
 えられた範囲は単にその `plot` コマンドでだけ使われ、`set` コマンドで設
 定された範囲はその後の描画で、コマンドラインで範囲を指定していないもの
 全てで使われます。これは `splot` も同じです。

 例:

 x の範囲をデフォルトの値にします:
       set xrange [-10:10]

 y の範囲が下方へ増加するようにします:
       set yrange [10:-10]

 z の最小値には影響を与えずに (自動縮尺されたまま)、最大値のみ 10 に設
 定します:
       set zrange [:10]

 x の最小値は自動縮尺とし、最大値は変更しません:
       set xrange [*:]

 x の最小値を自動縮尺としますが、その最小値は 0 以上にします。
       set xrange [0<*:]

 x の範囲を自動縮尺としますが、小さくても 10 から 50 の範囲を保持します
 (実際はそれより大きくなるでしょう):
       set xrange [*<10:50<*]

 自動縮尺で最大範囲を -1000 から 1000、すなわち [-1000:1000] 内で自動縮
 尺します:
       set xrange [-1000<*:*<1000]

 x の最小値を -200 から 100 の間のどこかにします:
       set xrange [-200<*<100:]

3 軸主目盛り指定 (xtics)
?commands set xtics
?commands unset xtics
?commands show xtics
?set xtics
?unset xtics
?show xtics
?xtics
?noxtics
 x 軸の (見出しのつく) 大目盛りは コマンド `set xtics` で制御できます。
 目盛りは `unset xtics` で消え、`set xtics` で (デフォルトの状態の) 目
 盛りがつきます。y,z,x2,y2 軸の大目盛りの制御を行なう同様のコマンドがあ
 ります。

 書式:
       set xtics {axis | border} {{no}mirror}
                 {in | out} {scale {default | <major> {,<minor>}}}
                 {{no}rotate {by <ang>}} {offset <offset> | nooffset}
                 {left | right | center | autojustify}
                 {add}
                 {  autofreq
                  | <incr>
                  | <start>, <incr> {,<end>}
                  | ({"<label>"} <pos> {<level>} {,{"<label>"}...) }
                 {format "formatstring"} {font "name{,<size>}"} {{no}enhanced}
                 { numeric | timedate | geographic }
                 { rangelimited }
                 { textcolor <colorspec> }
       unset xtics
       show xtics

 同じ書式が `ytics`, `ztics`, `x2tics`, `y2tics`, `cbtics` にも適用され
 ます。

 `axis` と `border` は `gnuplot` に目盛り (目盛りの刻み自身とその見出し)
 を、それぞれ軸につけるのか、境界につけるのかを指示します。軸が境界にと
 ても近い場合、`axis` を使用すると目盛りの見出し文字を境界の外に出して
 しまうでしょう。この場合自動的なレイアウトアルゴリズムによる余白設定は
 大抵よくないものとなってしまいます。

 `mirror` は `gnuplot` に反対側の境界の同じ位置に、見出しのない目盛りを
 出力するよう指示します。`nomirror` は、あなたが想像している通りのこと
 を行ないます。

 `in` と `out` は目盛りの刻みを内側に描くか外側に描くかを切り変えます。

 目盛りの刻みのサイズは `scale` で調整できます。<minor> の指定が省略さ
 れた場合は、それは 0.5*<major> になります。デフォルトのサイズは、大目
 盛りが 1.0 で小目盛りが 0.5 で、これは `scale default` で呼びだせます。

 `rotate` は、文字列を 90 度回転させて出力させようとします。これは、文
 字列の回転をサポートしている出力ドライバ (terminal) では実行されます。
 `norotate` はこれをキャンセルします。`rotate by <ang>` は角度 <ang> の
 回転を行ないますが、これはいくつかの出力形式 (terminal) でサポートされ
 ています。

 x と y 軸の大目盛りのデフォルトは `border mirror norotate` で、x2, y2
 軸は `border nomirror norotate` がデフォルトです。z 軸には、
 `{axis | border}` オプションは無効で、デフォルトは `nomirror` です。z
 軸の目盛りをミラー化したいなら、多分 `set border` でそのための空間をあ
 ける必要があるでしょう。

 <offset> は x,y かまたは x,y,z の形式で指定しますが、それに座標系を選
 択して、その前に `first`, `second`, `graph`, `screen`, `character` の
 いずれかをつけることもできます。<offset> は刻み文字のデフォルトの位置
 からのずれを表し、デフォルトの座標系は `character` です。詳細は、以下
 参照: `coordinates`。`nooffset` はずらしを無効にします。

 例:

 xtics をより描画に近づける:
       set xtics offset 0,graph 0.05

 デフォルトでは見出しラベルは、美しい結果を生むように、軸と回転角に依存
 した位置に自動的に位置合わせされます。それが気にいらなければ、明示的に
 `left`, `right`, `center` のキーワードにより位置合わせを変更できます。
 `autojustify` でデフォルトの挙動に復帰します。

 オプションなしで `set xtics` を実行すると、目盛りが表示される状態であ
 れば、それはデフォルトの境界、または軸を復元し、そうでなければ何もしま
 せん。その前に指定した目盛りの間隔、位置 (と見出し) は保持されます。

 目盛りの位置は、デフォルト、またはオプション `autofreq` が指定されてい
 れば自動的に計算されます。そうでなければ、次の 2 つの形式で指定されま
 す:

 暗示的な <start>, <incr>, <end> 形式は、目盛りの列を <start> から <end>
 の間を <incr> の間隔で表示します。<end> を指定しなければ、それは無限大
 とみなされます。<incr> は負の値も可能です。<start> と <end> の両方が指
 定されていない場合、<start> は -∞、<end> は +∞とみなされ、目盛りは
 <incr> の整数倍の位置に表示されます。軸が対数軸の場合、目盛りの間隔
 (増分) は、倍数として使用されます。

 負の <start> や <incr> を、数値の後ろに指定すると (例えば
 `rotate by <angle>` とか `offset <offset>` の後ろ)、gnuplot の構文解析
 器は、その値からその負の <start> や <incr> の値の引き算を行おうとする
 間違いを犯します。これを回避するには、そのような場合は、`0-<start>` や
 `0-<incr>` のように指定してください。

 例:
       set xtics border offset 0,0.5 -5,1,5
 最後の ',' のところで失敗します。
       set xtics border offset 0,0.5 0-5,1,5
 か
       set xtics offset 0,0.5 border -5,1,5
 ならば、ちゃんと指示通りに、目盛りを境界に、目盛り見出し文字列を 0,0.5
 文字分だけずらして、start, increment, end をそれぞれ -5,1,5 に設定しま
 す。

 `set grid` のオプション 'front', 'back', 'layerdefault' も、x 軸の目盛
 りの描画の順序に影響します。

 例:

 目盛りを 0, 0.5, 1, 1.5, ..., 9.5, 10 の位置に生成
       set xtics 0,.5,10

 目盛りを ..., -10, -5, 0, 5, 10, ... に生成
       set xtics 5

 目盛りを 1, 100, 1e4, 1e6, 1e8 に生成
       set logscale x; set xtics 1,100,1e8

 明示的な ("<label>" <pos> <level>, ...) の形式は、任意の目盛りの位置、
 あるいは数字でない見出しの生成も可能にします。この形式では、目盛りは位
 置の数字の順に与える必要はありません。各目盛りは位置 (pos) と見出し
 (label) を持ちますが、見出しは必須ではありません。見出しは二重引用符で
 囲まれた文字列であることに注意してください。それは、"hello" のような固
 定文字列でも構いませんし、"%3f clients" のようにその位置を数字に変換す
 る書式文字列を含んでも構いませんし、空文字列 "" でも構いません。より詳
 しい情報については、以下参照: `set format`。もし、文字列が与えられなけ
 れば、デフォルトの数字の見出しが使用されます。

 明示的な形式では 3 つ目のパラメータとしてレベルを指定できます。デフォ
 ルトのレベルは 0 で、これは大目盛りを意味し、レベル 1 の場合は小目盛り
 を生成します。ラベルは、小目盛りには決して付きません。大目盛りと小目盛
 りは gnuplot が自動的に生成しますが、ユーザが明示的に指定もできます。
 レベルが 2 以上の目盛りは、ユーザが明示的に指定しなければならず、自動
 生成の目盛りよりも高い優先度を持ちます。各レベルの目盛りの刻みの大きさ
 は、`set tics scale` で制御します。

 例:
       set xtics ("low" 0, "medium" 50, "high" 100)
       set xtics (1,2,4,8,16,32,64,128,256,512,1024)
       set ytics ("bottom" 0, "" 10, "top" 20)
       set ytics ("bottom" 0, "" 10 1, "top" 20)

 2 番目の例では、全ての目盛りが見出し付けされます。3 番目の例では、端の
 ものだけが見出し付けされます。4 番目の例の、見出しのない目盛りは小目盛
 りになります。

 通常明示的な (手動の) 目盛り位置が与えられた場合、自動的に生成される目
 盛りは使われません。逆に、`set xtics auto` のようなものが指定された場
 合は、以前に手動で設定した目盛りは消されてしまします。この手動の目盛り
 と自動的な目盛りを共存させるにはキーワード `add` を使用してください。
 これは追加する目盛りのスタイルの前に書かなければいけません。

 例:
       set xtics 0,.5,10
       set xtics add ("Pi" 3.14159)

 これは自動的に目盛りの刻みを x 軸に 0.5 間隔でつけますが、πのところに
 明示的な見出しも追加します。

 しかし指定しても、表示されるのはあくまで描画範囲のものだけです。

 目盛りの見出しの書式 (または省略) は `set format` で制御されます。ただ
 しそれは `set xtics (`<label>`)` の形式の明示的な見出し文字列が含まれ
 ていない場合だけです。

 (見出し付けされない) 小目盛りは、`set mxtics` コマンドで自動的に追加す
 るか、または位置を手動で `set xtics ("" <pos> 1, ...)` の形式で与える
 こともできます。
4 xtics timedata
?set xtics timedata
?xtics timedata tics
?timedata tics
 時間と日付は内部では秒数として保持されています。

 入力: 非数値の日時値は、入力時に `timefmt` で指定した書式を用いて秒数
 に変換します。軸に対する位置や軸の範囲も `timefmt` で解釈される日時で、
 引用符で囲んで与えます。
 <start>, <incr>, <end> 形式を使う場合、<incr> は秒単位で与えなければい
 けません。入力データの解釈には `timefmt` を使ってください。軸の範囲と
 目盛りの位置は、`set xdata time` で変更されます。

 出力: 軸の目盛りラベルは、`set format` か `set xtics format` のいずれ
 かで指定された、別の書式を使って生成します。デフォルトでは、それは通常
 の数値書式指定であると認識しますが (`set xtics numeric`)、他に、地理座
 標 (`set xtics geographic`) や、日時データ (`set xtics time`) のオプシ
 ョンがあります。

 注意: 以前の版の gnuplot との互換性のため、コマンド `set xdata time`
 も暗黙に `set xtics time` を実行しますし、`set xdata` や `unset xdata`
 は暗黙に `set xtics numeric` へリセットします。しかし、これはその後に
 `set xtics` を呼び出すことで変更できます。

 例:
       set xdata time           # 入力データの解釈の制御
       set timefmt "%d/%m"      # 入力データの読み込みの書式
       set xtics timedate       # 出力書式の解釈の制御
       set xtics format "%b %d" # 目盛りラベルで使う書式
       set xrange ["01/12":"06/12"]
       set xtics "01/12", 172800, "05/12"

       set xdata time
       set timefmt "%d/%m"
       set xtics format "%b %d" time
       set xrange ["01/12":"06/12"]
       set xtics ("01/12", "" "03/12", "05/12")
 これらは両方とも "Dec 1", "Dec 3", "Dec 5", の目盛りを生成しますが、2
 番目の例 "Dec 3" の目盛りは見出し付けされません。
4 geographic
?commands set xtics geographic
?set xtics geographic
?geographic
 `set xtics geographic` は、x 軸の値が度の単位の地理座標であることを意
 味します。その軸の刻みの見出しの表現の指定には、`set xtics format` か
 `set format x` を使います。地理座標データに関する書式指定子は以下の通
 り:
        %D                   = 度の整数表示
        %<width.precision>d  = 度の浮動小数表示
        %M                   = 分の整数表示
        %<width.precision>m  = 分の浮動小数表示
        %S                   = 秒の整数表示
        %<width.precision>s  = 秒の浮動小数表示
        %E                   = +/- でなく E/W のラベル
        %N                   = +/- でなく N/S のラベル
 例えば、コマンド `set format x "%Ddeg %5.2mmin %E"` は、x 座標の -1.51
 という値を `" 1deg 30.60min W"` のように表示します。
C shige: 日本語ロケールの場合を訳注として書くべきか。
C 度の記号は set encoding locale で出るようになると。

 xtics がデフォルトの状態のまま (`set xtics numeric`) の場合は、座標は
 10 進数の度で表示し、`format` も上の特別な記号ではなく、通常の数値書式
 が使われているとみなされます。
4 xtics rangelimited
?set xtics rangelimited
?xtics rangelimited
?rangelimited
?range-frame
 このオプションは、自動的に生成される軸の目盛りの見出しと、描画されたデ
 ータで実際に与えられる範囲に対応する描画境界の両方を制限します。これは
 描画に対する現在の範囲制限とは無関係であることに注意してください。例え
 ばデータ "file.dat" のデータがすべて 2 < y < 4 の範囲にあるとすると、
 以下のコマンドは、左側の描画境界 (y 軸) は y の範囲全体 ([0:10]) のこ
 の部分 ([2:4]) のみが描画され、この範囲 ([2:4]) の軸の目盛りのみが作ら
 れる描画を生成します。つまり、描画は y の範囲全体 ([0:10]) に拡大され
 ますが、左の境界は 0 から 2 の間、4 から 10 の間は空白領域となります。
 このスタイルは、`範囲枠` グラフ (range-frame) とも呼ばれます。
       set border 3
       set yrange [0:10]
       set ytics nomirror rangelimited
       plot "file.dat"
3 xy 平面位置 (xyplane)
?commands set xyplane
?commands show xyplane
?set xyplane
?show xyplane
?xyplane
 `set xyplane` コマンドは 3D 描画で描かれる xy 平面の位置を調整するのに
 使われます。後方互換性のために、"set ticslevel" も同じ意味のコマンドと
 して使うことができます。

 書式:
       set xyplane at <zvalue>
       set xyplane relative <frac>
       set ticslevel <frac>        # set xyplane relative と同等
       show xyplane

 `set xyplane relative <frac>` は、xy 平面を Z 軸の範囲のどこに置くかを
 決定します。<frac> には、xy 平面と z の一番下の位置との差の、z 軸の範
 囲全体に対する割合を与えます。デフォルトの値は 0.5 です。負の値も許さ
 れていますが、そうすると 3 つの軸の目盛りの見出しが重なる可能性があり
 ます。非推奨ですが、古い形式 `set ticslevel` も後方互換性のために残さ
 れています。

 xy 平面を z 軸の 'pos' の位置に置くには、`ticslevel` の値を
 (pos - zmin) / (zmin - zmax) としてください。しかし、この位置は z の範
 囲 (`zrange`) を変更した場合は変わってしまいます。

 もう一つの形式である `set xyplane at <zvalue>` は、現在の z の範囲を気
 にすることなく、指定した z の値の位置に xy 平面を固定します。よって、
 x,y,z 軸を共通の原点を通るようにするには、`set xyplane at 0` とすれば
 いいことになります。

 以下も参照: `set view`, `set zeroaxis`。
3 xzeroaxis
?commands set xzeroaxis
?commands unset xzeroaxis
?commands show xzeroaxis
?set xzeroaxis
?unset xzeroaxis
?show xzeroaxis
?xzeroaxis
?noxzeroaxis
 コマンド `set xzeroaxis` は y = 0 の直線を描きます。詳細に関しては、以
 下参照: `set zeroaxis`。
3 y2data
?commands set y2data
?commands show y2data
?set y2data
?show y2data
?y2data
 コマンド `set y2data` は y2 (右) 軸のデータを時系列 (日時) 形式に設定
 します。詳細は、以下参照: `set xdata`。
3 y2dtics
?commands set y2dtics
?commands unset y2dtics
?set y2dtics
?unset y2dtics
?show y2dtics
?y2dtics
?noy2dtics
 コマンド `set y2dtics` は y2 (右) 軸の目盛りを曜日に変更します。詳細は、
 以下参照: `set xdtics`。
3 y2label
?commands set y2label
?commands show y2label
?set y2label
?show y2label
?y2label
 コマンド `set y2label` は y2 (右) 軸の見出しを設定します。詳細は、以下
 参照: `set xlabel`。
3 y2mtics
?commands set y2mtics
?commands unset y2mtics
?commands show y2mtics
?set y2mtics
?unset y2mtics
?show y2mtics
?y2mtics
?noy2mtics
 コマンド `set y2mtics` は y2 (右) 軸の目盛りを 1 年の各月に変更します。
 詳細は、以下参照: `set xmtics`。
3 y2range
?commands set y2range
?commands show y2range
?set y2range
?show y2range
?y2range
 コマンド `set y2range` は y2 (右) 軸の表示される垂直範囲を設定します。
 コマンドオプションのすべての説明については、以下参照: `set xrange`。こ
 のコマンドは、y2 軸が明示的に y 軸にリンク (link) されている場合は無視
 されます。以下参照: `set link`。
3 y2tics
?commands set y2tics
?commands unset y2tics
?commands show y2tics
?set y2tics
?unset y2tics
?show y2tics
?y2tics
?noy2tics
 コマンド `set y2tics` は y2 (右) 軸の、見出し付けされる大目盛りの制御
 を行ないます。詳細は、以下参照: `set xtics`。
3 y2zeroaxis
?commands set y2zeroaxis
?commands unset y2zeroaxis
?commands show y2zeroaxis
?set y2zeroaxis
?unset y2zeroaxis
?show y2zeroaxis
?y2zeroaxis
?noy2zeroaxis
 コマンド `set y2zeroaxis` は、原点を通る y2 (右) 軸 (x2 = 0) を描きま
 す。詳細は、以下参照: `set zeroaxis`。
3 ydata
?commands set ydata
?commands show ydata
?set ydata
?show ydata
?ydata
 コマンド `set ydata` は y 軸のデータを時系列 (日時) 形式に設定します。
 以下参照: `set xdata`。
3 ydtics
?commands set ydtics
?commands unset ydtics
?commands show ydtics
?set ydtics
?unset ydtics
?show ydtics
?ydtics
?noydtics
 コマンド `set ydtics` は y 軸の目盛りを曜日に変更します。詳細は、以下
 参照: `set xdtics`。
3 ylabel
?commands set ylabel
?commands show ylabel
?set ylabel
?show ylabel
?ylabel
 このコマンドは y 軸の見出しを設定します。以下参照: `set xlabel`。
3 ymtics
?commands set ymtics
?commands unset ymtics
?commands show ymtics
?set ymtics
?unset ymtics
?show ymtics
?ymtics
?noymtics
 コマンド `set ymtics` は、y 軸の目盛りを月に変更します。詳細は、以下参
 照: `set xmtics`。
3 yrange
?commands set yrange
?commands show yrange
?set yrange
?show yrange
?yrange
 コマンド `set yrange` は、y 方向の垂直範囲を設定します。詳細は、以下参
 照: `set xrange`。
3 ytics
?commands set ytics
?commands unset ytics
?commands show ytics
?set ytics
?unset ytics
?show ytics
?ytics
?noytics
 コマンド `set ytics` は y 軸の (見出し付けされる) 大目盛りを制御します。
 詳細は、以下参照: `set xtics`。
3 yzeroaxis
?commands set yzeroaxis
?commands unset yzeroaxis
?commands show yzeroaxis
?set yzeroaxis
?unset yzeroaxis
?show yzeroaxis
?yzeroaxis
?noyzeroaxis
 コマンド `set yzeroaxis` は x = 0 の直線 (y 軸) を書きます。詳細は、以
 下参照: `set zeroaxis`。
3 zdata
?commands set zdata
?commands show zdata
?set zdata
?show zdata
?zdata
 コマンド `set zdata` は z 軸のデータを時系列 (日時) 形式に設定します。
 以下参照: `set xdata`。
3 zdtics
?commands set zdtics
?commands unset zdtics
?commands show zdtics
?set zdtics
?unset zdtics
?show zdtics
?zdtics
?nozdtics
 コマンド `set zdtics` は z 軸の目盛りを曜日に変更します。詳細は、以下
 参照: `set xdtics`。
3 zzeroaxis
?commands set zzeroaxis
?commands unset zzeroaxis
?commands show zzeroaxis
?set zzeroaxis
?unset zzeroaxis
?show zzeroaxis
?zzeroaxis
?nozzeroaxis
 コマンド `set zzeroaxis` は (x=0,y=0) を通る直線を描きます。これは、2D
 描画、および `set view map` での splot では効力を持ちません。詳細は、
 以下参照: `set zeroaxis`, `set xyplane`。
3 cbdata
?commands set cbdata
?commands show cbdata
?set cbdata
?show cbdata
?cbdata
 このコマンドはカラーボックス軸のデータを時系列 (日時) 形式に式に設定し
 ます。以下参照: `set xdata`。
3 cbdtics
?commands set cbdtics
?commands unset cbdtics
?commands show cbdtics
?set cbdtics
?unset cbdtics
?show cbdtics
?cbdtics
?nocbdtics
 コマンド `cbdtics` はカラーボックス軸の目盛りの刻みを曜日に変換します。
 詳細は、以下参照: `set xdtics`。
3 ゼロ閾値 (zero)
?commands set zero
?commands show zero
?set zero
?show zero
?zero
 `zero` の値は、0.0 に近いデフォルトの閾値を表します。

 書式:
       set zero <expression>
       show zero

 `gnuplot` は、(複素数値を持つ点の描画においては) その値の虚数部分の絶
 対値が `zero` 閾値より大きい場合 (つまり実数でない値を持つ点) は、その
 点を描画しません。この閾値は `gnuplot` の他の様々な部分においてその
 (大まかな) 数値誤差の閾値としても使われています。デフォルトの `zero` の
 値は 1e-8 です。1e-3 (= 典型的なビットマップディスプレイの解像度の逆数)
 より大きい `zero` の値は設定すべきではないでしょうが、`zero` を 0.0 と
 設定するのは意味のないことではありません。
3 ゼロ軸 (zeroaxis)
?commands set zeroaxis
?commands unset zeroaxis
?commands show zeroaxis
?set zeroaxis
?unset zeroaxis
?show zeroaxis
?zeroaxis
 x 軸は `set xzeroaxis` によって描かれ、`unset xzeroaxis` によって削除
 されます。同様の y, x2, y2, z 軸用のコマンドが同様の働きをします。
 `set zeroaxis ...` (前置詞なし) は、x, y, z 軸すべてに機能します。

 書式:
       set {x|x2|y|y2|z}zeroaxis { {linestyle | ls <line_style>}
                                  | { linetype | lt <line_type>}
                                    { linewidth | lw <line_width>}}
       unset {x|x2|y|y2|z}zeroaxis
       show {x|y|z}zeroaxis


 デフォルトでは、これらのオプションはオフになっています。選択された 0
 の軸は <line_type> の線の型と<line_width> の線の幅 (現在使用している
 出力形式がサポートしていれば) で、あるいはあらかじめ定義された
 <line_style> のスタイルで描かれます。

 線の型を指定しなければ、軸は通常の軸の線の型 (型 0) で描かれます。

 例:

 y=0 の軸を見えるように簡単に書く場合:

        set xzeroaxis

 太い線にして、違った色、または点線パターンにしたい場合:

        set xzeroaxis linetype 3 linewidth 2.5
3 zlabel
?commands set zlabel
?commands show zlabel
?set zlabel
?show zlabel
?zlabel
 このコマンドは z 軸の見出しを設定します。以下参照: `set xlabel`。
3 zmtics
?commands set zmtics
?commands unset zmtics
?commands show zmtics
?set zmtics
?unset zmtics
?show zmtics
?zmtics
?nozmtics
 コマンド `set zmtics` は z 軸の目盛りを月に変更します。詳細は、以下参
 照: `set xmtics`。
3 zrange
?commands set zrange
?commands show zrange
?set zrange
?show zrange
?zrange
 コマンド `set zrange` は z 軸方向に表示される範囲を設定します。このコ
 マンドは `splot` にのみ有効で、`plot` では無視されます。詳細は、以下参
 照: `set xrange`。
3 ztics
?commands set ztics
?commands unset ztics
?commands show ztics
?set ztics
?unset ztics
?show ztics
?ztics
?noztics
 コマンド `set ztics` は z 軸の (見出し付けされる) 大目盛りを制御します。
 詳細は、以下参照: `set xtics`。
3 cblabel
?commands set cblabel
?commands show cblabel
?set cblabel
?show cblabel
?cblabel
 このコマンドはカラーボックス軸の見出しを設定します。以下参照:
 `set xlabel`。
3 cbmtics
?commands set cbmtics
?commands unset cbmtics
?commands show cbmtics
?set cbmtics
?unset cbmtics
?show cbmtics
?cbmtics
?nocbmtics
 コマンド `set cbmtics` はカラーボックス軸の目盛りの見出しを月に変換し
 ます。詳細は、以下参照: `set xmtics`。
3 cbrange
?commands set cbrange
?commands show cbrange
?set cbrange
?show cbrange
?cbrange
 コマンド `set cbrange` は、スタイル `with pm3d`, `with image` や
 `with palette` などによって現在のパレット (`palette`) を使って色付けさ
 れる値の範囲を設定します。その範囲外の値に対しては、最も近い限界の値の
 色が使用されます。

 カラーボックス軸 (cb-軸) が `splot` で自動縮尺されている場合は、その
 カラーボックスの範囲は `zrange` が使われます。`splot ... pm3d|palette`
 で描画される点は、異なる `zrange` と `cbrange` を使うことでフィルタリ
 ングできます。

 `set cbrange` の書式に関する詳細は、以下参照: `set xrange`。以下も参照:
 `set palette`, `set colorbox`。
3 cbtics
?commands set cbtics
?commands unset cbtics
?commands show cbtics
?set cbtics
?unset cbtics
?show cbtics
?cbtics
?nocbtics
 コマンド `set cbtics` はカラーボックス軸の (見出し付けされる) 大目盛り
 を制御します。詳細は、以下参照: `set xtics`。
2 シェルコマンド (shell)
?commands shell
?shell
 `shell` コマンドは対話的なシェルを起動します。`gnuplot` に戻るには、
 VMS では `logout` を、Unix ならば `exit` もしくは END-OF-FILE 文字を、
 MS-DOS か OS/2 ならば `exit` を入力して下さい。

 シェルコマンドを実行する方法は 2 つあります: コマンド `system` を使う
 か `!` (VMS では $) を使うか。前者は、コマンド文字列をパラメータとして
 取るので、他の gnuplot コマンドのどこでも使うことができますが、後者の
 書式は、その行にそのコマンドただ一つであることを要求します。これらの場
 合コマンドが終了するとすぐに制御は `gnuplot` に戻ってきます。例えば
 MS-DOS, OS/2 では、

      ! dir
 または
      system "dir"

 とするとディレクトリの一覧を表示して `gnuplot` に戻ってきます。

 `system` を使う他の例:
        system "date"; set time; plot "a.dat"
        print=1; if (print) replot; set out; system "lpr x.ps"
2 splot
?commands splot
?splot
 `splot` は 3 次元描画のためのコマンドです (もちろんご存知でしょうが、
 実際にはその 2 次元への射影)。それは、`plot` コマンドの 3 次元版です。
 `splot` は、それぞれ単一の x, y, z 軸を提供するだけで、`plot` で用意さ
 れている第 2 軸 x2, y2 のようなものはありません。

 2 次元と 3 次元描画の両方で使える多くのオプションについては、以下参照:
 `plot`。

 書式:
       splot {<ranges>}
             {<iteration>}
             <function> | {{<file name> | <data block name>}
                           {datafile-modifiers}}
             {<title-spec>} {with <style>}
             {, {definitions{,}} <function> ...}

 コマンド `splot` は、関数から生成されたデータ、またはデータファイルか
 ら読み込んだデータ、または事前に保存された名前付きデータブロックのデー
 タを処理します。データファイル名は、通常引用符で囲んだ文字列として与え
 ます。関数は 1 本の数式ですが、媒介変数モード (parametric) では 3 つの
 数式の組として与えます。

 デフォルトでは、`splot` は描画されるデータの下に完全な xy 面を描きます。
 z の一番下の目盛りと xy 平面の位置関係は `set xyplane` で変更できます。
 `splot` の射影の向きは `set view` で制御できます。詳細は、以下参照:
 `set view`, `set xyplane`。

 `splot` コマンドの範囲の指定の書式は `plot` の場合と同じです。媒介変数
 モード (parametric) でなければ、範囲指定は以下の順で、
       splot [<xrange>][<yrange>][<zrange>] ...
 媒介変数モード (parametric) では、範囲指定は以下の順で与えなければいけ
 ません:
       splot [<urange>][<vrange>][<xrange>][<yrange>][<zrange>] ...

 `title` オプションも `plot` と同じです。`with` も `plot` とほぼ同じで
 すが、2 次元の描画スタイル全部が使えるわけではありません。

 `datafile` オプションにはさらに違いがあります。

 媒介変数モード (parametric) や関数を利用して曲面を描く別の方法に、疑似
 ファイル '++' を利用して xy 平面の格子の上に標本点を生成するやり方があ
 ります。

 以下も参照: `show plot`, `set view map`, `sampling`。
3 データファイル (datafile)
?commands splot datafile
?splot datafile
 `plot` と同じように、`splot` でファイルからグラフを生成できます。

 書式:
       splot '<file_name>' {binary <binary list>}
                           {{nonuniform} matrix}
                           {index <index list>}
                           {every <every list>}
                           {using <using list>}

 `""` や `"-"` といった特別なファイル名も `plot` と同様に許されます。以
 下参照: `special-filenames`。

 手短にいうと、`binary` や `matrix` はそのデータが特別な形であることを、
 `index` は多重データ集合ファイルからどのデータ集合を選んで描画するかを、
 `every` は各データ集合からどのデータ行 (部分集合) を選んで描画するかを、
 `using` は各データ行からどのように列を選ぶかを指定します。

 `index` と `every` オプションは `plot` の場合と同じように振舞います。
 `using` も、`using` のリストが 2 つでなく 3 つ必要であるということを
 除いては同様です。

 `plot` のオプションである `smooth` は `splot` では利用できません。しか
 し、`cntrparam` や `dgrid3d` が、制限されてはいますが平滑化のために用
 意されています。

 データファイルの形式は、各点が (x,y,z) の 3 つ組である以外は、本質的に
 `plot` と同じです。もし一つの値だけが与えられれば、それは z として使われ、
 データブロック番号が y として、そして x はそのデータブロック内での番号が
 使われます。もし 2 つ、あるいは 4 つの値が与えられれば、`gnuplot` はその
 最後の値を pm3d plot での色の計算に使います。3 つの値は (x,y,z) の組と見
 なされます。他に値があれば、それは一般に誤差と見なされます。それは `fit`
 で使うことが可能です。

 `splot` のデータファイルでは、1 行の空行はデータブロックの分離子です。
 `splot` は個々のデータブロックを、関数の y-孤立線と同じものとして扱い
 ます。1 行の空行で分離されている点同士は線分で結ばれることはありません。
 全てのデータブロックが全く同じ点の数を持つ場合、`gnuplot` はデータ
 ブロックを横断し、対応する点同士を結ぶ孤立線を描きます。これは "grid
 data" と呼ばれ、曲面の描画、等高線の描画 (`set contour`)、隠線処理
 (`set hidden3d`) では、この形のデータであることが必要となります。以下
 も参照: `splot grid_data`。

 3 列の `splot` データにおいては、媒介変数モード (`parametric`) を指定
 することはもはや不要です。
4 matrix
?commands plot datafile matrix
?commands splot datafile matrix
?plot datafile matrix
?splot datafile matrix
?binary matrix
?matrix
 gnuplot は、matrix (配列) 形式のデータ入力を、2 つの異なる形式で解釈す
 ることができます。

 その 1 つは、x, y の座標が一様であると仮定して、その値をこの一様な格子
 の matrix のそれぞれの要素 M[i,j] に割り当てる方法です。
 割り当てられる x 座標は [0:NCOLS-1] の範囲の整数です。
 割り当てられる y 座標は [0:NROWS-1] の範囲の整数です。
 これは、テキストデータに対してはデフォルトですが、バイナリデータに対し
 てはそうではありません。
 例や追加キーワードについては以下参照: `matrix uniform`。

 2 つ目の形式は、非一様な格子で、x, y 座標は明示していると仮定するもの
 で、入力データの最初の行を y 座標、最初の列を x 座標とみなします。
 バイナリデータに対しては、1 行目の最初の要素は、列数でなければいけませ
 ん。これは、`binary matrix` 入力ではデフォルトですが、テキスト入力デー
 タに対しては追加キーワード `nonuniform` が必要になります。
 例に関しては以下参照: `matrix nonuniform`。

5 uniform
?commands plot datafile matrix uniform
?commands splot datafile matrix uniform
?datafile matrix uniform
?matrix uniform
?binary matrix uniform
 一様な matrix データを描画するコマンドの例:
      splot 'file' matrix using 1:2:3          # テキストデータ
      splot 'file' binary general using 1:2:3  # バイナリデータ

 一様な格子の matrix データでは、各ブロックの z の値は一行で一度に読ま
 れます。すなわち、
     z11 z12 z13 z14 ...
     z21 z22 z23 z24 ...
     z31 z32 z33 z34 ...
 等。

 テキストデータに対しては、1 行目がデータでなく列ラベルを持つ場合、追加
 キーワード `columnheaders` を使ってください。同様に、各行の最初の要素
 がデータでなくラベルである場合は、追加キーワード `rowheaders` を使用し
 てください。以下は、その両方を使用する例です:
     $DATA << EOD
     xxx A   B   C   D
     aa  z11 z12 z13 z14
     bb  z21 z22 z23 z24
     cc  z31 z32 z33 z34
     EOD
     plot $DATA matrix columnheaders rowheaders with image

 テキストデータでは、空行やコメント行は配列データを終了させ、新たな曲面
 の網 (mesh) を開始します。いつものことですが、`splot` コマンドの
 `index` オプションを使ってファイル内の網を自由に選択できます。
5 nonuniform
?commands plot datafile matrix nonuniform
?commands splot datafile matrix nonuniform
?datafile matrix nonuniform
?matrix nonuniform
?binary matrix nonuniform
 入力データの最初の行は y 座標を持ちます。
 入力データの最初の列は x 座標を持ちます。
 バイナリ入力データでは、1 行目の最初の要素は列数でなければいけません
 (テキストデータではその番号は無視されます)。

 非一様な matrix データを描画するコマンドの例:
      splot 'file' nonuniform matrix using 1:2:3  # テキストデータ
      splot 'file' binary matrix using 1:2:3      # バイナリデータ

 よって、非一様な matrix データの構造は以下のようになります:

       <N+1>  <x0>   <x1>   <x2>  ...  <xN>
        <y0> <z0,0> <z0,1> <z0,2> ... <z0,N>
        <y1> <z1,0> <z1,1> <z1,2> ... <z1,N>
         :      :      :      :   ...    :

 これらは以下のような 3 つの数字の組に変換されます:

       <x0> <y0> <z0,0>
       <x0> <y1> <z0,1>
       <x0> <y2> <z0,2>
        :    :     :
       <x0> <yN> <z0,N>

       <x1> <y0> <z1,0>
       <x1> <y1> <z1,1>
        :    :     :

 そして、これらの 3 つの数字の組は `gnuplot` の孤立線に変換され、その後
 `gnuplot` が通常の方法で描画の残りを行います。
5 examples
?commands plot datafile matrix examples
?commands splot datafile matrix examples
?datafile matrix examples
?matrix examples
?binary matrix examples
 行列やベクトルの操作のサブルーチン (C による) が `binary.c` に用意され
 ています。バイナリデータを書くルーチンは

       int fwrite_matrix(file,m,nrl,nrl,ncl,nch,row_title,column_title)

 です。これらのサブルーチンを使う例が `bf_test.c` として用意されていて、
 これはデモファイル `demo/binary.dem` 用に複数のバイナリファイルを生成
 します。

 `plot` での使用法:
     plot `a.dat` matrix
     plot `a.dat` matrix using 1:3
     plot 'a.gpbin' {matrix} binary using 1:3
 これらは配列の行を描画し、using 2:3 とすれば配列の列を描画、using 1:2
 は、点の座標を描画します (多分無意味です)。オプション `every` を適用す
 ることで明示的に行や列を指定できます。

 例 -- テキストデータファイルの配列の軸の拡大:
     splot `a.dat` matrix using (1+$1):(1+$2*10):3

 例 -- テキストデータファイルの配列の第 3 行の描画:
     plot 'a.dat' matrix using 1:3 every 1:999:1:2
 (行は 0 から数えられるので、3 ではなくて 2 を指定します)。

 Gnuplot は、`array`, `record`, `format`, `filetype` などの general バ
 イナリ形式を特定するようなキーワードをつけずにオプション `binary` を使
 うことで、matrix バイナリファイルを読み込むことができます。その他の変換
 用の general バイナリキーワードは、matrix バイナリファイルにも適用でき
 るでしょう。(詳細は、以下参照: `binary general`。)
4 データファイルの例
?commands splot datafile example
?splot datafile example
?splot example
 以下は3 次元データファイルの描画の単純な一つの例です。

       splot 'datafile.dat'

 ここで、"datafile.dat" は以下を含むとします:

       # The valley of the Gnu.
          0 0 10
          0 1 10
          0 2 10

          1 0 10
          1 1 5
          1 2 10

          2 0 10
          2 1 1
          2 2 10

          3 0 10
          3 1 0
          3 2 10

 この "datafile.dat" は 4*3 の格子 (それぞれ 3 点からなるブロックの
 4 つの行) を定義することに注意して下さい。行 (データブロック) は 1 行の
 空行で区切られます。

 x の値はそれぞれのデータブロックの中で定数になっていることに注意して下
 さい。もし y を定数の値とし、隠線処理が有効な状態で描画すると、その曲面は
 裏返しで書かれることになります。

 格子状データ (grid data) に対して、個々のデータブロック内で x の値を定
 数としておく必要はありませんし、同じ場所の y の値を同じ値に揃えておく
 必要もありません。`gnuplot` は個々のデータブロック内の点の数が等しいと
 いうことを必要としているだけです。しかし、等高線を導くのに用いられる曲
 面の網目は、対応する点を列的に選んで結ぶため、不揃いの格子データに対す
 る曲面の描画への影響は予想できません。それはケースバイケースの原理でテ
 ストすべきでしょう。
3 格子状データ (grid data)
?commands splot grid_data
?splot grid_data
?grid_data
 3 次元描画のためのルーチンは、個々の網目の格子においては一つの標本点と
 一つのデータ点がある、という形の格子状データ用に設計されています。各デ
 ータ点は、関数の値を評価すること (以下参照: `set isosamples`)、または
 データファイルを読み込むこと (以下参照: `splot datafile`) によって生成
 されます。"孤立線" という言葉は関数に対しても、データに対してもその網
 目の線を表すものとして用いられます。網目は、必ずしも x, y に関する長方
 形でなくてもよく、u,v で媒介変数表示されても構わないことに注意して下さ
 い。以下参照: `set isosamples`。

 しかし、`gnuplot` はそのような形式を必ずしも必要とはしません。例えば
 関数の場合は、`samples` は `isosamples` と違っていても構いません。
 すなわち、x-孤立線のうち、1 本の y-孤立線と交わないものがいくつかある
 ことがあります。データファイルの場合は、個々のデータブロックのばらつい
 た点の個数が全て同じであれば、"孤立線は" はデータブロックの点を結び、
 "横断孤立線" は各データブロックの対応する点同士を結び、"曲面" を作ろう
 とします。どちらの場合でも、等高線、および隠線処理モードは点が意図した
 フォーマットであった場合とは違った描画を与えることになります。ばらつき
 のあるデータは `set dgrid3d` によって{異なる}格子状データに変換すること
 ができます。

 等高線に関するコードは、y-孤立線の点と、それに対応する隣の y-孤立線上
 の点の間の線分に沿っての z の張力を計測します。よって、x-孤立線に、
 y-孤立線との交点とはならないような標本点があるような曲面に対しては、
 `splot` の等高線はそのような標本点を無視することになります。以下を試して
 みて下さい:
        set xrange [-pi/2:pi/2]; set yrange [-pi/2:pi/2]
        set style function lp
        set contour
        set isosamples 10,10; set samples 10,10;
        splot cos(x)*cos(y)
        set samples 4,10; replot
        set samples 10,4; replot

3 splot の曲面 (splot surfaces)
?commands splot surfaces
?splot surfaces
 `splot` は点の集まりとして、あるいは、それらの点を結ぶことによって曲面
 を表示することができます。`plot` と同様に、点はデータファイルから読む
 こともできますし、指定された区間で関数の値を評価して得ることもできます。
 以下参照: `set isosamples`。曲面は、各点を線分で結ぶことで近似的に作ら
 れます。以下参照: `set surface`。そしてその場合曲面は、`set hidden3d`
 で不透明にもできます。3 次元曲面を眺める向きは、`set view` で変更でき
 ます。

 さらに、格子状のデータ点に対しては、`splot` は同じ高さを持つ点を補間す
 ることができ (以下参照: `set contour`)、そしてそれらを結んで等高線を描
 くことができます。さらに、その結び方には真直な線分や滑らかな線を使うこ
 とができます (以下参照: `set cntrparam`)。関数は、常に `set isosamples`
 と `set samples` で決定される格子状データとして評価されます。一方、フ
 ァイルのデータは、`data-file` に書かれているような格子状データフォーマ
 ットにするか、あるいは格子データを生成する (以下参照: `set dgrid3d`)
 ということをしなければそうはなりません。

 等高線は曲面の上に表示することもできますし、底面に射影することもできま
 す。底面への射影は、ファイルに書き出すこともでき、そしてそれを `plot`
 で再び読み込んで `plot` のより強い整形能力を生かすこともできます。
2 stats (簡単な統計情報)
?commands stats
?stats
?statistics
 書式:
      stats {<ranges>} 'filename' {matrix | using N{:M}} {name 'prefix'}
            {{no}output}

 このコマンドは、ファイルの 1 列、または 2 列のデータの簡単な統計情報を
 提供します。using 指定子は、plot コマンドと同じ形で解釈されますが、
 `index`, `every`, `using` 指定に関する詳細については以下参照: `plot`。
 データ点は、その解析の前に xrange, yrange に従ってフィルタにかけられま
 す。以下参照: `set xrange`。その情報はデフォルトではスクリーンに出力さ
 れますが、コマンド `set print` を先に使うことで出力をファイルにリダイ
 レクトしたり、オプション `nooutput` を使うことで出力しないようにするこ
 ともできます。

 画面出力に加え、gnuplot は個々の統計情報を 3 つの変数グループに保存し
 ます。
 1 番目の変数グループは、どんなデータが並んでいるかを示します:
@start table
      STATS_records           # 範囲内のデータ行の総数 (N)
      STATS_outofrange        # 範囲外として除かれた行数
      STATS_invalid           # 無効/不完全/欠損データ行の総数
      STATS_blank             # 空行の総数
      STATS_blocks            # ファイル内の index データブロック数
      STATS_columns           # データ先頭行の列数
#\begin{tabular}{|lcl|} \hline
#\verb@STATS_records@    & $~~N~~$ &  範囲内のデータ行の総数 \\
#\verb@STATS_outofrange@ & $~~~~~$  &  範囲外として除かれた行数 \\
#\verb@STATS_invalid@    & $~~~~~$  &  無効/不完全/欠損データ行の総数 \\
#\verb@STATS_blank@      & $~~~~~$  &  空行の総数 \\
#\verb@STATS_blocks@     & $~~~~~$  &  ファイル内の index データブロック数 \\
#\verb@STATS_columns@    & $~~~~~$  &  データ先頭行の列数 \\
@end table

 2 番目の変数グループは、1 つの列の、範囲内のデータの性質を示します。こ
 の列は y の値として扱われます。y 軸が自動縮尺の場合は、対象とする範囲
 に限界はありませんが、そうでなければ範囲 [ymin:ymax] 内の値のみを対象
 とします。

 2 つの列を同時に 1 回の `stats` コマンドで解析する場合は、各変数名に
 "_x", "_y" という接尾辞を追加します。例えば STATS_min_x は、1 つ目の列
 のデータの最小値で、STATS_min_y は 2 つ目の列のデータの最小値を意味し
 ます。この場合、点は xrange と yrange の両方で検査することでふるいにか
 けます。

@start table
      STATS_min               # 範囲内のデータ点の最小値
      STATS_max               # 範囲内のデータ点の最大値
      STATS_index_min         # data[i] == STATS_min となる添字 i
      STATS_index_max         # data[i] == STATS_max となる添字 i
      STATS_lo_quartile       # 第一 (下の) 四分位境界値
      STATS_median            # メジアン値 (第二四分位境界値)
      STATS_up_quartile       # 第三 (上の) 四分位境界値
      STATS_mean              # 範囲内のデータ点の平均値
      STATS_ssd               # 範囲内のデータ点の不偏標準偏差
                                   = sqrt( Sum[(y-ymean)^2] / (N-1) )
      STATS_stddev            # 範囲内のデータ点の標本標準偏差
                                   = sqrt( Sum[(y-ymean)^2] / N )
      STATS_sum               # 和
      STATS_sumsq             # 平方和
      STATS_skewness          # 範囲内のデータ点の歪度
      STATS_kurtosis          # 範囲内のデータ点の尖度
      STATS_adev              # 範囲内のデータ点の平均絶対偏差
      STATS_mean_err          # 平均値の標準誤差
      STATS_stddev_err        # 標準偏差の標準誤差
      STATS_skewness_err      # 歪度の標準誤差
      STATS_kurtosis_err      # 尖度の標準誤差
#\begin{tabular}{|lrll|} \hline
#\verb@STATS_min@ && $min(y)$ &  範囲内のデータ点の最小値 \\
#\verb@STATS_max@ && $max(y)$ &  範囲内のデータ点の最大値 \\
#\verb@STATS_index_min@ && $i \mid y_i = min(y)$ &  data[i] == STATS\_min となる添字 i \\
#\verb@STATS_index_max@ && $i \mid y_i = max(y)$ &  data[i] == STATS\_max となる添字 i \\
#\verb@STATS_mean@ & $\bar{y}=$ & $\frac{1}{N}\sum{y}$ &  範囲内のデータ点の平均値 \\
#\verb@STATS_stddev@ & $\sigma_y=$ & $\sqrt{\frac{1}{N}{\sum{{(y-\bar{y})}^2}}}$ &  範囲内のデータ点の標本標準偏差 \\
#\verb@STATS_ssd@ & $s_y=$ & $\sqrt{\frac{1}{N-1}{\sum{{(y-\bar{y})}^2}}}$ &  範囲内のデータ点の不偏標準偏差 \\
#\verb@STATS_lo_quartile@ && ~ &  第一 (下の) 四分位境界値 \\
#\verb@STATS_median@ && ~ &  メジアン値 (第二四分位境界値) \\
#\verb@STATS_up_quartile@ && ~ &  第三 (上の) 四分位境界値 \\
#\verb@STATS_sum@ && $\sum{y}$ &  和 \\
#\verb@STATS_sumsq@ && $\sum{y^2}$ &  平方和 \\
#\verb@STATS_skewness@ && $\frac{1}{N\sigma^3}\sum{(y-\bar{y})^3}$ &  範囲内のデータ点の歪度 \\
#\verb@STATS_kurtosis@ && $\frac{1}{N\sigma^4}\sum{(y-\bar{y})^4}$ &  範囲内のデータ点の尖度 \\
#\verb@STATS_adev@ && $\frac{1}{N}\sum{|{y}-\bar{y}|}$ &  範囲内のデータ点の平均絶対偏差 \\
#\verb@STATS_mean_err@ && $\sigma_y / \sqrt{N}$ &  平均値の標準誤差 \\
#\verb@STATS_stddev_err@ && $\sigma_y / \sqrt{2N}$ &  標準偏差の標準誤差 \\
#\verb@STATS_skewness_err@ && $\sqrt{6/N}$ &  歪度の標準誤差 \\
#\verb@STATS_kurtosis_err@ && $\sqrt{24/N}$ &  尖度の標準誤差 \\
@end table

 3 番目の変数グループは、2 つの列のデータの解析専用です。
@start table
      STATS_correlation       # x と y の不偏相関係数
      STATS_slope             # 回帰直線 y = Ax + B の係数 A
      STATS_slope_err         # A の不確かさ
      STATS_intercept         # 回帰直線 y = Ax + B の係数 B
      STATS_intercept_err     # B の不確かさ
      STATS_sumxy             # 積和 (x*y の和)
      STATS_pos_min_y         # y の最小値を与える x 座標
      STATS_pos_max_y         # y の最大値を与える x 座標
#\begin{tabular}{|lll|} \hline
#\verb@STATS_correlation@ &   &  x と y の不偏相関係数 \\
#\verb@STATS_slope@       &   &  回帰直線 y = Ax + B の係数 A \\
#\verb@STATS_slope_err@   &   &  A の不確かさ \\
#\verb@STATS_intercept@   &   &  回帰直線 y = Ax + B の係数 B \\
#\verb@STATS_intercept_err@ &   &  B の不確かさ \\
#\verb@STATS_sumxy@       &   &  積和 (x*y の和) \\
#\verb@STATS_pos_min_y@   &   &  y の最小値を与える x 座標 \\
#\verb@STATS_pos_max_y@   &   &  y の最大値を与える x 座標 \\
@end table

 `matrix` が指定されていれば、`using` オプションは無視され、"z" 値のみ
 が 1 次元のデータ集合として取り扱われます。その行列のサイズは、変数
 STATS_size_x と STATS_size_y に保存します。

 同時に 2 つ以上のファイルからの統計情報を使うことができれば便利でしょ
 うから、変数のデフォルトの接頭辞である "STATS" をオプション `name` で
 ユーザが指定する文字列に置き換えることができるようになっています。例え
 ば、異なる 2 つのファイルのそれぞれの 2 列目のデータの平均値は以下のよ
 うにして比較できます:
      stats "file1.dat" using 2 name "A"
      stats "file2.dat" using 2 name "B"
      if (A_mean < B_mean) {...}

 STATS_index_xxx で示される添字の値は、plot コマンドの第 0 疑似列 ($0)
 の値に対応し、最初の点は添字は 0、最後の点の添字は N-1 となります。

 メジアンと四分位境界値を探す際はデータの値をソートし、点の総数 N が奇
 数の場合は、その (N+1)/2 番目の値をメジアン値とし、N が偶数の場合は、
 N/2 番目と (N+2)/2 番目の値の平均値をメジアン値とします。四分位境界値
 も同様に処理します。

 その後の描画に注釈をつけるためにコマンド `stats` を利用した例について
 は、以下を参照してください。
^ <a href="http://www.gnuplot.info/demo/stats.html">
 stats.dem。
^ </a>

 現在の実装では、X 軸と Y 軸の一方が対数軸の場合は解析できません。この
 制限は今後のバージョンでは解消されるでしょう。

2 system
?commands system
?system
 `system "command"` は、標準的なシェルを使って "command" を実行します。
 以下参照: `shell`。関数として呼ばれた場合、`system("command")` は結果
 として標準出力に流れる文字列を文字列値として返します。一つ追加される改
 行文字は無視されます。

 これは、gnuplot スクリプト内に外部関数を取り込むのに使えます:

       f(x) = real(system(sprintf("somecommand %f", x)))
2 test
?commands test
?test palette
?test
 このコマンドは、出力形式やパレットでどのような出力が行なえるかを画像で
 テストし表示します。

 書式:
       test {terminal | palette}

 `test` または `test terminal` は、現在使用中の出力形式 (`terminal`) で
 使える線の種類、点の種類、または利用可能なその他の描画を生成します。

 `test palette` は、R(z),G(z),B(z) (0<=z<=1) の状態を描画します。これら
 は現在のカラーパレット (`palette`) の RGB 成分を示します。また、RGB を
 灰色階調に写像する NTSC 係数を用いて計算された視光度も描画します。この
 対応関係は、$PALETTE という名前のデータブロックにも取り込まれます。
2 undefine
?commands undefine
?undefine
 1 つ、または複数の定義済みのユーザ変数を削除します。これは、初期化テス
 トを含むようなスクリプトの状態をリセットするのに便利でしょう。

 変数名には、最後の文字としてワイルドカード文字 `*` を使うことができま
 す。ワイルドカード文字が見つかると、それより前の部分で始まるすべての変
 数を削除します。これは、共通の接頭語を使っている複数の変数を削除するの
 に便利でしょう。ただし、ワイルドカード文字は変数名の最後にしか使えない
 ことに注意してください。`undefine` にワイルドカード文字のみを引数とし
 て与えた場合は何もしません。

 例:

       undefine foo foo1 foo2
       if (!exists("foo")) load "initialize.gp"

       bar = 1; bar1 = 2; bar2 = 3
       undefine bar*                 # 3 つの変数を全部削除

2 unset
?commands unset
?unset
=iteration
 コマンド `set` で設定したオプションは、それに対応した `unset` コマンド
 によってそのデフォルトの値に戻すことが可能です。`unset` コマンドには繰
 り返し節も利用できます。以下参照: `plot for`。

 例:
       set xtics mirror rotate by -45 0,10,100
       ...
       unset xtics

       # 番号 100 から 200 までのラベルを unset
       unset for [i=100:200] label i
3 linetype
?unset linetype
 書式:
       unset linetype N
 以前に単一の線種に割り当てたすべての特性を削除します。この後にこの線種
 を使用した場合、特性、色は現在の出力形式にデフォルトで設定されているも
 のを使用します (すなわち gnuplot 4.6 より前のバージョンで有効だった、
 いわゆるデフォルトの線種)。
3 output
?unset output
 複数のグラフを一つの出力ファイルに書き出すことができる出力形式もあるの
 で、描画の後で出力ファイルを自動的には閉じません。よってそのファイルを
 安全に印刷等をするためには、まず明示的に `unset out` や `set output`
 とすることで前のファイルを閉じた上で新しいファイルを開いてください。
3 terminal
?unset terminal
 プログラムの最初に有効になるデフォルトの出力形式は、個々のシステム環境、
 gnuplot のコンパイルオプション、および環境変数 GNUTERM に依存します。
 このデフォルトが何であっても、gnuplot はそれを内部変数 GNUTERM に保存
 していますが、コマンド `unset terminal` は、この初期値を復帰します。こ
 れは、`set terminal GNUTERM` とすることと同じです。
2 update
?commands update
?update
 このコマンドは、与えられたファイルに保存されている変数を現在の値に更新
 しますが、これらは (`fit` の項で説明されている) 初期値のファイルと同じ
 書式である必要があります。

 その名前のファイルが存在しない場合、現在定義されているすべてのユーザ変
 数を含む新しいファイルを作成しますが、最後の fit 内で使用しなかった変
 数にはすべて "#FIXED" と印をつけています。これは、fit 変数の現在の値を
 後で使うために、あるいは終了/中断した当てはめを再実行するために保存し
 ておくのに有用です。

 書式:
       update <filename> {<filename>}

 2 番目のファイル名を指定すると、元のパラメータファイルは変更せずに 2
 番目のファイルの方に更新された値を書き出します。

 そうでなければ、指定したファイルが存在すれば `gnuplot` はそのファイル
 名に `.old` をつけてファイル名を変更し、指定したファイル名のファイルを
 新たに開き直します。つまり、"`update 'fred'`" とすると、それは
 "`!rename fred fred.old; update 'fred.old' 'fred'`" としたことと同じこ
 とになります。ファイルが既に存在するために名前の変更ができない場合は、
 update はエラーメッセージを出力して失敗します。[VMS では、ファイルのバ
 ージョン管理システムが使われるため、名前の変更は行なわれません。]

 より詳しい情報に関しては、以下参照: `fit`。
2 While
?while
?commands while
 書式:
       while (<expr>) {
           <commands>
       }
 これは、コマンドのブロックを、<expr> が 0 でない値と評価される間、繰り
 返し実行します。このコマンドは、古い形式 (かっこなし) の if/else 構文
 と一緒に使うことはできません。以下参照: `if`。
1 出力形式 (Terminal)
^ <h2> Terminal Types </h2>
2 出力形式の一覧
?complete list of terminals
?terminal
?term
 gnuplot はとても多くの出力形式をサポートしています。これらは、適切な
 出力形式を、必要なら機能を変更する追加オプションをつけて選択すること
 により設定されます。以下参照: `set terminal`。

 この文書は、あなたのシステム上で初期設定およびインストールがなされなか
 ったために利用できない出力形式についても記述されているかも知れません。
 インストールされた個々の gnuplot で、どの出力形式が有効なのかの一覧を
 見るには、オプションを何もつけずに 'set terminal' と打ってください。

 (訳注: この日本語訳に含まれる terminal のマニュアルは、その一覧にはな
 い出力形式のものも含まれているかもしれませんし、逆にその一覧内の出力形
 式でマニュアルがないものもあるかもしれません。)
<3 -- 全ての出力ドライバの項目は、.trm ファイルから引っ張って来られます。
1 バグ (Bugs)
?bugs
 バグリポートは e-mail で gnuplot-bugs メーリングリストへ送るか、または
 SourceForge の gnuplot ウェブサイトにその報告を投稿してください。その
 際、あなたが使用している gnuplot のバージョンの完全な情報、そして可能
 ならばそのバグを実証するテストスクリプトを送ってください。以下参照:
 `seeking-assistance`。

2 知られている制限 (limitations)
 `do` や `while` ループの中括弧内でインラインデータ (例: plot '-' ...)
 を使うことはできません。

=gamma
=bessel
=timefmt
=nohidden3d
=floating point exceptions
 浮動小数計算例外 (浮動小数値が大きすぎる (または小さすぎる) 場合、0 で
 割算した場合など) は、ユーザ定義関数において発生することがあります。特
 に、いくつかのデモで、浮動小数の範囲を越える数値を生成することが起こる
 ようです。システムがそのような例外を無視する (`gnuplot` はそのような点
 を定義できないもの、と見なします) か、または `gnuplot` の実行を中止す
 るかは、コンパイル時 (あるいは実行時) の環境によります。

 ガンマ関数とベッセル関数は複素数引数をサポートしていません。

 "時刻" として指定された座標は 24 時で折り返します。

 媒介変数の曲線: `nohidden3d` は、全体的な設定である `set hidden3d` を
 個々のグラフに対して免除するためのオプションですが、これは媒介変数の曲
 線 (parametric) に対しては機能しません。
 コマンド `plot` 内の繰り返し (iteration) は、媒介変数の曲線に対しては
 機能しません。

 X11 出力形式: UTF-8 フォントの選択が困難です。
 すべての x11 描画ウィンドウに対して、一度には 1 つのカラーパレットのみ
 が有効です。これは、異なるパレットを使用する描画を含んだ multiplot で
 は x11 上では正しく表示されないことを意味します。

 Qt 出力形式: 3 次元での多角形や曲面の回転はかなり遅くなる可能性があり
 ますが、これは Qt のレンダリングモード (Qt の説明書を参照してください)
 に強く依存します。

2 外部ライブラリ (External libraries)
?bugs external_libraries
=libgd
=svgalib
=locale
=internationalization
=pdf
 外部ライブラリ GD (PNG/JPEG/GIF ドライバで使用):
 バージョン 2.0.33 までの libgd には、Adobe の Symbol フォントの文字の
 マッピングに関するいくつかのバグがあります。また、アンチエイリアスされ
 た線分がキャンバスの上の角と交わる場合に、ライブラリがセグメンテーショ
 ンフォルトを引き起すこともあります。

 外部ライブラリ PDFlib (PDF ドライバで使用):
 gnuplot は libpdf のバージョン 4, 5, 6 のいずれかをリンクできます。し
 かし、これらはバージョンによってパイプされた入出力の処理が違っています
 ので、パイプを使って PDF を出力する gnuplot スクリプトは、PDFlib のあ
 るバージョンでだけしかちゃんと動かないかもしれません。

 外部ライブラリ svgalib (linux, vgadl ドライバで使用):
 これは gnuplot が root に setuid (嫌!) されることを要求しますし、ビデ
 オカードや X11 で使用されるグラフィックドライバに特有の多くのバグがあ
 ります。

 国際化 (ロケールの設定):
 gnuplot は、入出力の数、時刻、日付文字列のロケールに依存した書式の制御
 を、C ランタイムライブラリに含まれる setlocale() を用いて行うので、ロ
 ケールの有効性や、ロケール機能のサポートのレベル (例えば数字の 3 桁毎
 の区切り文字など) などは、あなたのコンピュータが提供する国際化のサポー
 トの度合いに依存します。
