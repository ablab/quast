# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package mummer;
use base qw(Exporter);
use base qw(DynaLoader);
package mummerc;
bootstrap mummer;
package mummer;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package mummer;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package mummer;

*set_num_threads = *mummerc::set_num_threads;
*get_num_threads = *mummerc::get_num_threads;
*align_sequences = *mummerc::align_sequences;

############# Class : mummer::LongVector ##############

package mummer::LongVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( mummer );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = mummerc::new_LongVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *mummerc::LongVector_size;
*empty = *mummerc::LongVector_empty;
*clear = *mummerc::LongVector_clear;
*push = *mummerc::LongVector_push;
*pop = *mummerc::LongVector_pop;
*get = *mummerc::LongVector_get;
*set = *mummerc::LongVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mummerc::delete_LongVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : mummer::Alignment ##############

package mummer::Alignment;
use overload
    '""' => sub { $_[0]->__str__()},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( mummer );
%OWNER = ();
%ITERATORS = ();
*swig_dirB_get = *mummerc::Alignment_dirB_get;
*swig_dirB_set = *mummerc::Alignment_dirB_set;
*swig_sA_get = *mummerc::Alignment_sA_get;
*swig_sA_set = *mummerc::Alignment_sA_set;
*swig_sB_get = *mummerc::Alignment_sB_get;
*swig_sB_set = *mummerc::Alignment_sB_set;
*swig_eA_get = *mummerc::Alignment_eA_get;
*swig_eA_set = *mummerc::Alignment_eA_set;
*swig_eB_get = *mummerc::Alignment_eB_get;
*swig_eB_set = *mummerc::Alignment_eB_set;
*swig_delta_get = *mummerc::Alignment_delta_get;
*swig_delta_set = *mummerc::Alignment_delta_set;
*swig_deltaApos_get = *mummerc::Alignment_deltaApos_get;
*swig_deltaApos_set = *mummerc::Alignment_deltaApos_set;
*swig_Errors_get = *mummerc::Alignment_Errors_get;
*swig_Errors_set = *mummerc::Alignment_Errors_set;
*swig_SimErrors_get = *mummerc::Alignment_SimErrors_get;
*swig_SimErrors_set = *mummerc::Alignment_SimErrors_set;
*swig_NonAlphas_get = *mummerc::Alignment_NonAlphas_get;
*swig_NonAlphas_set = *mummerc::Alignment_NonAlphas_set;
*identity = *mummerc::Alignment_identity;
*similarity = *mummerc::Alignment_similarity;
*stopity = *mummerc::Alignment_stopity;
*__str__ = *mummerc::Alignment___str__;
sub new {
    my $pkg = shift;
    my $self = mummerc::new_Alignment(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mummerc::delete_Alignment($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : mummer::AlignmentVector ##############

package mummer::AlignmentVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( mummer );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = mummerc::new_AlignmentVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *mummerc::AlignmentVector_size;
*empty = *mummerc::AlignmentVector_empty;
*clear = *mummerc::AlignmentVector_clear;
*push = *mummerc::AlignmentVector_push;
*pop = *mummerc::AlignmentVector_pop;
*get = *mummerc::AlignmentVector_get;
*set = *mummerc::AlignmentVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mummerc::delete_AlignmentVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : mummer::Options ##############

package mummer::Options;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( mummer );
%OWNER = ();
%ITERATORS = ();
*mum = *mummerc::Options_mum;
*mumcand = *mummerc::Options_mumcand;
*mumreference = *mummerc::Options_mumreference;
*maxmatch = *mummerc::Options_maxmatch;
*breaklen = *mummerc::Options_breaklen;
*banded = *mummerc::Options_banded;
*nobanded = *mummerc::Options_nobanded;
*mincluster = *mummerc::Options_mincluster;
*diagdiff = *mummerc::Options_diagdiff;
*diagfactor = *mummerc::Options_diagfactor;
*extend = *mummerc::Options_extend;
*noextend = *mummerc::Options_noextend;
*forward = *mummerc::Options_forward;
*maxgap = *mummerc::Options_maxgap;
*minmatch = *mummerc::Options_minmatch;
*optimize = *mummerc::Options_optimize;
*nooptimize = *mummerc::Options_nooptimize;
*reverse = *mummerc::Options_reverse;
*simplify = *mummerc::Options_simplify;
*nosimplify = *mummerc::Options_nosimplify;
*swig_min_len_get = *mummerc::Options_min_len_get;
*swig_min_len_set = *mummerc::Options_min_len_set;
*swig_fixed_separation_get = *mummerc::Options_fixed_separation_get;
*swig_fixed_separation_set = *mummerc::Options_fixed_separation_set;
*swig_max_separation_get = *mummerc::Options_max_separation_get;
*swig_max_separation_set = *mummerc::Options_max_separation_set;
*swig_min_output_score_get = *mummerc::Options_min_output_score_get;
*swig_min_output_score_set = *mummerc::Options_min_output_score_set;
*swig_separation_factor_get = *mummerc::Options_separation_factor_get;
*swig_separation_factor_set = *mummerc::Options_separation_factor_set;
*swig_use_extent_get = *mummerc::Options_use_extent_get;
*swig_use_extent_set = *mummerc::Options_use_extent_set;
*swig_do_delta_get = *mummerc::Options_do_delta_get;
*swig_do_delta_set = *mummerc::Options_do_delta_set;
*swig_do_extend_get = *mummerc::Options_do_extend_get;
*swig_do_extend_set = *mummerc::Options_do_extend_set;
*swig_to_seqend_get = *mummerc::Options_to_seqend_get;
*swig_to_seqend_set = *mummerc::Options_to_seqend_set;
*swig_do_shadows_get = *mummerc::Options_do_shadows_get;
*swig_do_shadows_set = *mummerc::Options_do_shadows_set;
*swig_break_len_get = *mummerc::Options_break_len_get;
*swig_break_len_set = *mummerc::Options_break_len_set;
*swig_banding_get = *mummerc::Options_banding_get;
*swig_banding_set = *mummerc::Options_banding_set;
sub new {
    my $pkg = shift;
    my $self = mummerc::new_Options(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mummerc::delete_Options($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package mummer;

1;
